{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A library for various muxing and automation tools for anything and everything fansubbing related. The guide here is essentially a glorified examples section but I heard it works well enough.</p> <p><code>muxtools</code> contains all functionality that's possible without having vapoursynth. <code>vsmuxtools</code> is the extension to it that adds some more functionality to some existing functions but also adds all video encoding stuff. It also exports everything from muxtools so you should ever only have to use/import vs-muxtools if you have vapoursynth.</p>"},{"location":"#installation","title":"Installation","text":"<p>Git is always the most updated one obviously but I can't guarantee that everything is in a working state. vs-muxtools depends on muxtools so you should uninstall both and reinstall starting with muxtools if you need latest git. <pre><code>pip install git+https://github.com/Jaded-Encoding-Thaumaturgy/muxtools.git\npip install git+https://github.com/Jaded-Encoding-Thaumaturgy/vs-muxtools.git\n</code></pre>  You can also grab the latest stable ish versions from pip.</p> <p>muxtools </p> <p>vsmuxtools </p>"},{"location":"examples/adapt-subkt/","title":"Adapting a subkt project to muxtools","text":"<p>This script was made as a proof-of-concept for the new timestamps processing. Should be a 1:1 port of the Kaleido-Subs Blue Archive project.</p> Script <pre><code># ruff: noqa: F405 F403\nfrom muxtools import *\n\nepisode = int(input(\"Please enter an episode number: \"))\n\nsetup = Setup(\n    f\"{episode:02d}\",\n    None,\n    show_name=\"Blue Archive\",\n    out_name=R\"$show$ - S01E$ep$ (BD 1080p HEVC) [Kaleido-Test-Mux]\",\n    mkv_title_naming=R\"$show$ - S01E$ep$ - $title$\",\n    out_dir=\"muxed\",\n    clean_work_dirs=False,\n)\n\nvideo_file = GlobSearch(f\"*Kaleido*Archive* - S01E{setup.episode}*.mkv\", dir=\"D:/\")\n\n# Use timecodes from video for calculations in shifts and merges and what not\n# This is technically optional but you will get spammed with warnings.\nsetup.set_default_sub_timesource(video_file)\n\npremux = Premux(video_file, subtitles=None, keep_attachments=False, mkvmerge_args=[\"--no-global-tags\", \"--no-chapters\"])\n\nsub_kaleido = SubFile(GlobSearch(\"*.ass\", allow_multiple=True, dir=f\"./{setup.episode}\"))\n\nchapters = Chapters.from_sub(sub_kaleido, use_actor_field=True) # Doing this later would grab stuff from the NCs lol\n\nif episode not in [1, 12]:\n    # Non-default shift_mode because that's what subkt uses.\n    # I don't think shifting by time directly should be considered good practice but people want to match the behavior I guess.\n    sub_kaleido.merge(\"./NCOP1/BlueArchive NCOP1.ass\", \"opsync\", \"sync\", no_error=True, shift_mode=ShiftMode.TIME)\n    sub_kaleido.merge(\"./NCED1/BlueArchive NCED1.ass\", \"edsync\", \"sync\", no_error=True, shift_mode=ShiftMode.TIME)\n\nsub_kaleido.merge(\"./common/warning.ass\")\nsub_kaleido.clean_garbage().clean_extradata().set_headers(\n    (ASSHeader.PlayResX, 1920),\n    (ASSHeader.PlayResY, 1080),\n    (ASSHeader.LayoutResX, 1920),\n    (ASSHeader.LayoutResY, 1080),\n    (ASSHeader.YCbCr_Matrix, \"TV.709\"),\n    (ASSHeader.ScaledBorderAndShadow, True),\n    (ASSHeader.WrapStyle, 2),\n    (\"Title\", \"Kaleido-subs\")\n)\n\nsub_enm = sub_kaleido.copy().autoswapper()\n\nsub_official = SubTrack(f\"./{setup.episode}/BlueArchive {setup.episode} - Dialogue (Nexon).srt\", \"English (Official/Nexon)\", \"en\", False)\n# Alternatively convert to ass with\n# SubFile.from_srt(f\"./{setup.episode}/BlueArchive {setup.episode} - Dialogue (Nexon).srt\")\n\nfonts = sub_kaleido.collect_fonts(use_system_fonts=False)\n\nmux(\n    premux,\n    sub_kaleido.to_track(\"English\", \"en\"),\n    sub_enm.to_track(\"English (Honorifics)\", \"enm\"),\n    sub_official,\n    *fonts,\n    chapters,\n    tmdb=TmdbConfig(218833)\n)\n</code></pre>"},{"location":"examples/random-cyberpunk-mux/","title":"Batch Mux script for a private cyberpunk mux","text":"Script <pre><code>from muxtools import Setup, GlobSearch, Premux, SubFile, mux, TmdbConfig\n\nfor i in range(1, 11):\n    # Basic Setup for every episode without a config file\n    setup = Setup(\n        f\"{i:02d}\",  # Format to have padded zeros\n        None,\n        show_name=\"Cyberpunk Edgerunners\",\n        out_dir=R\"D:\\Compings\\muxed\",\n        mkv_title_naming=R\"$show$ - S01E$ep$ - $title$\",\n        out_name=R\"[Styx] $show$ - S01E$ep$ [WEB 1080p HEVC]\",\n        clean_work_dirs=True,\n    )\n    bobbington = GlobSearch(f\"*choom* - {setup.episode}*.mkv\", dir=R\"D:\\Compings\\b\")\n    nfweb = GlobSearch(f\"*Cyberpunk Edgerunners - {setup.episode}*GerEngSub*.mkv\", dir=R\"D:\\Compings\\b\")\n\n    premux = Premux(\n        bobbington,\n        keep_attachments=False,\n        subtitles=None,\n        mkvmerge_args='--no-global-tags --track-name 0:\"choom/MTBB Encode\" --track-name 1:\"Japanese 5.1 (Netflix)\"',\n    )\n\n    audios = Premux(\n        nfweb,\n        video=None,\n        audio=[0, 1],\n        subtitles=None,\n        keep_attachments=False,\n        mkvmerge_args='--no-global-tags --no-chapters --track-name 1:\"German 5.1 (Netflix)\" --track-name 2:\"English 5.1 (Netflix)\"',\n    )\n    sub_en = SubFile.from_mkv(bobbington.paths, 0).clean_styles()\n    sub_ger = SubFile.from_mkv(nfweb.paths, 1).clean_styles()\n    sub_ger_signs = SubFile.from_mkv(nfweb.paths, 0).clean_styles()\n\n    # Every font collector call will just dump them into the workdir and then return all including ones are already there.\n    sub_ger_signs.collect_fonts()\n    sub_en.collect_fonts()\n    fonts = sub_ger.collect_fonts()\n\n    mux(\n        premux,\n        audios,\n        sub_en.to_track(\"English (whomst modified)\"),\n        sub_ger.to_track(\"German (Netflix modified)\", \"ger\", False, False),\n        sub_ger_signs.to_track(\"German Signs &amp; Songs (Netflix)\", \"ger\", False, True),\n        *fonts,\n        tmdb=TmdbConfig(105248, write_title=True, write_ids=True),\n    )\n</code></pre>"},{"location":"examples/sample-encode-script/","title":"Basic encode script with multiple sources","text":"Script <pre><code>from vsmuxtools import * # Doing this is technically bad practise but I don't really have to worry about name collision here\nfrom vspreview import is_preview\nfrom awsmfunc import fixlvls\nfrom vodesfunc import out\n\nimport JJKcommon as common\nimport JJKbdmvs as bdmv\n\nsetup = Setup(\"03\")\n\nstronger_deband = []\nlol_deband = []\nheavy_aa = []\nwtf = []\nlower_thresh = []\n\nop_start_frame = 4603\ned_start_frame = 30569\n\nzone_up = []\nzone_slightly = []\nzone_down = [(16064, 16303)]\n\nif op_start_frame != -1:\n    lol_deband.append((op_start_frame + 1167, op_start_frame + 1177))\n    lol_deband.append((op_start_frame + 1383, op_start_frame + 1399))\n    zone_slightly.append((op_start_frame, op_start_frame + 2157))\n\nITBD = FileInfo(bdmv.get_episode_itbd(), force_lsmas=True, trim=(12, -12))\nDEBD = FileInfo(bdmv.get_episode_debd(), force_lsmas=True)\nUKBD = FileInfo(bdmv.get_episode_ukbd(), force_lsmas=True)\nKAIZOKU = FileInfo(\n    GlobSearch(f\"*Jujutsu Kaisen - {setup.episode}*.mkv\", dir=R\"\\\\diablo\\Vault\\Misc\\Media\\[Kaizoku] Jujutsu Kaisen (BD 1080p)\"),\n    force_lsmas=True,\n)\n\nfiltered = common.filter_chain(ITBD.init_cut(), stronger_deband, heavy_aa, wtf, lol_deband)\n\nchapters = Chapters(ITBD, _print=False).set_names([\"Prologue\", \"Opening\", \"Part A\", \"Part B\", \"Ending\", \"Preview\"]).print()\n\nif is_preview():\n    out(ITBD.src_cut, \"ITBD\")\n    out(filtered[0], \"Filtered\")\n    out(fixlvls(DEBD.init_cut()), \"DEBD (Gamma fixed)\")\n    out(UKBD.src_cut, \"UKBD\")\n    out(KAIZOKU.src_cut[:2] + KAIZOKU.src_cut, \"Kaizoku\")\n    print(lol_deband)\nelse:\n    settings = sb265(7, 13.7, rect=False, tskip=True, append=\"--aq-bias-strength 0.9\")\n    zones = [(a, b, 1.2) for a, b in zone_up]\n    zones.extend([(a, b, 1.1) for a, b in zone_slightly])\n    zones.extend([(a, b, 0.8) for a, b in zone_down])\n\n    jp, en, de = encode_audio(ITBD, 1), encode_audio(UKBD), encode_audio(DEBD)\n    video = x265(settings, zones, qp_clip=ITBD).encode(filtered[0])\n    mux(\n        video.to_track(\"Vodes Encode\"),\n        jp.to_track(\"Japanese 2.0\"),\n        en.to_track(\"English 2.0\", \"en\"),\n        de.to_track(\"German 2.0\", \"de\"),\n        chapters,\n        tmdb=TmdbConfig(95479),\n    )\n</code></pre>"},{"location":"examples/scripts-with-config/","title":"Example scripts with config","text":""},{"location":"examples/scripts-with-config/#muxing-of-my-jigokuraku-fansub","title":"Muxing of my Jigokuraku fansub","text":"config.ini <pre><code>[SETUP]\nbdmv_dir = ./\nshow_name = Jigokuraku\nallow_binary_download = True\nclean_work_dirs = True\nout_dir = muxed\nout_name = [Nirvana] $show$ - S01E$ep$ [WEB 1080p HEVC] [$crc32$]\nmkv_title_naming = Hell's Paradise - $ep$ - $title$\n</code></pre> Script <pre><code>from muxtools import Setup, Premux, GlobSearch, SubFile, mux, TitleTMDB\n\nsetup = Setup(\"09\")\n\npremux = Premux(f\"./premux/Jigokuraku - {setup.episode} (premux).mkv\")\n\ndialogue = GlobSearch(\"*Dialogue*.ass\", dir=f\"./{setup.episode}/\")\ntypesetting = GlobSearch(\"*TS*.ass\", dir=f\"./{setup.episode}/\").paths\nif not typesetting:\n    typesetting = GlobSearch(\"*Sign*.ass\", dir=f\"./{setup.episode}/\").paths\n\nsongs = [\"./songs/OP.ass\", \"./songs/ED.ass\"]\nsub = SubFile([dialogue.paths, typesetting]) \\\n    .merge(songs[0], \"opsync\").merge(songs[1], \"edsync\")\n\nfonts = sub.collect_fonts()\n\nmux(premux, sub.to_track(\"English\"), *fonts, tmdb=TitleTMDB(117465))\n</code></pre>"},{"location":"examples/scripts-with-config/#aergia-ristorante-paradiso-mux-script","title":"[Aergia] Ristorante Paradiso mux script","text":"config.ini <pre><code>[SETUP]\nbdmv_dir = ./\nshow_name = Ristorante Paradiso\nallow_binary_download = False\nclean_work_dirs = True\nout_dir = [Aergia] Ristorante Paradiso (WEB-DL 1080p AVC AC-3)\nout_name = [Aergia] $show$ - $ep$ (WEB-DL 1080p AVC AC-3)\nmkv_title_naming = $show$ $ep$ - $title$\ndebug = True\n</code></pre> Script <pre><code>from muxtools import Setup, VideoTrack, AudioTrack, SubTrack, TitleTMDB, mux\nfrom fractions import Fraction\n\n\naudio_delays = (9, -8, 9, 15, 9, -8, 9, -8, 9, 0, 6)\n\nfor i in range(1, 11 + 1):\n    setup = Setup(\n        f\"{i:02d}\",\n        show_name=\"Ristorante Paradiso\",\n        allow_binary_download=False,\n        clean_work_dirs=True,\n    )\n\n    video = VideoTrack(rf\"{setup.bdmv_dir}\\Video\\{setup.episode}.avc\", name=\"Netflix WEB-DL\")\n    audio = AudioTrack(\n        rf\"{setup.bdmv_dir}\\Audio\\{setup.episode}.ac3\", name=\"Japanese 2.0 AC-3\", delay=audio_delays[i - 1]\n    )\n    subtitles = SubTrack(rf\"{setup.bdmv_dir}\\Subtitles\\{setup.episode}.sup\", name=\"Full Subtitles (Right Stuf)\")\n\n    mux(video, audio, subtitles, rf\"{setup.bdmv_dir}\\Chapters\\{setup.episode}.xml\", tmdb=TitleTMDB(34855))  # type: ignore\n\n\nncs = (\"NCOP\", \"NCED\")\nnames = (\"Marigold\", \"Suteki na Kajitsu\")\nsar = Fraction(6, 5) * 720 / 480\n\nfor i in range(len(ncs)):\n    setup = Setup(\n        ncs[i],\n        show_name=\"Ristorante Paradiso\",\n        allow_binary_download=False,\n        clean_work_dirs=True,\n    )\n\n    setup.edit(\"title\", names[i])\n    setup.edit(\"out_name\", \"[Aergia] $show$ - $ep$ (DVDRemux 480p MPEG-2 AC-3)\")\n\n    video = VideoTrack(\n        rf\"{setup.bdmv_dir}\\Video\\{setup.episode}.mpg\",\n        name=\"R2J DVD\",\n        crop=(0, 0, 0, 2),\n        args=[\"--display-dimensions\", f\"0:{sar.numerator}x{sar.denominator}\"],\n    )\n    audio = AudioTrack(rf\"{setup.bdmv_dir}\\Audio\\{setup.episode}.ac3\", name=\"Japanese 2.0 AC-3\")\n    subtitles = SubTrack(rf\"{setup.bdmv_dir}\\Subtitles\\{setup.episode}.sup\", name=\"Full Subtitles (Right Stuf)\")\n\n    mux(video, audio, subtitles)  # type: ignore\n</code></pre>"},{"location":"guide/dynamic-dataclasses/","title":"Dynamic Dataclasses","text":"<p>Since (vs-)muxtools 0.2.0 all video and audio encoders use pydantic dataclasses. These allow users to pass kwargs to them.</p> <p>These kwargs are used to pass custom params to the encoder processes. Have a look at part of the <code>CLIKwargs</code> class docstring here: <pre><code>test = Encoder(clip, colorspace=\"BT709\")\nprint(test.get_custom_args())\n# returns ['--colorspace', 'BT709']\n\n# if it starts with an _ it will be a single - argument\n# empty values will be stripped\ntest = Encoder(clip, _vbr=\"\")\nprint(test.get_custom_args())\n# returns ['-vbr']\n\n# if it ends with an _ it will preserve underscores\ntest = Encoder(clip, _color_range_=\"limited\")\nprint(test.get_custom_args())\n# returns ['-color_range', 'limited']\n</code></pre></p>"},{"location":"guide/dynamic-dataclasses/#yes-append-is-still-supported","title":"Yes, <code>append</code> is still supported","text":"<p>... and now also almost everywhere and better!</p> <pre><code>test = Encoder(clip, append=\"-vbr --bitrate 192\")\ntest = Encoder(clip, append=[\"-vbr\", \"--bitrate\", \"192\"])\ntest = Encoder(clip, append={\"-vbr\": \"\", \"--bitrate\": \"192\"})\n# all of them return ['-vbr', '--bitrate', '192']\n</code></pre>"},{"location":"guide/dynamic-dataclasses/#practical-uses","title":"Practical Uses","text":"<p>In terms of video encoders I mostly implemented this to serve SVTAV1 and the FFMPEG encoders.</p> <p>You can for example do something like <pre><code>SVTAV1(qp_clip=src, sharpness=3, film_grain=3, tune=3, variance_boost_strength=3, variance_octile=5, frame_luma_bias=20)\n</code></pre> and you will find that most of these params are not actually defined in the <code>SVTAV1</code> class constructor. They will however still get passed to it as <code>--sharpness 3 --film-grain 3 --variance-boost-strength 3 --variance-octile 5 --frame-luma-bias 20</code>.</p> <p>This will also work for x264/5 but considering the settings there are just a string to begin with, I don't see much of a point.</p>"},{"location":"guide/dynamic-dataclasses/#affinity","title":"Affinity","text":"<p>This only<sup>1</sup> applies to the video encoders but you can now pass an <code>affinity</code> kwarg to the classes.</p> <p>Just like the vs-tools <code>set_affinity</code> function, this will lock the process (of the encoder, instead of vapoursynth) to the cores you request.</p> <p>A fun and interesting tidbit that inspired me to write this is that SVTAV1 seems to always inherit the affinity of the parent that started it. Which means that it would be locked to the same affinity you set for your filtering when using it through muxtools. muxtools simply overwrites it to use all cores now if nothing custom was passed.</p> <ol> <li> <p>Make an issue if you want to see that for audio stuff. Can't think of a usecase tho.\u00a0\u21a9</p> </li> </ol>"},{"location":"guide/encode-audio/","title":"Audio Encoding","text":""},{"location":"guide/encode-audio/#available-encoders","title":"Available Encoders","text":"<p>There are plenty with varying degrees of usefulness.</p>"},{"location":"guide/encode-audio/#lossless","title":"Lossless","text":"<ul> <li>FLAC (libFLAC)</li> <li>FLACCL (included in CUETools)</li> <li>FF_FLAC (FF = FFMPEG)</li> <li>TTA/TrueAudio</li> <li>Wavpack</li> <li>ALAC via qaac</li> </ul>"},{"location":"guide/encode-audio/#lossy","title":"Lossy","text":"<ul> <li>Opus via opusenc</li> <li>AAC via qaac</li> <li>AAC via FDK_AAC (in non-free builds of ffmpeg but also works with the binary)</li> <li>LossyWAV (This one is a lossy preprocessor for other lossless codecs to save size)</li> </ul>"},{"location":"guide/encode-audio/#available-extractorstrimmers","title":"Available Extractors/Trimmers","text":""},{"location":"guide/encode-audio/#extractors","title":"Extractors","text":"<ul> <li>FFMPEG</li> <li>eac3to</li> </ul> <p>Eac3to is at this point fully obsolete because of our ffmpeg implementation. There's only really a use for it if you need to add silence to something proprietary like TrueHD Atmos or DTS:X without reencoding.</p>"},{"location":"guide/encode-audio/#trimmers","title":"Trimmers","text":"<ul> <li>FFMPEG</li> <li>SoX</li> </ul> <p>SoX only works with lossless files and always uses wav internally. It also is more accurate than FFMPEG and as such should be your default for lossless. FFMPEG can somewhat decently trim and concat lossy audio and we implemented something similar to the eac3to delay thing to have a more accurate end result.</p>"},{"location":"guide/encode-audio/#basic-usage","title":"Basic Usage","text":""},{"location":"guide/encode-audio/#all-in-one-function","title":"All-in-one Function","text":"<p>There's this neat little <code>do_audio</code> function that should satisfy all your needs. If you don't pass any extractors, trimmers or encoders it will choose:</p> <ul> <li> <p>FFMPEG as the extractor</p> </li> <li> <p>SoX or FFMPEG for the trimmer depending on if the input is lossy (the latter if it is)</p> </li> <li> <p>Opus as the encoder if lossless and otherwise it will choose to not encode</p> </li> </ul> <p>If you already have wav files to work with you can also pass <code>None</code> to the extractor param to skip that step.</p> <pre><code>from vsmuxtools import src_file, Wavpack, do_audio # Another alias for this would be encode_audio\n\nfile = R\"00008.m2ts\"\naudio = do_audio(file, 1, encoder=Wavpack())\n\n# You can also pass a src_file with the vs(!)-muxtools extension.\n# This will automatically apply the src_file trim if you don't pass any yourself.\nITBD = src_file(file, trim=(24, -24))\naudio = do_audio(ITBD, 0)\n\n# If you want to choose everything\nfrom vsmuxtools import FFMpeg, Sox, TrueAudio\n\naudio = do_audio(JPBD, track=0, extractor=FFMpeg.Extractor(preserve_delay=False), trimmer=Sox(), encoder=TrueAudio())\n</code></pre>"},{"location":"guide/encode-audio/#step-by-step","title":"Step by step","text":"<p>Of course you're not forced to use <code>do_audio</code>.</p> <pre><code>from vsmuxtools import FFMpeg, Sox, FLAC, DitherType, src_file, Resample\n\nITBD = src_file(R\"00008.m2ts\", trim=(24, -24))\n\naudio = FFMpeg.Extractor(track=1).extract_audio(ITBD.file)\naudio = Sox(trim=[(24, 500), (800, 1245)], fps=Fraction(24000, 1001)).trim_audio(audio)\naudio = FLAC(preprocess=Resample(dither=DitherType.LOW_SHIBATA)).encode_audio(audio)\n</code></pre> <p>All of those <code>audio</code> variables are a <code>AudioFile</code> object. To get the filepath you simply do <code>audio.file</code>.</p> <p>Same deal as with the encodes these also have a <code>to_track()</code> function to create a track with metadata. (Defaults to <code>lang='jp', default=True, forced=False</code>)</p>"},{"location":"guide/encode-audio/#preprocessing","title":"Preprocessing","text":"<p>(Almost) every encoder also supports various preprocessing options. Currently implemented are:</p> <ul> <li> <p>Resample   To change sample rate or bitdepth</p> </li> <li> <p>Downmix / Pan   The ffmpeg pan filter with a few presets for better/more dynamic downmixing</p> </li> <li> <p>Loudnorm   A ffmpeg based normalization implementation according to EBU-R128 standards.   This also uses the two-pass methodology as described here and used in the ffmpeg-normalize utility.</p> </li> </ul>"},{"location":"guide/encode-audio/#example-usage","title":"Example usage","text":"<pre><code># Lossless encoders use the Resample preprocessor by default (which defaults to 16bit and 48kHz)\naudio = do_audio(file, 1, encoder=FLAC())\n\n# Can be entirely disabled like this\naudio = do_audio(file, 1, encoder=FLAC(preprocess=None))\n\n# You can also chain them like this\naudio = do_audio(file, 1, encoder=FLAC(preprocess=[Pan(Pan.RFC_7845), Resample(DitherType.LIPSHITZ)]))\n\n# Or define your own with either ffmpeg args or an ffmpeg audio-filter\naudio = do_audio(file, 1, encoder=FLAC(preprocess=[\n    Resample(DitherType.LIPSHITZ),\n    # In this case, the filter creates a massive echo effect (the args are obviously nonsense)\n    CustomPreprocessor(filt=\"aecho=0.8:0.9:1000:0.3\", args=[\"--example\", \"value\"])\n]))\n</code></pre>"},{"location":"guide/encode-video/","title":"Video Encoding","text":""},{"location":"guide/encode-video/#x264-x265","title":"x264 &amp; x265","text":"<p>Lossy encoders targetting quality. These two also support resuming from previous parts of the encode in case it crashed or whatever.  It's done somewhat automagically and you don't really have to worry about it.</p>"},{"location":"guide/encode-video/#ffv1","title":"FFV1","text":"<p>FFMPEG's lossless codec. Basically the lossless codec to use. Supports just about everything and has way better compression than lossless x264.</p>"},{"location":"guide/encode-video/#losslessx264","title":"LosslessX264","text":"<p>Another option for lossless encodes. Way worse compression than FFV1 but also way faster. Limited to 10 bit video.</p>"},{"location":"guide/encode-video/#svtav1","title":"SVTAV1","text":"<p>An AV1 encoder that has proper threading capabilities standalone and is still competitive with others. You can of course use SVT-AV1-PSY with muxtools too.</p>"},{"location":"guide/encode-video/#basic-usage","title":"Basic Usage","text":"<pre><code>from vsmuxtools import src_file, x265, x264, FFV1, LosslessX264, LosslessPreset, settings_builder_x265, settings_builder_x264\nfrom vstools import vs, core, finalize_clip\n\nJPBD = src_file(R\"F:\\BDMV\\Main Disc\\BDMV\\STREAM\\00002.m2ts\", True, (24, 500))\n\n# This calls initialize_clip from vstools which creates a 16 bit clip to work with\nsrc = JPBD.init_cut()\n\nfiltered = denoise(src)\nfiltered = grain(filtered)\n\noutput = finalize_clip(filtered)\n\n# This will run if the current script is started without vspreview and whatnot\n# Alternatively you can use: if not vspreview.is_preview():\nif __name__ == \"__main__\":\n    # Convenience function to make a settings string\n    settings = settings_builder_x265(preset=\"slower\", crf=13.5)\n\n    # Basic bitrate multiplier zones\n    x265_zones = [(100, 400, 0.5), (450, 480, 1.25)]\n\n    # QP Clip can be a normal videonode or the src_file/FileInfo\n    # You can also pass existing files to the qp_file parameter\n    video_hevc = x265(settings, x265_zones, qp_clip=JPBD).encode(output)\n\n    # x264 Zones can be a bit more useful with params like crf\n    # You can still pass stuff like this with x265 but it can only do b and q.\n    x264_zones = [(100, 400, \"crf\", 15), (450, 480, \"crf\", 13)]\n\n    # You can also use a file with settings tho there's also a settings builder for x264\n    # QP file generation will be skipped in this example\n    video_avc = x264(R\"./path/x264_settings\", x264_zones).encode(output)\n\n    # These two have way less params and don't support resumable encodes.\n    # You only really have to care about the 3 presets this package offers.\n    video_ffv1 = FFV1(LosslessPreset.COMPRESSION).encode(output)\n    video_ll_avc = LosslessX264(LosslessPreset.SPEED).encode(output)\n</code></pre> <p>All of those <code>video_*</code> variables return a <code>VideoFile</code> object. To get the filepath you simply do <code>video_hevc.file</code>. Here you can also have your first look at the <code>to_track()</code> function of the <code>*File</code> types. These convert the File types to their respective track types. This will be needed for muxing later.</p>"},{"location":"guide/encode-video/#intermediaries","title":"Intermediaries","text":"<p>vs-muxtools 0.2.0+ has convenience classes for creating an intermediary and encoding that to one or many targets.</p> <pre><code># Encode clip to FFV1 first and then to the list of encoders (x265 and SVTAV1)\nIntermediaryEncoder(\n    LosslessX264(LosslessPreset.SPEED),\n    [\n        x265(settings_builder_x265(\"veryslow\", 13.5)),\n        SVTAV1(4, 18),\n    ],\n).encode(clip)\n\n# Can also do something like this\n\nIntermediaryEncoder(\n    LosslessX264(LosslessPreset.SPEED),\n    [\n        x265(settings_builder_x265(\"veryslow\", 13.5)),\n        (SVTAV1(4, 18), lambda clip: Hermite.scale(clip, 1280, 720)), # Downscales the intermediary and outputs that to SVTAV1\n    ],\n).encode(clip)\n</code></pre> <p>There's also a standalone ProResIntermediary class that automatically handles conversion to and from 422. The approach may still be very flawed but it didn't cause issues at a quick glance.</p>"},{"location":"guide/external-dependencies/","title":"External Dependencies","text":"<p>* = Cannot be auto downloaded on runtime ** = Cannot be downloaded using scoop</p>"},{"location":"guide/external-dependencies/#encoders","title":"Encoders","text":"<p>You only really need x264 and x265, depending on what you wanna use. I recommend these specific versions. Easily buildable on any platform if you're not on windows.</p> <ul> <li>x265-aMod** (by DJATOM)</li> <li>x264 t_mod**</li> <li>SVT-AV1-PSY***</li> </ul> <p>FFV1 &amp; ProRes are included with FFMPEG (see below)</p>"},{"location":"guide/external-dependencies/#other-utilities","title":"Other Utilities","text":"<ul> <li>FFMPEG   Probably the most important utility for this package.   It's used for TTA, FLAC, W64 and AIFF audio encoding and also ensures valid input for every other encoder.   Also used to extract existing audio track from other releases/containers.   Oh and of course used for FFV1 lossless video encoding.   If you're interested in AAC encoding via FDK AAC you might be interested in non-free builds like my own on GitHub or on scoop.</li> <li>eac3to</li> <li>SoX*</li> <li>MKVToolNix/mkvmerge/mkvextract*</li> <li>opus-tools   Used for opus encoding.   The official builds are yet to receive any updates for whatever reason so for the time being I'd recommend getting builds from rarewares.</li> <li>qaac   The best encoder for AAC, but it does ALAC aswell.   This one has a few quirks, like needing iTunes either installed or its libraries. Here's some detailed information in that and here are links to both iTunes Libs and a libFLAC you might need.</li> <li>FLAC (libFLAC)   Used for FLAC encoding</li> <li>CUETools**   Also used for FLAC encoding but with the FLACCL encoder instead.</li> <li>LossyWAV***   A lossy preprocessor you can use for FLAC and Wavpack to achieve smaller sizes.   Doesn't really have any advantage over a good lossy codec besides being funny.</li> <li> <p>Wavpack   Another lossless Codec one can use if they feel like it.</p> </li> <li> <p>Aegisub and aegisub-cli   Aegisub is basically the go-to subtitle editor. Useful for all kinds of subtitle related stuff.   Aegisub-CLI is (currently) only used for resampling in muxtools. Simply download it and place it right into your aegisub install folder.   (And don't forget to make sure that the install folder is also in your PATH)   For better resampling results, you might wanna get the <code>Resample Perspective</code> script in the Aegisub DependencyControl menu.</p> </li> </ul>"},{"location":"guide/external-dependencies/#tldr-i-dont-care","title":"TLDR, I don't care","text":"<p>You can also use the <code>muxtools</code> CLI functionality to automatically install everything not marked with <code>**</code> on windows.It will only ask you for tools you don't already have in PATH.</p> <p>Simply run <code>muxtools &lt;deps/dependencies&gt;</code> and you will find yourself getting prompts for everything.</p> <p>If you already have tools like SoX, Eac3to and qAAC installed, you might still want to have updated libraries for them.</p> <p>To get those you can run <code>muxtools &lt;libs/libraries&gt;</code>. (No need to do so if you did <code>deps</code> before this because that will run both)</p>"},{"location":"guide/getting-started/","title":"Getting started","text":"<p>Some necessities used/needed for essentially every script</p>"},{"location":"guide/getting-started/#setup","title":"Setup","text":"<p>For detailed information on every parameter, check the docs.</p> <pre><code>from vsmuxtools import Setup\n\nsetup = Setup(\"01\") # This is just the episode number\n</code></pre> <p>This is used for most if not all workflows in this package and should be set at the start of every script. Initially it will prompt you to fill out the generated <code>config.ini</code> file.</p> <p>This will create a work directory under <code>./_workdir/&lt;episode you passed&gt;</code>. Every function uses this as its default output. If you do decide to not use a Setup it will dump everything in your current directory.</p>"},{"location":"guide/getting-started/#src_file","title":"SRC_FILE","text":"<p>Simple convenience wrapper for sources.</p> <pre><code>from vstools import core\nfrom vsmuxtools import src_file # Other aliases for this are SRC_FILE and FileInfo\n\n# force_lsmas simply uses lsmashsource if True and otherwise tries to use DGIndexNV\nJPBD = src_file(R\"F:\\BDMV\\Main Disc\\BDMV\\STREAM\\00002.m2ts\", force_lsmas=True)\n\n# You can also set a initial trim, in this example it'll make the cut clip start at the 24th frame \n# and cut off 24 frames at the end\nJPBD = src_file(R\"F:\\BDMV\\Main Disc\\BDMV\\STREAM\\00002.m2ts\", trim=(24, -24))\n\n# You can also just set a custom indexing function that takes a path and returns a videonode\nJPBD = src_file(R\"F:\\BDMV\\Main Disc\\BDMV\\STREAM\\00002.m2ts\", idx = lambda file: core.lsmas.LWLibavSource(file))\n\n\n# This is the uncut/untrimmed clip\nsrc = JPBD.src\n\n# This is the clip with trims applied\nsrc = JPBD.src_cut\n\n# Same deal as above but now applying vstools.initialize_clip\n# (which makes a 16 bit clip by default and sets a bunch of useful props)\nsrc = JPBD.init()\nsrc = JPBD.init_cut()\n\n# If you need the AudioNode for this src_file you can also use these.\n# This just indexes the audio using bestsource. You can pass a track num and any other args as you wish.\naudio = JPBD.get_audio()\naudio = JPBD.get_audio_trimmed() # same deal as src/init_cut ofc\n</code></pre>"},{"location":"guide/muxing-tmdb/","title":"Muxing & TMDB","text":""},{"location":"guide/muxing-tmdb/#muxing","title":"Muxing","text":"<p>All of your muxing needs right here.</p> <p>Here I should maybe also mention the available \"tokens\" you can use for the filename and mkv title templates in your <code>Setup</code>.</p>"},{"location":"guide/muxing-tmdb/#tokens","title":"Tokens","text":"<ul> <li><code>$show$</code>     The show name. Taken from the current <code>Setup</code>.</li> <li><code>$ep$</code>     The episode number/string. Taken from the current <code>Setup</code>.</li> <li><code>$crc32$</code>     Used to generate a crc32 for the resulting mux.     You should probably not use this for the mkv title as setting mkv metadata will change the crc.</li> <li><code>$title$</code>     Token for the episode title. This will only work if you use the TMDB integration.</li> <li><code>$title_sanitized$</code>     Same as above but with the title_sanitization param in TMDBConfig applied to the string. </li> </ul> <p>You can also use any variable that's declared in Setup as a token. This also includes any \"unknown\" ones that you might have configured in the ini file.</p> <p>For example: If you have a <code>group_name</code> variable in the ini or set via Setup.edit you can just use <code>$group_name$</code> as a token in filenames or titles.</p>"},{"location":"guide/muxing-tmdb/#basic-usage","title":"Basic Usage","text":"<p>This assumes you have the variables created in the previous 3 wiki entries. (Encodes, Audio, Subs &amp; Chapters)</p> <pre><code>from vsmuxtools import Setup, mux\n\nsetup = Setup(\"01\")\n\nmux(\n    video_hevc.to_track(name=\"Vodes Encode\", lang=\"jpn\", default=True),\n    audio.to_track(\"Japanese 2.0 (Amazon)\", \"jpn\", True),\n    subtitle.to_track(\"English (CR)\", \"en\", True),\n    *fonts, # The * is necessary to unpack the list into multiple \"tracks\"\n    chapters\n)\n# Note that this just returns the Path of the resulting mux. You can do whatever you feel like with it.\n</code></pre>"},{"location":"guide/muxing-tmdb/#tmdb","title":"TMDB","text":"<p>This package has a TMDB Integration so you can have episode titles and other various metadata in your mux.</p> <pre><code>from vsmuxtools import mux, TitleTMDB, TmdbConfig, TMDBOrder\n\n# This is useful for if you don't really care about any of the other metadata besides the ep title.\nmux(..., tmdb=TitleTMDB(117465))\n\n# Otherwise you can have fun with every option using this\nmux(..., tmdb=TmdbConfig(117465, write_date=True, write_ids=True, write_summary=True))\n\n# You can also use episode groups/orders via their ID\n# This for example selects the *proper* season 2 for jujutsu kaisen.\nmux(..., tmdb=TmdbConfig(95479, 2, order=\"64a3fc4fe9da6900ae2fa807\"))\n\n# or auto-select an them using the enum\n# Automatically fetches the same ID as the example right above this.\nmux(..., tmdb=TmdbConfig(95479, 2, order=TMDBOrder.PRODUCTION))\n</code></pre>"},{"location":"guide/subtitles-and-chapters/","title":"Subtitles & Chapters","text":""},{"location":"guide/subtitles-and-chapters/#subtitles","title":"Subtitles","text":"<p>Uh... there are a lot of subtitle processing functions in the SubFile class. It would probably take a lot of time to explain them here again so go read the docs.</p>"},{"location":"guide/subtitles-and-chapters/#basic-usage","title":"Basic Usage","text":"<pre><code>from muxtools import SubFile, GJM_GANDHI_PRESET, GlobSearch, dummy_video\n\n# Might be worth noting that none of this touches the original input file\n# A copy to the work directory is always the first step\n# You can simply chain everything like this as they all return the SubFile object again\nsubtitle = SubFile(R\"test.ass\") \\\n    .resample(\"random video.mkv\") \\\n    .restyle(GJM_GANDHI_PRESET) \\\n    .clean_styles()\n\n# Also possible to resample with a dummy video\n# Might be worth noting that not specifying a video at all will always create a 1920x1080 dummy video\nsubtitle.resample(dummy_video(width=1920, height=1080))\n\n# You can do a basic merge of more 2+ files like this\nsubtitle = SubFile([R\"dialogue.ass\", R\"signs.ass\"])\n\n# ... or with a GlobSearch\nsubtitle = SubFile(GlobSearch(\"*_en.ass\", allow_multiple=True, dir=\"./subs/english\"))\n\n# Finally you can collect fonts\nfonts = subtitle.collect_fonts()\n</code></pre> <p>All of those <code>subtitle</code> variables are a <code>SubFile</code> object. To get the filepath you simply do <code>subtitle.file</code>.</p>"},{"location":"guide/subtitles-and-chapters/#merging-and-shifting","title":"Merging and shifting","text":"<p>Shifting and merging with syncs should be done with timestamps. You can pass a <code>timesource</code> to every function that works with frame &lt;-&gt; conversions. Subtitles specifically can also fetch a default from the <code>Setup</code>. See docs.</p> <p>If you never set one in either the functions or the Setup it will assume FPS timestamps with <code>24000/1001</code> and a timescale that's the usual on MKV files. And also print a warning because you probably shouldn't be doing that.</p> <pre><code>subtitle.merge(\n    \"./songs/OP.ass\", \n    \"opsync\", # Syncpoint in your current subtitle object/file\n    \"sync\", # Syncpoint in the OP file. If none given this will just be the first non-comment line (sorted by start time)\n    timesource=\"./premux/01.mkv\" # Where to take the timestamps &amp; timescale from.\n)\n</code></pre> <p>If you want to match SubKt in its merging with syncpoints behavior you need to set the <code>shift_mode</code> param. SubKt shifts by <code>TIME</code> directly without considering frames or a video file at all. You can see the available ones in the docs.</p> <p>There's also a full SubKt project port in the examples section.</p>"},{"location":"guide/subtitles-and-chapters/#chapters","title":"Chapters","text":"<p>As usual, check the docs for all the available functions you can use in Chapters.</p> <p>Note that this doesn't include the src_file part because it's not in muxtools. For that, check this.</p> <pre><code>from vsmuxtools import Chapters, src_file\n\n# If you pass a src_file it will try parsing it from the BDMV playlists if it detects a BDMV file stucture\n# ofc it will also account for the trims\nJPBD = src_file(R\"F:\\BDMV\\Main Disc\\BDMV\\STREAM\\00002.m2ts\", trim=(24, 500))\nchapters = Chapters(JPBD)\n\n# then you could set the names like\nchapters.set_names([\"Prologue\", \"Opening\", \"Part A\", \"Part B\", \"Ending\"])\n\n# You can also manually define chapters like this: (obviously frame numbers)\nchapters = Chapters([(0, \"Prologue\"), (2110, \"Opening\"), (4268, \"Episode\"), (32981, \"Ending\")])\n\n# You can easily save the chapters to a ogm file with this\n# If you don't pass your own output path it will default to \"current workdir/chapters.txt\"\nchapters.to_file()\n</code></pre> <p>The chapters take a <code>timesource</code> and <code>timescale</code> param aswell albeit defaulting to FPS timestamps without a warning. Using a <code>src_file</code> or doing <code>Chapters.from_mkv</code> will automatically fetch them from that respective video.</p> <p>Chapters will not fetch a default from the setup! (unless you're doing <code>Chapters.from_sub</code>)</p>"},{"location":"guide/subtitles-and-chapters/#also-notable","title":"Also notable","text":"<p>muxtools offers a CLI command for generating a VideoMeta json file.</p> <p>This may be of interest to you if you want to have all the necessary timestamp information in your fansub git repo. Perhaps to then do merges on CI and whatnot.</p> <p>The usage is literally just:  <pre><code>muxtools gen-vm \"path/to/your/video.mkv\"\nmuxtools generate-videometa \"video.mkv\" \"out.json\"\n</code></pre></p> <p>Output being optional and, if not given, creating a <code>video_meta.json</code> file in your current directory with these samples.</p>"},{"location":"misc/config-issue/","title":"How to no config issue","text":"<p>Last updated: 2024-03-29</p>"},{"location":"misc/config-issue/#vodes-nuke-vs-guidetm-the-ultimate-config-issue-solver","title":"Vodes-Nuke-VS-Guide\u2122\ufe0f (the ultimate config issue solver)","text":"<ul> <li>do you have python? if yes, nuke it and any site-packages (in appdata too)  folders</li> <li>uninstall vs and nuke plugins folder if you had it (%appdata%/Vapoursynth/plugins64) </li> <li>Install Python 3.12 (select for all users, when you click advanced or something like that in the installer)</li> <li>Install vapoursynth (select for all users)</li> <li><code>pip install git+https://github.com/vapoursynth/vsrepo.git</code> (if it doesn't work out of the box) </li> <li>install whatever plugins you need with vsrepo (run <code>vsrepo available</code> to see)</li> <li><code>pip install vsjet vodesfunc vsmuxtools</code></li> </ul>"},{"location":"misc/wav-and-friends/","title":"Wav and Friends","text":"<p>So you've probably heard of wav and w64 before. This page is meant to explain most notable containers to contain pcm with.</p>"},{"location":"misc/wav-and-friends/#formats","title":"Formats","text":""},{"location":"misc/wav-and-friends/#w64","title":"W64","text":""},{"location":"misc/wav-and-friends/#specification","title":"Specification","text":"<p>Also known as Sony Wave64. This is an extension to the original riff specification to add support for bigger files.</p> Usage FFMPEG <pre><code>ffmpeg -i \"$input\" -c:a pcm_s24le out.w64\n</code></pre>"},{"location":"misc/wav-and-friends/#rf64","title":"RF64","text":""},{"location":"misc/wav-and-friends/#specification-wikipedia","title":"Specification | Wikipedia","text":"<p>This is an extension to the original riff specification by the European Broadcasting Union. It has been accepted as the ITU recommendation ITU-R BS.2088.</p> Usage FFMPEG <pre><code># Auto means that it'll be regular wav until it exceeds 4GB.\nffmpeg -i \"$input\" -c:a pcm_s24le -rf64 auto out.wav\n</code></pre>"},{"location":"misc/wav-and-friends/#aiff","title":"AIFF","text":"<p>Audio Interchange File Format</p>"},{"location":"misc/wav-and-friends/#specification-wikipedia_1","title":"Specification | Wikipedia","text":"<p>Essentially the Apple equivalent of the regular RIFF/WAVE format and also limited to 4GB. Not recommended.</p> Usage FFMPEG <pre><code>ffmpeg -i \"$input\" -c:a pcm_s24be out.aiff\n</code></pre>"},{"location":"misc/wav-and-friends/#caf","title":"CAF","text":"<p>Core Audio Format</p>"},{"location":"misc/wav-and-friends/#specification-wikipedia_2","title":"Specification | Wikipedia","text":"<p>Essentially the Apple equivalent of RF64.</p> Usage FFMPEG <pre><code>ffmpeg -i \"$input\" -c:a pcm_s24le out.caf\n</code></pre>"},{"location":"misc/wav-and-friends/#what-should-i-use","title":"What should I use","text":"<p>If you're mainly using Apple devices and software exclusive to that ecosystem the answer is simple: CAF.</p> <p>If not: The answer is complicated. From my own experience and from what I gathered in various forum posts<sup>1</sup><sup>2</sup> and blogs<sup>3</sup><sup>4</sup> RF64 is more widely supported by both hardware and software.</p>"},{"location":"misc/wav-and-friends/#the-chaotic-good","title":"The chaotic good","text":"<p>If your software supports it... you should just use FLAC. There's no gamble if it supports one or any of the 64-bit WAV extensions/deviations. It usually either supports FLAC or it doesn't.</p> <p>With FLAC you get a more concrete spec that software is less likely to misinterpret and other things<sup>5</sup> less useful for the purpose of having an intermediary file. If you just want a file to input to something else, low compression levels are actually ridiculously fast<sup>6</sup> to encode on modern hardware!</p> Usage <pre><code># If you don't care about compression and just want speed\nflac -0 -o \"out.flac\" \"$input\"\n\n# The reference flac encoder is better but ffmpeg is also an option\nffmpeg -i \"$input\" -c:a flac -compression_level 0 \"out.flac\"\n</code></pre> <ol> <li> <p>https://gearspace.com/board/music-computers/1086321-do-you-use-rf64.html \u21a9</p> </li> <li> <p>https://forums.cockos.com/showpost.php?s=10bbd1b868d37f653ec4e36a6de1cb5a&amp;p=1845069&amp;postcount=2 \u21a9</p> </li> <li> <p>Bjorn Roche - WAVE64 vs RF64 vs CAF \u21a9</p> </li> <li> <p>https://trptk.com/one-wav-or-the-other-wav-formats-explained \u21a9</p> </li> <li> <p>Integrity checks in the encoder and error detection in the decoder, actual metadata support, obviously lossless compression\u00a0\u21a9</p> </li> <li> <p>Like 2 seconds to encode an anime episode's audio (24 minutes) with <code>flac -0</code> on my machine\u00a0\u21a9</p> </li> </ol>"},{"location":"muxtools/chapters/","title":"chapters","text":""},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters","title":"<code>Chapters</code>","text":"Source code in <code>           muxtools/misc/chapters.py         </code> <pre><code>class Chapters:\n    chapters: list[Chapter]\n    fps: Fraction | PathLike\n    timestamps: ABCTimestamps\n\n    def __init__(\n        self,\n        chapter_source: PathLike | GlobSearch | Chapter | list[Chapter],\n        timesource: TimeSourceT = Fraction(24000, 1001),\n        timescale: TimeScaleT = TimeScale.MKV,\n        _print: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Convenience class for chapters\n\n        :param chapter_source:      Input either txt with ogm chapters, xml or (a list of) self defined chapters.\n        :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                    For details check the docstring on the type.\n        :param _print:              Prints chapters after parsing and after trimming.\n        \"\"\"\n        self.timestamps = resolve_timesource_and_scale(timesource, timescale, caller=self)\n        if isinstance(chapter_source, tuple):\n            self.chapters = [chapter_source]\n        elif isinstance(chapter_source, list):\n            self.chapters = chapter_source\n        else:\n            # Handle both OGM .txt files and xml files\n            if isinstance(chapter_source, GlobSearch):\n                chapter_source = chapter_source.paths[0]\n            chapter_source = chapter_source if isinstance(chapter_source, Path) else Path(chapter_source)\n\n            self.chapters = parse_xml(chapter_source) if chapter_source.suffix.lower() == \".xml\" else parse_ogm(chapter_source)\n            if _print:\n                self.print()\n\n        # Convert all framenumbers to timedeltas\n        chapters = []\n        for ch in self.chapters:\n            if isinstance(ch[0], int):\n                current = list(ch)\n                ms = self.timestamps.frame_to_time(current[0], TimeType.START, 3)\n                current[0] = timedelta(milliseconds=ms)\n                chapters.append(tuple(current))\n            else:\n                chapters.append(ch)\n        self.chapters = chapters\n\n    def trim(self: ChaptersSelf, trim_start: int = 0, trim_end: int = 0, num_frames: int = 0) -&gt; ChaptersSelf:\n        \"\"\"\n        Trims the chapters\n        \"\"\"\n        if trim_start &gt; 0:\n            chapters: list[Chapter] = []\n            for chapter in self.chapters:\n                if self.timestamps.time_to_frame(int(chapter[0].total_seconds() * 1000), TimeType.START, 3) == 0:\n                    chapters.append(chapter)\n                    continue\n                if self.timestamps.time_to_frame(int(chapter[0].total_seconds() * 1000), TimeType.START, 3) - trim_start &lt; 0:\n                    continue\n                current = list(chapter)\n                trim_start_ms = self.timestamps.frame_to_time(trim_start, TimeType.START, 3)\n                current[0] = current[0] - timedelta(milliseconds=trim_start_ms)\n                if num_frames:\n                    last_frame_ms = self.timestamps.frame_to_time(num_frames - 1, TimeType.START, 3)\n                    if current[0] &gt; timedelta(milliseconds=last_frame_ms):\n                        continue\n                chapters.append(tuple(current))\n\n            self.chapters = chapters\n        if trim_end is not None and trim_end != 0:\n            if trim_end &gt; 0:\n                chapters: list[Chapter] = []\n                for chapter in self.chapters:\n                    if self.timestamps.time_to_frame(int(chapter[0].total_seconds() * 1000), TimeType.START, 3) &lt; trim_end:\n                        chapters.append(chapter)\n                self.chapters = chapters\n\n        return self\n\n    def set_names(self: ChaptersSelf, names: list[str | None]) -&gt; ChaptersSelf:\n        \"\"\"\n        Renames the chapters\n\n        :param names:   List of names\n        \"\"\"\n        old: list[str] = [chapter[1] for chapter in self.chapters]\n        if len(names) &gt; len(old):\n            self.print()\n            raise error(\"Chapters: too many names!\", self)\n        if len(names) &lt; len(old):\n            names += [None] * (len(old) - len(names))\n\n        chapters: list[Chapter] = []\n        for i, name in enumerate(names):\n            current = list(self.chapters[i])\n            current[1] = name\n            chapters.append(tuple(current))\n\n        self.chapters = chapters\n        return self\n\n    def add(self: ChaptersSelf, chapters: Chapter | list[Chapter], index: int = 0) -&gt; ChaptersSelf:\n        \"\"\"\n        Adds a chapter at the specified index\n        \"\"\"\n        if isinstance(chapters, tuple):\n            chapters = [chapters]\n        else:\n            chapters = chapters\n\n        converted = []\n        for ch in chapters:\n            if isinstance(ch[0], int):\n                current = list(ch)\n                ms = self.timestamps.frame_to_time(current[0], TimeType.START, 3)\n                current[0] = timedelta(milliseconds=ms)\n                converted.append(tuple(current))\n            else:\n                converted.append(ch)\n\n        for ch in converted:\n            self.chapters.insert(index, ch)\n            index += 1\n        return self\n\n    def shift_chapter(self: ChaptersSelf, chapter: int = 0, shift_amount: int = 0) -&gt; ChaptersSelf:\n        \"\"\"\n        Used to shift a single chapter by x frames\n\n        :param chapter:         Chapter number (starting at 0)\n        :param shift_amount:    Frames to shift by\n        \"\"\"\n        ch = list(self.chapters[chapter])\n        ch_frame = self.timestamps.time_to_frame(int(ch[0].total_seconds() * 1000), TimeType.START, 3) + shift_amount\n        if ch_frame &gt; 0:\n            ms = self.timestamps.frame_to_time(ch_frame, TimeType.START, 3)\n            ch[0] = timedelta(milliseconds=ms)\n        else:\n            ch[0] = timedelta(seconds=0)\n        self.chapters[chapter] = tuple(ch)\n        return self\n\n    def shift(self: ChaptersSelf, shift_amount: int) -&gt; ChaptersSelf:\n        \"\"\"\n        Shifts all chapters by x frames.\n\n        :param shift_amount:    Frames to shift by\n        \"\"\"\n        return [self.shift_chapter(i, shift_amount) for i, _ in enumerate(self.chapters)][-1]\n\n    def print(self: ChaptersSelf) -&gt; ChaptersSelf:\n        \"\"\"\n        Prettier print for these because default timedelta formatting sucks\n        \"\"\"\n        info(\"Chapters:\")\n        for time, name in self.chapters:\n            frame = self.timestamps.time_to_frame(int(time.total_seconds() * 1000), TimeType.START, 3)\n            print(f\"{name}: {format_timedelta(time)} | {frame}\")\n        print(\"\", end=\"\\n\")\n        return self\n\n    def to_file(self: ChaptersSelf, out: PathLike | None = None, minus_one_ms_hack: bool = True) -&gt; str:\n        \"\"\"\n        Outputs the chapters to an OGM file\n\n        :param out:                 Can be either a directory or a full file path\n        :param minus_one_ms_hack:   If True, every chapter will be shifted by -1ms to avoid issues with some players\n        \"\"\"\n        if not out:\n            out = get_workdir()\n        out = ensure_path(out, self)\n        if out.is_dir():\n            out_file = os.path.join(out, \"chapters.txt\")\n        else:\n            out_file = out\n        with open(out_file, \"w\", encoding=\"UTF-8\") as f:\n            chapters = [\n                \"CHAPTER{num:02d}={time}\\nCHAPTER{num:02d}NAME={name}\\n\".format(\n                    num=i + 1,\n                    time=format_timedelta(\n                        (chapter[0] - timedelta(milliseconds=1)) if minus_one_ms_hack and chapter[0] &gt; timedelta(milliseconds=0) else chapter[0]\n                    ),\n                    name=chapter[1],\n                )\n                for i, chapter in enumerate(sorted(self.chapters, key=lambda x: x[0]))\n            ]\n            f.writelines(chapters)\n        return out_file\n\n    @staticmethod\n    def from_sub(\n        file: PathLike | SubFile,\n        timesource: TimeSourceT = None,\n        timescale: TimeScaleT = None,\n        use_actor_field: bool = False,\n        markers: str | list[str] = [\"chapter\", \"chptr\"],\n        _print: bool = True,\n        encoding: str = \"utf_8_sig\",\n    ) -&gt; \"Chapters\":\n        \"\"\"\n        Extract chapters from an ass file or a SubFile.\n\n        :param file:            Input ass file or SubFile\n        :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n        :param use_actor_field: Uses the actor field instead of the effect field for identification.\n        :param markers:         Markers to check for.\n        :param _print:          Prints the chapters after parsing\n        :param encoding:        Encoding used to read the ass file if need be\n        \"\"\"\n        from ass import parse_file, Comment\n\n        caller = \"Chapters.from_sub\"\n\n        if isinstance(markers, str):\n            markers = [markers]\n\n        if isinstance(file, SubFile):\n            doc = file._read_doc()\n        else:\n            file = ensure_path_exists(file, caller)\n            with open(file if not file else file, \"r\", encoding=encoding) as reader:\n                doc = parse_file(reader)\n\n        pattern = re.compile(r\"\\{([^\\\\=].+?)\\}\")\n        chapters = list[Chapter]()\n        for line in doc.events:\n            field_value = str(line.name).lower() if use_actor_field else str(line.effect).lower()\n            found = [m in field_value for m in markers]\n            if any(found):\n                match = pattern.search(line.text)\n                if match:\n                    chapters.append((line.start, match.group(1)))\n                elif isinstance(line, Comment) and line.text:\n                    chapters.append((line.start, str(line.text).strip()))\n                else:\n                    warn(f\"Chapter {(len(chapters) + 1):02.0f} does not have a name!\", caller)\n                    chapters.append((line.start, \"\"))\n\n        if not chapters:\n            warn(\"Could not find any chapters in subtitle!\", caller)\n\n        if timesource is None and (setup_timesource := get_setup_attr(\"sub_timesource\", None)) is not None:\n            if not isinstance(setup_timesource, TimeSourceT):\n                raise error(\"Invalid timesource type in Setup!\", caller)\n            debug(\"Using default timesource from setup.\", caller)\n            timesource = setup_timesource\n\n        if timescale is None and (setup_timescale := get_setup_attr(\"sub_timescale\", None)) is not None:\n            if not isinstance(setup_timescale, TimeScaleT):\n                raise error(\"Invalid timescale type in Setup!\", caller)\n            debug(\"Using default timescale from setup.\", caller)\n            timescale = setup_timescale\n\n        ch = Chapters(chapters, timesource, timescale)\n        if _print and chapters:\n            ch.print()\n        return ch\n\n    @staticmethod\n    def from_mkv(file: PathLike, timesource: TimeSourceT = None, timescale: TimeScaleT = None, _print: bool = True, quiet: bool = True) -&gt; \"Chapters\":\n        \"\"\"\n        Extract chapters from mkv.\n\n        :param file:            Input mkv file\n        :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n        :param _print:          Prints the chapters after parsing\n        \"\"\"\n        caller = \"Chapters.from_mkv\"\n        file = ensure_path_exists(file, caller)\n\n        mkvextract = get_executable(\"mkvextract\")\n        out = Path(get_temp_workdir(), f\"{file.stem}_chapters.txt\")\n        args = [mkvextract, str(file), \"chapters\", \"-s\", str(out)]\n        if run_commandline(args, quiet):\n            raise error(\"Failed to extract chapters!\", caller)\n\n        if timesource is None:\n            chapters = Chapters(out, file, _print=_print)\n        else:\n            chapters = Chapters(out, timesource, timescale, _print)\n\n        clean_temp_files()\n        return chapters\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.__init__","title":"<code>__init__(chapter_source, timesource=Fraction(24000, 1001), timescale=TimeScale.MKV, _print=True)</code>","text":"<p>Convenience class for chapters</p> <p>Parameters:</p> Name Type Description Default <code>chapter_source</code> <code>PathLike | GlobSearch | Chapter | list[Chapter]</code> <p>Input either txt with ogm chapters, xml or (a list of) self defined chapters.</p> required <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>Fraction(24000, 1001)</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>_print</code> <code>bool</code> <p>Prints chapters after parsing and after trimming.</p> <code>True</code> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def __init__(\n    self,\n    chapter_source: PathLike | GlobSearch | Chapter | list[Chapter],\n    timesource: TimeSourceT = Fraction(24000, 1001),\n    timescale: TimeScaleT = TimeScale.MKV,\n    _print: bool = True,\n) -&gt; None:\n    \"\"\"\n    Convenience class for chapters\n\n    :param chapter_source:      Input either txt with ogm chapters, xml or (a list of) self defined chapters.\n    :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n    :param _print:              Prints chapters after parsing and after trimming.\n    \"\"\"\n    self.timestamps = resolve_timesource_and_scale(timesource, timescale, caller=self)\n    if isinstance(chapter_source, tuple):\n        self.chapters = [chapter_source]\n    elif isinstance(chapter_source, list):\n        self.chapters = chapter_source\n    else:\n        # Handle both OGM .txt files and xml files\n        if isinstance(chapter_source, GlobSearch):\n            chapter_source = chapter_source.paths[0]\n        chapter_source = chapter_source if isinstance(chapter_source, Path) else Path(chapter_source)\n\n        self.chapters = parse_xml(chapter_source) if chapter_source.suffix.lower() == \".xml\" else parse_ogm(chapter_source)\n        if _print:\n            self.print()\n\n    # Convert all framenumbers to timedeltas\n    chapters = []\n    for ch in self.chapters:\n        if isinstance(ch[0], int):\n            current = list(ch)\n            ms = self.timestamps.frame_to_time(current[0], TimeType.START, 3)\n            current[0] = timedelta(milliseconds=ms)\n            chapters.append(tuple(current))\n        else:\n            chapters.append(ch)\n    self.chapters = chapters\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.add","title":"<code>add(chapters, index=0)</code>","text":"<p>Adds a chapter at the specified index</p> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def add(self: ChaptersSelf, chapters: Chapter | list[Chapter], index: int = 0) -&gt; ChaptersSelf:\n    \"\"\"\n    Adds a chapter at the specified index\n    \"\"\"\n    if isinstance(chapters, tuple):\n        chapters = [chapters]\n    else:\n        chapters = chapters\n\n    converted = []\n    for ch in chapters:\n        if isinstance(ch[0], int):\n            current = list(ch)\n            ms = self.timestamps.frame_to_time(current[0], TimeType.START, 3)\n            current[0] = timedelta(milliseconds=ms)\n            converted.append(tuple(current))\n        else:\n            converted.append(ch)\n\n    for ch in converted:\n        self.chapters.insert(index, ch)\n        index += 1\n    return self\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.from_mkv","title":"<code>from_mkv(file, timesource=None, timescale=None, _print=True, quiet=True)</code>  <code>staticmethod</code>","text":"<p>Extract chapters from mkv.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Input mkv file</p> required <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> <code>_print</code> <code>bool</code> <p>Prints the chapters after parsing</p> <code>True</code> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>@staticmethod\ndef from_mkv(file: PathLike, timesource: TimeSourceT = None, timescale: TimeScaleT = None, _print: bool = True, quiet: bool = True) -&gt; \"Chapters\":\n    \"\"\"\n    Extract chapters from mkv.\n\n    :param file:            Input mkv file\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    :param _print:          Prints the chapters after parsing\n    \"\"\"\n    caller = \"Chapters.from_mkv\"\n    file = ensure_path_exists(file, caller)\n\n    mkvextract = get_executable(\"mkvextract\")\n    out = Path(get_temp_workdir(), f\"{file.stem}_chapters.txt\")\n    args = [mkvextract, str(file), \"chapters\", \"-s\", str(out)]\n    if run_commandline(args, quiet):\n        raise error(\"Failed to extract chapters!\", caller)\n\n    if timesource is None:\n        chapters = Chapters(out, file, _print=_print)\n    else:\n        chapters = Chapters(out, timesource, timescale, _print)\n\n    clean_temp_files()\n    return chapters\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.from_sub","title":"<code>from_sub(file, timesource=None, timescale=None, use_actor_field=False, markers=['chapter', 'chptr'], _print=True, encoding='utf_8_sig')</code>  <code>staticmethod</code>","text":"<p>Extract chapters from an ass file or a SubFile.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | SubFile</code> <p>Input ass file or SubFile</p> required <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> <code>use_actor_field</code> <code>bool</code> <p>Uses the actor field instead of the effect field for identification.</p> <code>False</code> <code>markers</code> <code>str | list[str]</code> <p>Markers to check for.</p> <code>['chapter', 'chptr']</code> <code>_print</code> <code>bool</code> <p>Prints the chapters after parsing</p> <code>True</code> <code>encoding</code> <code>str</code> <p>Encoding used to read the ass file if need be</p> <code>'utf_8_sig'</code> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>@staticmethod\ndef from_sub(\n    file: PathLike | SubFile,\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = None,\n    use_actor_field: bool = False,\n    markers: str | list[str] = [\"chapter\", \"chptr\"],\n    _print: bool = True,\n    encoding: str = \"utf_8_sig\",\n) -&gt; \"Chapters\":\n    \"\"\"\n    Extract chapters from an ass file or a SubFile.\n\n    :param file:            Input ass file or SubFile\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    :param use_actor_field: Uses the actor field instead of the effect field for identification.\n    :param markers:         Markers to check for.\n    :param _print:          Prints the chapters after parsing\n    :param encoding:        Encoding used to read the ass file if need be\n    \"\"\"\n    from ass import parse_file, Comment\n\n    caller = \"Chapters.from_sub\"\n\n    if isinstance(markers, str):\n        markers = [markers]\n\n    if isinstance(file, SubFile):\n        doc = file._read_doc()\n    else:\n        file = ensure_path_exists(file, caller)\n        with open(file if not file else file, \"r\", encoding=encoding) as reader:\n            doc = parse_file(reader)\n\n    pattern = re.compile(r\"\\{([^\\\\=].+?)\\}\")\n    chapters = list[Chapter]()\n    for line in doc.events:\n        field_value = str(line.name).lower() if use_actor_field else str(line.effect).lower()\n        found = [m in field_value for m in markers]\n        if any(found):\n            match = pattern.search(line.text)\n            if match:\n                chapters.append((line.start, match.group(1)))\n            elif isinstance(line, Comment) and line.text:\n                chapters.append((line.start, str(line.text).strip()))\n            else:\n                warn(f\"Chapter {(len(chapters) + 1):02.0f} does not have a name!\", caller)\n                chapters.append((line.start, \"\"))\n\n    if not chapters:\n        warn(\"Could not find any chapters in subtitle!\", caller)\n\n    if timesource is None and (setup_timesource := get_setup_attr(\"sub_timesource\", None)) is not None:\n        if not isinstance(setup_timesource, TimeSourceT):\n            raise error(\"Invalid timesource type in Setup!\", caller)\n        debug(\"Using default timesource from setup.\", caller)\n        timesource = setup_timesource\n\n    if timescale is None and (setup_timescale := get_setup_attr(\"sub_timescale\", None)) is not None:\n        if not isinstance(setup_timescale, TimeScaleT):\n            raise error(\"Invalid timescale type in Setup!\", caller)\n        debug(\"Using default timescale from setup.\", caller)\n        timescale = setup_timescale\n\n    ch = Chapters(chapters, timesource, timescale)\n    if _print and chapters:\n        ch.print()\n    return ch\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.print","title":"<code>print()</code>","text":"<p>Prettier print for these because default timedelta formatting sucks</p> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def print(self: ChaptersSelf) -&gt; ChaptersSelf:\n    \"\"\"\n    Prettier print for these because default timedelta formatting sucks\n    \"\"\"\n    info(\"Chapters:\")\n    for time, name in self.chapters:\n        frame = self.timestamps.time_to_frame(int(time.total_seconds() * 1000), TimeType.START, 3)\n        print(f\"{name}: {format_timedelta(time)} | {frame}\")\n    print(\"\", end=\"\\n\")\n    return self\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.set_names","title":"<code>set_names(names)</code>","text":"<p>Renames the chapters</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>list[str | None]</code> <p>List of names</p> required Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def set_names(self: ChaptersSelf, names: list[str | None]) -&gt; ChaptersSelf:\n    \"\"\"\n    Renames the chapters\n\n    :param names:   List of names\n    \"\"\"\n    old: list[str] = [chapter[1] for chapter in self.chapters]\n    if len(names) &gt; len(old):\n        self.print()\n        raise error(\"Chapters: too many names!\", self)\n    if len(names) &lt; len(old):\n        names += [None] * (len(old) - len(names))\n\n    chapters: list[Chapter] = []\n    for i, name in enumerate(names):\n        current = list(self.chapters[i])\n        current[1] = name\n        chapters.append(tuple(current))\n\n    self.chapters = chapters\n    return self\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.shift","title":"<code>shift(shift_amount)</code>","text":"<p>Shifts all chapters by x frames.</p> <p>Parameters:</p> Name Type Description Default <code>shift_amount</code> <code>int</code> <p>Frames to shift by</p> required Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def shift(self: ChaptersSelf, shift_amount: int) -&gt; ChaptersSelf:\n    \"\"\"\n    Shifts all chapters by x frames.\n\n    :param shift_amount:    Frames to shift by\n    \"\"\"\n    return [self.shift_chapter(i, shift_amount) for i, _ in enumerate(self.chapters)][-1]\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.shift_chapter","title":"<code>shift_chapter(chapter=0, shift_amount=0)</code>","text":"<p>Used to shift a single chapter by x frames</p> <p>Parameters:</p> Name Type Description Default <code>chapter</code> <code>int</code> <p>Chapter number (starting at 0)</p> <code>0</code> <code>shift_amount</code> <code>int</code> <p>Frames to shift by</p> <code>0</code> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def shift_chapter(self: ChaptersSelf, chapter: int = 0, shift_amount: int = 0) -&gt; ChaptersSelf:\n    \"\"\"\n    Used to shift a single chapter by x frames\n\n    :param chapter:         Chapter number (starting at 0)\n    :param shift_amount:    Frames to shift by\n    \"\"\"\n    ch = list(self.chapters[chapter])\n    ch_frame = self.timestamps.time_to_frame(int(ch[0].total_seconds() * 1000), TimeType.START, 3) + shift_amount\n    if ch_frame &gt; 0:\n        ms = self.timestamps.frame_to_time(ch_frame, TimeType.START, 3)\n        ch[0] = timedelta(milliseconds=ms)\n    else:\n        ch[0] = timedelta(seconds=0)\n    self.chapters[chapter] = tuple(ch)\n    return self\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.to_file","title":"<code>to_file(out=None, minus_one_ms_hack=True)</code>","text":"<p>Outputs the chapters to an OGM file</p> <p>Parameters:</p> Name Type Description Default <code>out</code> <code>PathLike | None</code> <p>Can be either a directory or a full file path</p> <code>None</code> <code>minus_one_ms_hack</code> <code>bool</code> <p>If True, every chapter will be shifted by -1ms to avoid issues with some players</p> <code>True</code> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def to_file(self: ChaptersSelf, out: PathLike | None = None, minus_one_ms_hack: bool = True) -&gt; str:\n    \"\"\"\n    Outputs the chapters to an OGM file\n\n    :param out:                 Can be either a directory or a full file path\n    :param minus_one_ms_hack:   If True, every chapter will be shifted by -1ms to avoid issues with some players\n    \"\"\"\n    if not out:\n        out = get_workdir()\n    out = ensure_path(out, self)\n    if out.is_dir():\n        out_file = os.path.join(out, \"chapters.txt\")\n    else:\n        out_file = out\n    with open(out_file, \"w\", encoding=\"UTF-8\") as f:\n        chapters = [\n            \"CHAPTER{num:02d}={time}\\nCHAPTER{num:02d}NAME={name}\\n\".format(\n                num=i + 1,\n                time=format_timedelta(\n                    (chapter[0] - timedelta(milliseconds=1)) if minus_one_ms_hack and chapter[0] &gt; timedelta(milliseconds=0) else chapter[0]\n                ),\n                name=chapter[1],\n            )\n            for i, chapter in enumerate(sorted(self.chapters, key=lambda x: x[0]))\n        ]\n        f.writelines(chapters)\n    return out_file\n</code></pre>"},{"location":"muxtools/chapters/#muxtools.misc.chapters.Chapters.trim","title":"<code>trim(trim_start=0, trim_end=0, num_frames=0)</code>","text":"<p>Trims the chapters</p> Source code in <code>         muxtools/misc/chapters.py       </code> <pre><code>def trim(self: ChaptersSelf, trim_start: int = 0, trim_end: int = 0, num_frames: int = 0) -&gt; ChaptersSelf:\n    \"\"\"\n    Trims the chapters\n    \"\"\"\n    if trim_start &gt; 0:\n        chapters: list[Chapter] = []\n        for chapter in self.chapters:\n            if self.timestamps.time_to_frame(int(chapter[0].total_seconds() * 1000), TimeType.START, 3) == 0:\n                chapters.append(chapter)\n                continue\n            if self.timestamps.time_to_frame(int(chapter[0].total_seconds() * 1000), TimeType.START, 3) - trim_start &lt; 0:\n                continue\n            current = list(chapter)\n            trim_start_ms = self.timestamps.frame_to_time(trim_start, TimeType.START, 3)\n            current[0] = current[0] - timedelta(milliseconds=trim_start_ms)\n            if num_frames:\n                last_frame_ms = self.timestamps.frame_to_time(num_frames - 1, TimeType.START, 3)\n                if current[0] &gt; timedelta(milliseconds=last_frame_ms):\n                    continue\n            chapters.append(tuple(current))\n\n        self.chapters = chapters\n    if trim_end is not None and trim_end != 0:\n        if trim_end &gt; 0:\n            chapters: list[Chapter] = []\n            for chapter in self.chapters:\n                if self.timestamps.time_to_frame(int(chapter[0].total_seconds() * 1000), TimeType.START, 3) &lt; trim_end:\n                    chapters.append(chapter)\n            self.chapters = chapters\n\n    return self\n</code></pre>"},{"location":"muxtools/main/","title":"main","text":""},{"location":"muxtools/main/#muxtools.main.Setup","title":"<code>Setup</code>  <code>dataclass</code>","text":"<p>Something like an environment used for a lot of functions in this package. Mostly used for muxing and data locations (work directory and what not).</p> <p>If you want to change any of the variables AFTER initialization make sure to use the <code>Setup.edit</code> function to do so. Read its docstring to get why.</p> <p>Parameters:</p> Name Type Description Default <code>episode</code> <code>str</code> <p>Episode identifier used for workdir and muxing</p> <code>'01'</code> <code>config_file</code> <code>str</code> <p>An ini file where the config will be loaded from. You can disable this by leaving it empty or setting None. Make sure you set the relevant variables in this constructor in that case. You can also set other, technically, not existing variables in there and access them from python after.</p> <code>'config.ini'</code> <code>bdmv_dir</code> <code>str</code> <p>Convenience path for sources and what not.</p> <code>'BDMV'</code> <code>show_name</code> <code>str</code> <p>The name of the show. Used for the $show$ placeholder in muxing.</p> <code>'Nice Series'</code> <code>allow_binary_download</code> <code>bool</code> <p>This will download any executables needed for doing what you're requesting to do. For example x265, opusenc, etc.</p> <code>True</code> <code>clean_work_dirs</code> <code>bool</code> <p>Cleanup the work directories after muxing. Might be useful if you're muxing a ton of stuff.</p> <code>False</code> <code>out_dir</code> <code>str</code> <p>The folder the muxed files will go into.</p> <code>'premux'</code> <code>out_name</code> <code>str</code> <p>The naming template applied to the muxed files.</p> <code>'$show$ - $ep$ (premux)'</code> <code>mkv_title_naming</code> <code>str</code> <p>The naming template applied to the mkv title.</p> <code>'$show$ - $ep$'</code> <code>work_dir</code> <code>str | None</code> <p>In case you want to set a custom work directory for all the temp files.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enable or Disable various, possibly interesting, debug output of all functions in this package.</p> <code>True</code> <code>error_on_danger</code> <code>bool</code> <p>Raise an error when normally a \"danger\" log would be printed.</p> <code>False</code> Source code in <code>           muxtools/main.py         </code> <pre><code>@dataclass\nclass Setup:\n    \"\"\"\n    Something like an environment used for a lot of functions in this package.\n    Mostly used for muxing and data locations (work directory and what not).\n\n    If you want to change any of the variables AFTER initialization make sure to use the `Setup.edit` function to do so.\n    Read its docstring to get why.\n\n    :param episode:                 Episode identifier used for workdir and muxing\n    :param config_file:             An ini file where the config will be loaded from.\n                                    You can disable this by leaving it empty or setting None.\n                                    Make sure you set the relevant variables in this constructor in that case.\n                                    You can also set other, technically, not existing variables in there and access them from python after.\n\n    :param bdmv_dir:                Convenience path for sources and what not.\n    :param show_name:               The name of the show. Used for the $show$ placeholder in muxing.\n    :param allow_binary_download:   This will download any executables needed for doing what you're requesting to do.\n                                    For example x265, opusenc, etc.\n    :param clean_work_dirs:         Cleanup the work directories after muxing. Might be useful if you're muxing a ton of stuff.\n    :param out_dir:                 The folder the muxed files will go into.\n    :param out_name:                The naming template applied to the muxed files.\n    :param mkv_title_naming:        The naming template applied to the mkv title.\n    :param work_dir:                In case you want to set a custom work directory for all the temp files.\n    :param debug:                   Enable or Disable various, possibly interesting, debug output of all functions in this package.\n    :param error_on_danger:         Raise an error when normally a \"danger\" log would be printed.\n    \"\"\"\n\n    episode: str = \"01\"\n    config_file: str = \"config.ini\"\n\n    bdmv_dir: str = \"BDMV\"\n    show_name: str = \"Nice Series\"\n    allow_binary_download: bool = True\n    clean_work_dirs: bool = False\n    out_dir: str = \"premux\"\n    out_name: str = \"$show$ - $ep$ (premux)\"\n    mkv_title_naming: str = r\"$show$ - $ep$\"\n    work_dir: str | None = None\n    debug: bool = True\n    error_on_danger: bool = False\n\n    def __post_init__(self):\n        if self.config_file:\n            config = ConfigParser()\n            config_name = self.config_file\n\n            if not os.path.exists(config_name):\n                config[\"SETUP\"] = {\n                    \"bdmv_dir\": self.bdmv_dir,\n                    \"show_name\": self.show_name,\n                    \"allow_binary_download\": self.allow_binary_download,\n                    \"clean_work_dirs\": self.clean_work_dirs,\n                    \"out_dir\": self.out_dir,\n                    \"out_name\": self.out_name,\n                    \"mkv_title_naming\": self.mkv_title_naming,\n                    \"debug\": self.debug,\n                    \"error_on_danger\": self.error_on_danger,\n                }\n\n                with open(config_name, \"w\", encoding=\"utf-8\") as config_file:\n                    config.write(config_file)\n\n                raise error(f\"Template config created at {Path(config_name).resolve()}.\\nPlease set it up!\")\n\n            config.read(config_name, encoding=\"utf-8\")\n            settings = config[\"SETUP\"]\n\n            valid_bools = [\"true\", \"1\", \"t\", \"y\", \"yes\"]\n            for key in settings:\n                if hasattr(self, key) and isinstance(getattr(self, key), bool):\n                    setattr(self, key, True if settings[key].lower() in valid_bools else False)\n                else:\n                    setattr(self, key, settings[key])\n\n        if not self.work_dir:\n            self.work_dir = Path(os.getcwd(), \"_workdir\", self.episode)\n\n        self.work_dir = Path(self.work_dir)\n        self.work_dir.mkdir(parents=True, exist_ok=True)\n        self.work_dir = str(self.work_dir)\n\n        from .utils.env import save_setup\n\n        save_setup(self)\n\n    def edit(self: SetupSelf, attr: str, value: Any) -&gt; SetupSelf:\n        \"\"\"\n        Sets a variable inside of Setup and saves it to the environment variables.\n        You should use this to apply any changes because other functions will not make use of them otherwise!\n\n        :param attr:        The name of the variable/attribute you want to change\n        :param value:       The value this variable/attribute will have.\n        \"\"\"\n        setattr(self, attr, value)\n\n        from .utils.env import save_setup\n\n        save_setup(self)\n        return self\n\n    def set_default_sub_timesource(\n        self: SetupSelf,\n        timesource: Path | GlobSearch | str | float | list[int],\n        timescale: TimeScale | int | None = None,\n    ) -&gt; SetupSelf:\n        \"\"\"\n        Set a default timesource and timescale for conversions in subtitle functions.\n\n        The source selection for this is a bit more limited than the explicit params in the respective functions due to certain types being hard to store in the environment.\n\n        :param timesource:          The source of timestamps/timecodes.\\n\n                                    This can be a video file, a timestamps txt file, actual timestamps as integers,\n                                    a muxtools VideoMeta json file or FPS as a fraction string or float.\n        :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                    For details check the docstring on the type.\n        \"\"\"\n        if isinstance(timesource, GlobSearch):\n            timesource = timesource.paths[0]\n\n        if isinstance(timesource, Path):\n            timesource = str(timesource.resolve())\n\n        if isinstance(timescale, TimeScale):\n            timescale = timescale.value\n\n        self.edit(\"sub_timesource\", timesource)\n        return self.edit(\"sub_timescale\", timescale)\n\n    def _toJson(self) -&gt; str:\n        return json.dumps(self.__dict__)\n</code></pre>"},{"location":"muxtools/main/#muxtools.main.Setup.edit","title":"<code>edit(attr, value)</code>","text":"<p>Sets a variable inside of Setup and saves it to the environment variables. You should use this to apply any changes because other functions will not make use of them otherwise!</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the variable/attribute you want to change</p> required <code>value</code> <code>Any</code> <p>The value this variable/attribute will have.</p> required Source code in <code>         muxtools/main.py       </code> <pre><code>def edit(self: SetupSelf, attr: str, value: Any) -&gt; SetupSelf:\n    \"\"\"\n    Sets a variable inside of Setup and saves it to the environment variables.\n    You should use this to apply any changes because other functions will not make use of them otherwise!\n\n    :param attr:        The name of the variable/attribute you want to change\n    :param value:       The value this variable/attribute will have.\n    \"\"\"\n    setattr(self, attr, value)\n\n    from .utils.env import save_setup\n\n    save_setup(self)\n    return self\n</code></pre>"},{"location":"muxtools/main/#muxtools.main.Setup.set_default_sub_timesource","title":"<code>set_default_sub_timesource(timesource, timescale=None)</code>","text":"<p>Set a default timesource and timescale for conversions in subtitle functions.</p> <p>The source selection for this is a bit more limited than the explicit params in the respective functions due to certain types being hard to store in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>timesource</code> <code>Path | GlobSearch | str | float | list[int]</code> <p>The source of timestamps/timecodes.  This can be a video file, a timestamps txt file, actual timestamps as integers, a muxtools VideoMeta json file or FPS as a fraction string or float.</p> required <code>timescale</code> <code>TimeScale | int | None</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> Source code in <code>         muxtools/main.py       </code> <pre><code>def set_default_sub_timesource(\n    self: SetupSelf,\n    timesource: Path | GlobSearch | str | float | list[int],\n    timescale: TimeScale | int | None = None,\n) -&gt; SetupSelf:\n    \"\"\"\n    Set a default timesource and timescale for conversions in subtitle functions.\n\n    The source selection for this is a bit more limited than the explicit params in the respective functions due to certain types being hard to store in the environment.\n\n    :param timesource:          The source of timestamps/timecodes.\\n\n                                This can be a video file, a timestamps txt file, actual timestamps as integers,\n                                a muxtools VideoMeta json file or FPS as a fraction string or float.\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n    \"\"\"\n    if isinstance(timesource, GlobSearch):\n        timesource = timesource.paths[0]\n\n    if isinstance(timesource, Path):\n        timesource = str(timesource.resolve())\n\n    if isinstance(timescale, TimeScale):\n        timescale = timescale.value\n\n    self.edit(\"sub_timesource\", timesource)\n    return self.edit(\"sub_timescale\", timescale)\n</code></pre>"},{"location":"muxtools/main/#muxtools.functions.do_audio","title":"<code>do_audio(fileIn, track=0, trims=None, timesource=Fraction(24000, 1001), timescale=TimeScale.MKV, num_frames=0, extractor=FFMpeg.Extractor(), trimmer=AutoTrimmer(), encoder=AutoEncoder(), quiet=True, output=None)</code>","text":"<p>One-liner to handle the whole audio processing</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike | list[PathLike]</code> <p>Input file</p> required <code>track</code> <code>int</code> <p>Audio track number</p> <code>0</code> <code>trims</code> <code>Trim | list[Trim] | None</code> <p>Frame ranges to trim and/or combine, e.g. (24, -24) or [(24, 500), (700, 900)]</p> <code>None</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>Fraction(24000, 1001)</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>num_frames</code> <code>int</code> <p>Total number of frames, used for negative numbers in trims</p> <code>0</code> <code>extractor</code> <code>Extractor | None</code> <p>Tool used to extract the audio</p> <code>Extractor()</code> <code>trimmer</code> <code>Trimmer | None</code> <p>Tool used to trim the audio AutoTrimmer means it will choose ffmpeg for lossy and Sox for lossless</p> <code>AutoTrimmer()</code> <code>encoder</code> <code>Encoder | None</code> <p>Tool used to encode the audio AutoEncoder means it won't reencode lossy and choose opus otherwise.</p> <code>AutoEncoder()</code> <code>quiet</code> <code>bool</code> <p>Whether the tool output should be visible</p> <code>True</code> <code>output</code> <code>PathLike | None</code> <p>Custom output file or directory, extensions will be automatically added</p> <code>None</code> <p>Returns:</p> Type Description <code>AudioFile</code> <p>AudioFile Object containing file path, delays and source</p> Source code in <code>         muxtools/functions.py       </code> <pre><code>def do_audio(\n    fileIn: PathLike | list[PathLike],\n    track: int = 0,\n    trims: Trim | list[Trim] | None = None,\n    timesource: TimeSourceT = Fraction(24000, 1001),\n    timescale: TimeScaleT = TimeScale.MKV,\n    num_frames: int = 0,\n    extractor: Extractor | None = FFMpeg.Extractor(),\n    trimmer: Trimmer | None = AutoTrimmer(),\n    encoder: Encoder | None = AutoEncoder(),\n    quiet: bool = True,\n    output: PathLike | None = None,\n) -&gt; AudioFile:\n    \"\"\"\n    One-liner to handle the whole audio processing\n\n    :param fileIn:          Input file\n    :param track:           Audio track number\n    :param trims:           Frame ranges to trim and/or combine, e.g. (24, -24) or [(24, 500), (700, 900)]\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    :param num_frames:      Total number of frames, used for negative numbers in trims\n    :param extractor:       Tool used to extract the audio\n    :param trimmer:         Tool used to trim the audio\n                            AutoTrimmer means it will choose ffmpeg for lossy and Sox for lossless\n\n    :param encoder:         Tool used to encode the audio\n                            AutoEncoder means it won't reencode lossy and choose opus otherwise.\n\n    :param quiet:           Whether the tool output should be visible\n    :param output:          Custom output file or directory, extensions will be automatically added\n    :return:                AudioFile Object containing file path, delays and source\n    \"\"\"\n    if isinstance(fileIn, list) and (not extractor or not isinstance(extractor, FFMpeg.Extractor)):\n        raise error(\"When passing a list of files you have to use the FFMpeg extractor!\", do_audio)\n\n    if extractor:\n        setattr(extractor, \"track\", track)\n        if not trimmer and not encoder:\n            setattr(extractor, \"output\", output)\n        if isinstance(fileIn, list):\n            info(f\"Extracting audio from {len(fileIn)} files to concatenate...\", do_audio)\n            extractor._no_print = True\n            fileIn = [ensure_path_exists(f, do_audio) for f in fileIn]\n            extracted = []\n            for f in fileIn:\n                try:\n                    af = extractor.extract_audio(f, quiet, True, True)\n                except:\n                    setattr(extractor, \"track\", 0)\n                    af = extractor.extract_audio(f, quiet, True, True)\n                    setattr(extractor, \"track\", track)\n                    duration = af.duration or timedelta(milliseconds=0)\n                    if duration &gt; timedelta(seconds=2):\n                        danger(f\"Could not find valid track {track} in '{f.name}' and falling back resulted in suspiciously long file.\", do_audio, 1)\n                        continue\n\n                    duration = format_timedelta(duration)\n                    warn(f\"Fell back to track 0 for '{f.name}' with a duration of {duration}\", do_audio, 1)\n\n                extracted.append(af)\n            audio = FFMpeg.Concat(extracted).concat_audio()\n        else:\n            audio = extractor.extract_audio(fileIn, quiet)\n    else:\n        audio = ensure_path_exists(fileIn, do_audio)\n\n    if not isinstance(audio, AudioFile):\n        audio = AudioFile.from_file(audio, do_audio)\n\n    trackinfo = audio.get_trackinfo()\n    track_format = trackinfo.get_audio_format()\n    if not track_format:\n        raise error(f\"Unknown track format! ({trackinfo.codec_name})\", do_audio)\n    if isinstance(trimmer, AutoTrimmer) and trims:\n        if track_format.should_not_transcode():\n            trimmer = FFMpeg.Trimmer()\n        else:\n            trimmer = Sox()\n\n    if isinstance(encoder, AutoEncoder):\n        if track_format.is_lossy:\n            encoder = None\n        elif track_format.should_not_transcode():\n            encoder = None\n            warn(\"Audio will not be reencoded due to having Atmos or special DTS features.\", do_audio, 2)\n        else:\n            encoder = Opus()\n\n    if trimmer and trims:\n        setattr(trimmer, \"trim\", trims)\n        setattr(trimmer, \"timesource\", timesource)\n        setattr(trimmer, \"timescale\", timescale)\n        setattr(trimmer, \"num_frames\", num_frames)\n        if not encoder:\n            setattr(trimmer, \"output\", output)\n        trimmed = trimmer.trim_audio(audio, quiet)\n        ensure_path(audio.file, do_audio).unlink(missing_ok=True)\n        audio = trimmed\n\n    if encoder:\n        setattr(encoder, \"output\", output)\n        encoded = encoder.encode_audio(audio, quiet)\n        ensure_path(audio.file, do_audio).unlink(missing_ok=True)\n        audio = encoded\n\n    print(\"\")\n    return audio\n</code></pre>"},{"location":"muxtools/audio/audioutils/","title":"audioutils","text":""},{"location":"muxtools/audio/audioutils/#muxtools.audio.audioutils.ensure_valid_in","title":"<code>ensure_valid_in(fileIn, supports_pipe=True, preprocess=None, valid_type=ValidInputType.FLAC, caller=None)</code>","text":"<p>Ensures valid input for any encoder that accepts flac (all of them). Passes existing file if no need to dither and is either wav or flac.</p> Source code in <code>         muxtools/audio/audioutils.py       </code> <pre><code>def ensure_valid_in(\n    fileIn: AudioFile,\n    supports_pipe: bool = True,\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = None,\n    valid_type: ValidInputType = ValidInputType.FLAC,\n    caller: Any = None,\n) -&gt; AudioFile | subprocess.Popen:\n    \"\"\"\n    Ensures valid input for any encoder that accepts flac (all of them).\n    Passes existing file if no need to dither and is either wav or flac.\n    \"\"\"\n    if fileIn.has_multiple_tracks(caller):\n        msg = f\"'{fileIn.file.name}' is a container with multiple tracks.\\n\"\n        msg += f\"The first audio track will be {'piped' if supports_pipe else 'extracted'} using default ffmpeg.\"\n        warn(msg, caller, 5)\n    trackinfo = fileIn.get_trackinfo()\n    container = fileIn.get_containerinfo()\n    preprocess = sanitize_pre(preprocess)\n\n    form = trackinfo.get_audio_format()\n    if form:\n        if form.is_lossy:\n            danger(f\"It's strongly recommended to not reencode lossy audio! ({trackinfo.codec_name})\", caller, 5)\n        elif form.should_not_transcode():\n            warn(\"Encoding tracks with special DTS Features or Atmos is very much discouraged.\", caller, 5)\n\n    wont_process = not any([p.can_run(trackinfo, preprocess) for p in preprocess])\n\n    if (form == AudioFormat.PCM and container.format_name.lower() == \"wav\") and wont_process:\n        return fileIn\n    if valid_type.allows_flac():\n        valid_type = valid_type.remove_flac()\n        if (form == AudioFormat.FLAC and container.format_name.lower() == \"flac\") and wont_process:\n            return fileIn\n\n    if valid_type == ValidInputType.FLAC:\n        from .encoders import FF_FLAC\n\n        if supports_pipe:\n            return FF_FLAC(preprocess=preprocess).get_pipe(fileIn)\n        else:\n            return FF_FLAC(compression_level=0, preprocess=preprocess, output=os.path.join(get_temp_workdir(), \"tempflac\")).encode_audio(\n                fileIn, temp=True\n            )\n    else:\n        return get_pcm(fileIn, trackinfo, supports_pipe, preprocess, valid_type, caller)\n</code></pre>"},{"location":"muxtools/audio/audioutils/#muxtools.audio.audioutils.has_libFDK","title":"<code>has_libFDK()</code>","text":"<p>Returns if whatever installation of ffmpeg being used has been compiled with libFDK</p> Source code in <code>         muxtools/audio/audioutils.py       </code> <pre><code>def has_libFDK() -&gt; bool:\n    \"\"\"\n    Returns if whatever installation of ffmpeg being used has been compiled with libFDK\n    \"\"\"\n    exe = get_executable(\"ffmpeg\")\n    _, readout = communicate_stdout([exe, \"-encoders\"])\n    for line in readout.splitlines():\n        if \"libfdk_aac\" in line.lower():\n            return True\n    return False\n</code></pre>"},{"location":"muxtools/audio/audioutils/#muxtools.audio.audioutils.qaac_compatcheck","title":"<code>qaac_compatcheck()</code>","text":"<p>Checks if the qAAC installation has libflac and returns the qaac version.</p> Source code in <code>         muxtools/audio/audioutils.py       </code> <pre><code>def qaac_compatcheck() -&gt; str:\n    \"\"\"\n    Checks if the qAAC installation has libflac and returns the qaac version.\n    \"\"\"\n    exe = get_executable(\"qaac\")\n    _, readout = communicate_stdout([exe, \"--check\"])\n    if \"libflac\" not in readout.lower():\n        raise error(\n            \"Your installation of qaac does not have libFLAC.\\nIt is needed for proper piping from ffmpeg etc.\"\n            + \"\\nYou can download it from https://github.com/xiph/flac/releases or run muxtools deps\"\n            + \"\\nFor installation check https://github.com/nu774/qaac/wiki/Installation\",\n            \"QAAC\",\n        )\n\n    if match := re.search(r\"qaac (\\d+\\.\\d+(?:\\.\\d+)?)\", readout, re.I):\n        return match.group(1)\n\n    return \"Unknown version\"\n</code></pre>"},{"location":"muxtools/audio/encoders/","title":"encoders","text":""},{"location":"muxtools/audio/encoders/#muxtools.audio.encoders.FDK_AAC","title":"<code>FDK_AAC</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Uses the libFDK implementation in ffmpeg to encode audio to AAC. It's strongly recommended to use qAAC if you're on windows because its straight up the best AAC encoder.</p> <p>Parameters:</p> Name Type Description Default <code>bitrate_mode</code> <p>Any int value from 0 - 5 0 will be CBR and using the bitrate below, 1 - 5 are true VBR modes See https://wiki.hydrogenaud.io/index.php?title=Fraunhofer_FDK_AAC#Bitrate_Modes</p> required <code>bitrate</code> <p>Any int value representing kbps</p> required <code>cutoff</code> <p>Hard frequency cutoff. 20 kHz is a good default and setting it to 0 will let it choose automatically.</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>use_binary</code> <p>Whether to use the fdkaac encoder binary or ffmpeg. If you don't have ffmpeg compiled with libfdk it will try to fall back to the binary.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/encoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass FDK_AAC(Encoder):\n    \"\"\"\n    Uses the libFDK implementation in ffmpeg to encode audio to AAC.\n    It's strongly recommended to use qAAC if you're on windows because its straight up the best AAC encoder.\n\n    :param bitrate_mode:        Any int value from 0 - 5\n                                0 will be CBR and using the bitrate below, 1 - 5 are true VBR modes\n                                See https://wiki.hydrogenaud.io/index.php?title=Fraunhofer_FDK_AAC#Bitrate_Modes\n\n    :param bitrate:             Any int value representing kbps\n    :param cutoff:              Hard frequency cutoff. 20 kHz is a good default and setting it to 0 will let it choose automatically.\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param use_binary:          Whether to use the fdkaac encoder binary or ffmpeg.\n                                If you don't have ffmpeg compiled with libfdk it will try to fall back to the binary.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    bitrate_mode: int = 5\n    bitrate: int = 256\n    cutoff: int = 20000\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = None\n    use_binary: bool = False\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        output = make_output(fileIn.file, \"m4a\", \"fdkaac\", self.output)\n        if not has_libFDK():\n            exe = get_executable(\"fdkaac\", False, False)\n            if not exe:\n                raise error(\n                    \"Your installation of ffmpeg wasn't compiled with libFDK.\"\n                    + \"\\nYou can download builds with the non-free flag from https://github.com/AnimMouse/ffmpeg-autobuild/releases\"\n                    + \"\\nYou can also use the FDKAAC binary if you can find a built version.\",\n                    self,\n                )\n            self.use_binary = True\n        else:\n            exe = get_executable(\"ffmpeg\") if not self.use_binary else get_executable(\"fdkaac\")\n\n        if os.name == \"nt\":\n            warn(\"It is strongly recommended to use qAAC on windows. See docs.\", self, 1)\n        info(f\"Encoding '{fileIn.file.stem}' to AAC using libFDK...\", self)\n\n        tags = dict[str, str]()\n        if self.use_binary:\n            fdk_version = get_binary_version(exe, r\"fdkaac (\\d\\.\\d\\.\\d)\")\n            tags.update(ENCODER=f\"fdkaac {fdk_version}\")\n            source = ensure_valid_in(fileIn, preprocess=self.preprocess, caller=self, valid_type=ValidInputType.RF64, supports_pipe=False)\n            args = [exe, \"-m\", str(self.bitrate_mode), \"-w\", str(self.cutoff), \"-a\", \"1\"]\n            if self.bitrate_mode == 0:\n                args.extend([\"-b\", str(self.bitrate)])\n            args.extend(self.get_custom_args() + [\"-o\", str(output), str(source.file)])\n        else:\n            tags.update(ENCODER=\"ffmpeg -c:a libfdk_aac\")\n            args = [exe, \"-hide_banner\", \"-i\", str(fileIn.file), \"-map\", \"0:a:0\", \"-c:a\", \"libfdk_aac\", \"-cutoff\", str(self.cutoff)]\n            if self.bitrate_mode &gt; 0:\n                args.extend([\"-vbr\", str(self.bitrate_mode)])\n            else:\n                args.extend([\"-b:a\", f\"{self.bitrate}k\"])\n            args.extend(get_preprocess_args(fileIn, self.preprocess, fileIn.get_trackinfo(), self) + self.get_custom_args())\n            args.append(str(output))\n\n        if self.use_binary:\n            config = ProgressBarConfig(\"Encoding...\")\n        else:\n            config = ProgressBarConfig(\"Encoding...\", duration_from_file(fileIn, 0))\n        if not run_cmd_pb(args, quiet, config, shell=False):\n            tags.update(ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags)\n        else:\n            raise crit(\"Encoding to AAC using libFDK failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/encoders/#muxtools.audio.encoders.FF_FLAC","title":"<code>FF_FLAC</code>","text":"<p>               Bases: <code>LosslessEncoder</code></p> <p>Uses the ffmpeg/libav FLAC encoder to encode audio to flac.</p> <p>Parameters:</p> Name Type Description Default <code>compression_level</code> <p>Any int value from 0 to 12 (Higher = better but slower)</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/encoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass FF_FLAC(LosslessEncoder):\n    \"\"\"\n    Uses the ffmpeg/libav FLAC encoder to encode audio to flac.\n\n    :param compression_level:   Any int value from 0 to 12 (Higher = better but slower)\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    compression_level: int = 10\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    output: PathLike | None = None\n\n    def _base_command(self, fileIn: AudioFile, compression: int = 0) -&gt; list[str]:\n        # fmt: off\n        args = [get_executable(\"ffmpeg\"), \"-hide_banner\", \"-i\", str(fileIn.file.resolve()), \"-map\", \"0:a:0\", \"-c:a\", \"flac\", \"-compression_level\", str(compression)]\n        minfo = fileIn.get_trackinfo()\n        args.extend(get_preprocess_args(fileIn, self.preprocess, minfo, self) + self.get_custom_args())\n        return args\n        # fmt: on\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        output = make_output(fileIn.file, \"flac\", \"ffmpeg\", self.output)\n        if \"temp\" in kwargs.keys():\n            debug(\"Preparing audio for input to other encoder using ffmpeg...\", self)\n        else:\n            info(f\"Encoding '{fileIn.file.stem}' to FLAC using ffmpeg...\", self)\n        args = self._base_command(fileIn, self.compression_level)\n        args.append(str(output.resolve()))\n\n        if not run_cmd_pb(\n            args, quiet, ProgressBarConfig(\"Preparing...\" if \"temp\" in kwargs.keys() else \"Encoding...\", duration_from_file(fileIn, 0))\n        ):\n            tags = dict[str, str](ENCODER=\"ffmpeg -c:a flac\", ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to flac using ffmpeg failed!\", self)\n\n    def get_pipe(self, fileIn: AudioFile) -&gt; subprocess.Popen:\n        debug(\"Piping audio for input to other encoder using ffmpeg...\", self)\n        args = self._base_command(fileIn, 0)\n        args.extend([\"-f\", \"flac\", \"-\"])\n        p = subprocess.Popen(args, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=False)\n        return p\n</code></pre>"},{"location":"muxtools/audio/encoders/#muxtools.audio.encoders.FLAC","title":"<code>FLAC</code>","text":"<p>               Bases: <code>LosslessEncoder</code></p> <p>Uses the reference libFLAC encoder to encode audio to flac.</p> <p>Parameters:</p> Name Type Description Default <code>compression_level</code> <p>Any int value from 0 to 8 (Higher = better but slower)</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>verify</code> <p>Make the encoder verify each encoded sample while encoding to ensure valid output.</p> required <code>threads</code> <p>Number of threads to use for encoding. (Requires FLAC 1.5.0) <code>None</code> will choose whatever your CPU has with a max of 8.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/encoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass FLAC(LosslessEncoder):\n    \"\"\"\n    Uses the reference libFLAC encoder to encode audio to flac.\n\n    :param compression_level:   Any int value from 0 to 8 (Higher = better but slower)\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param verify:              Make the encoder verify each encoded sample while encoding to ensure valid output.\n    :param threads:             Number of threads to use for encoding. (Requires FLAC 1.5.0)\n                                `None` will choose whatever your CPU has with a max of 8.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    compression_level: int = 8\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    verify: bool = True\n    threads: int | None = None\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        flac = get_executable(\"flac\")\n        version = get_binary_version(flac, r\"flac .+? version (\\d\\.\\d+\\.\\d+)\")\n        output = make_output(fileIn.file, \"flac\", \"libflac\", self.output)\n        source = ensure_valid_in(fileIn, preprocess=self.preprocess, caller=self, valid_type=ValidInputType.W64_OR_FLAC, supports_pipe=False)\n        info(f\"Encoding '{fileIn.file.stem}' to FLAC using libFLAC...\", self)\n\n        args = [flac, f\"-{self.compression_level}\", \"-o\", str(output)] + self.get_custom_args()\n        if self.verify:\n            args.append(\"--verify\")\n\n        if self.threads or self.threads is None:\n            if re.search(r\"1\\.[2|3|4]\\.\\d+?\", version):\n                warn(\"Using outdated FLAC encoder that does not support threading!\", self)\n            else:\n                if self.threads is None:\n                    self.threads = min(os.cpu_count(), 8)\n                args.append(f\"--threads={self.threads}\")\n\n        args.append(str(source.file.resolve()) if isinstance(source, AudioFile) else \"-\")\n\n        stdin = subprocess.DEVNULL if isinstance(source, AudioFile) else source.stdout\n\n        if not run_cmd_pb(args, quiet, ProgressBarConfig(\"Encoding...\"), shell=False, stdin=stdin):\n            tags = dict(ENCODER=f\"FLAC {version}\", ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to FLAC using libFLAC failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/encoders/#muxtools.audio.encoders.FLACCL","title":"<code>FLACCL</code>","text":"<p>               Bases: <code>LosslessEncoder</code></p> <p>Uses the CUETools FLACCL encoder to encode audio to flac. This one uses OpenCL or Cuda depending on your GPU and claims to have better compression than libFLAC.</p> <p>Parameters:</p> Name Type Description Default <code>compression_level</code> <p>Any int value from 0 to 11 (Higher = better but slower) Keep in mind that over 8 is technically out of spec so we default to 8 here.</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>verify</code> <p>Make the encoder verify each encoded sample while encoding to ensure valid output.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/encoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass FLACCL(LosslessEncoder):\n    \"\"\"\n    Uses the CUETools FLACCL encoder to encode audio to flac.\n    This one uses OpenCL or Cuda depending on your GPU and claims to have better compression than libFLAC.\n\n    :param compression_level:   Any int value from 0 to 11 (Higher = better but slower)\n                                Keep in mind that over 8 is technically out of spec so we default to 8 here.\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param verify:              Make the encoder verify each encoded sample while encoding to ensure valid output.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    compression_level: int = 8\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    verify: bool = True\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        flaccl = get_executable(\"CUETools.FLACCL.cmd\")\n        output = make_output(fileIn.file, \"flac\", \"flaccl\", self.output)\n        source = ensure_valid_in(fileIn, preprocess=self.preprocess, caller=self, valid_type=ValidInputType.FLAC, supports_pipe=False)\n        info(f\"Encoding '{fileIn.file.stem}' to FLAC using FLACCL...\", self)\n\n        args = [flaccl, f\"-{self.compression_level}\", \"-o\", str(output)] + self.get_custom_args()\n        if self.compression_level &gt; 8:\n            args.append(\"--lax\")\n        if self.verify:\n            args.append(\"--verify\")\n        args.append(str(source.file.resolve()) if isinstance(source, AudioFile) else \"-\")\n\n        stdin = subprocess.DEVNULL if isinstance(source, AudioFile) else source.stdout\n\n        if not run_commandline(args, quiet, False, stdin):\n            tags = version_settings_dict(self.get_mediainfo_settings(args), flaccl, r\"CUETools FLACCL (\\d\\.\\d+\\.\\d+)\", prepend=\"FLACCL\")\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to FLAC using FLACCL failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/encoders/#muxtools.audio.encoders.Opus","title":"<code>Opus</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Uses opusenc to encode audio to opus.</p> <p>Parameters:</p> Name Type Description Default <code>bitrate</code> <p>Any int value representing kbps from 1 to 512 Automatically chooses 192 and 320 for stereo and surround respectively if None</p> required <code>vbr</code> <p>Uses VBR encoding if True</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/encoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass Opus(Encoder):\n    \"\"\"\n    Uses opusenc to encode audio to opus.\n\n    :param bitrate:             Any int value representing kbps from 1 to 512\n                                Automatically chooses 192 and 320 for stereo and surround respectively if None\n\n    :param vbr:                 Uses VBR encoding if True\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    bitrate: int | None = None\n    vbr: bool = True\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = None\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n\n        exe = get_executable(\"opusenc\")\n        source = ensure_valid_in(fileIn, preprocess=self.preprocess, caller=self, valid_type=ValidInputType.FLAC, supports_pipe=True)\n        bitrate = self.bitrate\n        if not bitrate:\n            track_info = fileIn.get_trackinfo()\n            channels = track_info.raw_ffprobe.channels or 2\n            match channels:\n                case _ if channels == 2 or [p for p in sanitize_pre(self.preprocess) if isinstance(p, Downmix)]:\n                    bitrate = 192\n                case _ if channels &gt; 6:\n                    bitrate = 420\n                case _:\n                    bitrate = 320\n            info(f\"Encoding '{fileIn.file.stem}' to Opus ({bitrate} kbps) using opusenc...\", self)\n        else:\n            info(f\"Encoding '{fileIn.file.stem}' to Opus using opusenc...\", self)\n\n        output = make_output(fileIn.file, \"opus\", \"opusenc\", self.output)\n\n        args = [exe, \"--vbr\" if self.vbr else \"--cvbr\", \"--bitrate\", str(bitrate)] + self.get_custom_args()\n        args.append(str(source.file.resolve()) if isinstance(source, AudioFile) else \"-\")\n        args.append(str(output))\n\n        stdin = subprocess.DEVNULL if isinstance(source, AudioFile) else source.stdout\n\n        if isinstance(source, AudioFile):\n            config = ProgressBarConfig(\"Encoding...\")\n        else:\n            config = ProgressBarConfig(\"Encoding...\", duration_from_file(fileIn, 0), regex=r\".*\\] (\\d+:\\d+:\\d+.\\d+).*\")\n\n        if not run_cmd_pb(args, quiet, config, shell=False, stdin=stdin):\n            tags = version_settings_dict(\n                self.get_mediainfo_settings(args), exe, r\"opusenc (opus-tools .+?\\(using libopus \\d+\\.\\d+(?:\\.\\d)?.+\\)?)\", [\"-V\"], prepend=\"opusenc\"\n            )\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to opus using opusenc failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/encoders/#muxtools.audio.encoders.qAAC","title":"<code>qAAC</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Uses qAAC to encode audio to AAC.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <p>Quality value ranging from 0 to 127 if using TVBR, otherwise bitrate in kbps</p> required <code>mode</code> <p>Encoding mode, Defaults to TVBR</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/encoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass qAAC(Encoder):\n    \"\"\"\n    Uses qAAC to encode audio to AAC.\n\n    :param q:                   Quality value ranging from 0 to 127 if using TVBR, otherwise bitrate in kbps\n    :param mode:                Encoding mode, Defaults to TVBR\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    q: int = 127\n    mode: qAAC_MODE | int = qAAC_MODE.TVBR\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = None\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        output = make_output(fileIn.file, \"aac\", \"qaac\", self.output)\n        source = ensure_valid_in(fileIn, preprocess=self.preprocess, caller=self, valid_type=ValidInputType.RF64, supports_pipe=True)\n        qaac = get_executable(\"qaac\")\n        ver = qaac_compatcheck()\n        tags = dict[str, str](ENCODER=f\"qaac {ver}\")\n\n        info(f\"Encoding '{fileIn.file.stem}' to AAC using qAAC...\", self)\n        args = [qaac, \"--no-delay\", \"--no-optimize\", \"--threading\", f\"--{self.mode.name.lower()}\", str(self.q)]\n        args.extend(self.get_custom_args())\n        args.extend([\"-o\", str(output), str(source.file.resolve()) if isinstance(source, AudioFile) else \"-\"])\n\n        stdin = subprocess.DEVNULL if isinstance(source, AudioFile) else source.stdout\n\n        if isinstance(source, AudioFile):\n            config = ProgressBarConfig(\"Encoding...\")\n        else:\n            config = ProgressBarConfig(\"Encoding...\", duration_from_file(fileIn, 0), regex=r\".*\\] (\\d+:\\d+:\\d+.\\d+).*\")\n\n        if not run_cmd_pb(args, quiet, config, shell=False, stdin=stdin):\n            tags.update(ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to AAC using qAAC failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/extractors/","title":"extractors","text":""},{"location":"muxtools/audio/extractors/#muxtools.audio.extractors.Eac3to","title":"<code>Eac3to</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extracts audio files using eac3to</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>int</code> <p>Relative audio track number</p> <code>0</code> <code>output</code> <code>PathLike | None</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> <code>None</code> <code>append</code> <code>str</code> <p>Specify a string of args you can pass to Eac3to</p> <code>''</code> Source code in <code>           muxtools/audio/extractors.py         </code> <pre><code>@dataclass\nclass Eac3to(Extractor):\n    \"\"\"\n    Extracts audio files using eac3to\n\n    :param track:               Relative audio track number\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    :param append:              Specify a string of args you can pass to Eac3to\n    \"\"\"\n\n    track: int = 0\n    output: PathLike | None = None\n    append: str = \"\"\n\n    def extract_audio(self, input: PathLike, quiet: bool = True) -&gt; AudioFile:\n        eac3to = get_executable(\"eac3to\")\n        parsed = ParsedFile.from_file(input, self)\n        track = parsed.find_tracks(relative_id=self.track, type=TrackType.AUDIO, caller=self, error_if_empty=True)[0]\n        form = track.get_audio_format()\n        if not form:\n            danger(f\"Unrecognized format: {track.codec_name}\\nWill extract as wav instead.\", self, 2)\n            extension = \"wav\"\n        else:\n            extension = form.extension\n\n        info(f\"Extracting audio track {self.track} from '{input.stem}'...\", self)\n\n        out = make_output(input, extension, f\"extracted_{self.track}\", self.output)\n        code, stdout = communicate_stdout(f'\"{eac3to}\" \"{input}\" {track.index + 1}: \"{out}\" {self.append}')\n        if code == 0:\n            if not out.exists():\n                pattern_str = rf\"{re.escape(out.stem)} DELAY.*\\.{extension}\"\n                pattern = re.compile(pattern_str, re.IGNORECASE)\n                for f in os.listdir(out.parent):\n                    if pattern.match(f):\n                        f = Path(out.parent, f)\n                        out = f.rename(f.with_stem(out.stem))\n                        break\n            delay = 0\n\n            pattern = re.compile(EAC3TO_DELAY_REGEX)\n            for line in stdout.splitlines():\n                match = re.search(pattern, line)\n                if match:\n                    delay = int(match.group(\"delay\"))\n                    debug(f\"Additional delay of {delay} ms will be applied to fix remaining sync.\", self)\n            return AudioFile(out, delay, input, duration=duration_from_file(input, self.track))\n        else:\n            print(\"\", stdout, \"\")\n            raise error(f\"eac3to failed to extract audio track {self.track} from '{input}'\", self.extract_audio)\n</code></pre>"},{"location":"muxtools/audio/extractors/#muxtools.audio.extractors.FFMpeg","title":"<code>FFMpeg</code>","text":"<p>               Bases: <code>HasExtractor</code>, <code>HasTrimmer</code></p> Source code in <code>           muxtools/audio/extractors.py         </code> <pre><code>class FFMpeg(HasExtractor, HasTrimmer):\n    @dataclass\n    class Extractor(Extractor):\n        \"\"\"\n        Extracts audio files using FFMPEG\n\n        :param track:               Relative audio track number\n        :param preserve_delay:      Will preserve existing container delay\n        :param output:              Custom output. Can be a dir or a file.\n                                    Do not specify an extension unless you know what you're doing.\n        :param skip_analysis:       Skip the audio analysis with FLAC for wasted bits on lossless audio.\n        \"\"\"\n\n        track: int = 0\n        preserve_delay: bool = True\n        output: PathLike | None = None\n        skip_analysis: bool = False\n\n        def __post_init__(self):\n            self.executable = get_executable(\"ffmpeg\")\n\n        def extract_audio(self, input: PathLike, quiet: bool = True, is_temp: bool = False, force_flac: bool = False) -&gt; AudioFile:\n            input = ensure_path_exists(input, self)\n            parsed = ParsedFile.from_file(input, self)\n            track = parsed.find_tracks(relative_id=self.track, type=TrackType.AUDIO, caller=self, error_if_empty=True)[0]\n            form = track.get_audio_format()\n            if not self._no_print:\n                info(f\"Extracting audio track {self.track} from '{parsed.source.stem}'...\", self)\n            if not form:\n                lossy = False\n                extension = \"wav\"\n                danger(\"Unrecognized format: {track.format}\\nWill extract as wav instead.\", self, 2)\n                out = make_output(input, extension, f\"extracted_{self.track}\", self.output, temp=is_temp)\n            else:\n                lossy = form.is_lossy\n                extension = form.extension\n                out = make_output(input, form.extension, f\"extracted_{self.track}\", self.output, temp=is_temp)\n\n            args = [self.executable, \"-hide_banner\", \"-i\", str(input.resolve()), \"-map_chapters\", \"-1\", \"-map\", f\"0:a:{self.track}\"]\n\n            specified_depth = track.bit_depth or 16\n            should_truncate = (\n                not self.skip_analysis\n                and not lossy\n                and form\n                and not form.should_not_transcode()\n                and bool(actual_depth := self._analyse_bitdepth(input, specified_depth, quiet))\n                and specified_depth &gt; actual_depth\n            )\n\n            if should_truncate:\n                if specified_depth &gt; actual_depth:\n                    debug(f\"Detected fake/padded {specified_depth} bit. Actual depth is {actual_depth} bit.\", self)\n                if actual_depth &lt;= 16:\n                    debug(\"Track will be converted to flac and truncated to 16 bit instead.\", self)\n                    out = make_output(input, \"flac\", f\"extracted_{self.track}\", self.output, temp=is_temp)\n                    args.extend([\"-c:a\", \"flac\", \"-sample_fmt\", \"s16\", \"-compression_level\", \"0\"])\n            else:\n                if force_flac and extension in [\"dts\", \"wav\"] and not lossy:\n                    out = make_output(input, \"flac\", f\"extracted_{self.track}\", self.output, temp=is_temp)\n                    args.extend([\"-c:a\", \"flac\", \"-compression_level\", \"0\"])\n                else:\n                    if extension == \"wav\":\n                        args.extend([\"-c:a\", \"pcm_s16le\" if specified_depth &lt;= 16 else \"pcm_s24le\", \"-rf64\", \"auto\"])\n                    else:\n                        args.extend([\"-c:a\", \"copy\"])\n                        if extension == \"dtshd\" or extension == \"dts\":\n                            # FFMPEG screams about dtshd not being a known output format but ffmpeg -formats lists it....\n                            args.extend([\"-f\", \"dts\"])\n\n            args.append(str(out))\n            duration = duration_from_file(input, self.track)\n            if not run_cmd_pb(args, quiet, ProgressBarConfig(\"Extracting...\", duration)):\n                return AudioFile(out, getattr(track, \"delay_relative_to_video\", 0) if self.preserve_delay else 0, input, None, duration)\n            else:\n                raise error(\"Failed to extract audio track using ffmpeg\", self)\n\n        def _analyse_bitdepth(self, file_in: PathLike, specified_depth: int, quiet: bool) -&gt; int:\n            flac = get_executable(\"flac\", can_error=False)\n            if not flac:\n                warn(\"No FLAC executable found. Please disable analysis explicitly or make sure you have FLAC in your path.\", self)\n                return 0\n            debug(\"Analysing audio track with libFLAC...\", self)\n            version = get_binary_version(flac, r\"flac .+? version (\\d\\.\\d+\\.\\d+)\")\n            temp_out = make_output(file_in, \"flac\", \"analysis\", temp=True)\n            args_ffmpeg = [\n                self.executable,\n                \"-hide_banner\",\n                \"-i\",\n                str(file_in),\n                \"-map\",\n                f\"0:a:{self.track}\",\n                \"-f\",\n                \"w64\",\n                \"-c:a\",\n                \"pcm_s16le\" if specified_depth &lt;= 16 else \"pcm_s24le\",\n                \"-\",\n            ]\n            ffmpeg_process = subprocess.Popen(\n                args_ffmpeg, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL if quiet else subprocess.STDOUT, text=False\n            )\n            args_flac = [flac, \"-0\", \"-o\", str(temp_out), \"-\"]\n            if re.search(r\"1\\.[2|3|4]\\.\\d+?\", version):\n                warn(\"Using outdated FLAC encoder that does not support threading!\", self)\n            else:\n                args_flac.append(f\"--threads={min(os.cpu_count(), 8)}\")\n\n            flac_returncode = run_commandline(args_flac, quiet, stdin=ffmpeg_process.stdout)\n            if flac_returncode:\n                danger(\"Failed to encode temp file via flac for analysis!\", self)\n                clean_temp_files()\n                return 0\n            returncode, stdout = communicate_stdout([flac, \"-sac\", str(temp_out)])\n            if returncode:\n                danger(\"Failed to analyse the temporary flac file!\", self)\n                clean_temp_files()\n                return 0\n\n            total = 0\n            n = 0\n            for line in stdout.splitlines():\n                if \"wasted_bits\" not in line:\n                    continue\n                idx = line.index(\"wasted_bits\") + len(\"wasted_bits\") + 1\n                try:\n                    wasted_bits = int(\"\".join(takewhile(str.isdigit, line[idx : idx + 3])))\n                    total += specified_depth - wasted_bits\n                    n += 1\n                except:\n                    debug(line, self)\n\n            average_bits = 0\n            if n &gt; 0:\n                average_bits = ((total * 10 // n) + 5) // 10\n            else:\n                danger(\"Audio analysis resulted in no valid bit depth entries!\", self)\n\n            clean_temp_files()\n            return average_bits\n\n    @dataclass\n    class Trimmer(Trimmer):\n        \"\"\"\n        Trims audio files using FFMPEG.\n        If you're working with lossless files it is strongly recommended to use SoX instead.\n\n        :param trim:                Can be a single trim or a sequence of trims.\n        :param preserve_delay:      Will preserve existing container delay\n        :param trim_use_ms:         Will use milliseconds instead of frame numbers\n        :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                    For details check the docstring on the type.\n        :param num_frames:          Total number of frames used for calculations\n        :param output:              Custom output. Can be a dir or a file.\n                                    Do not specify an extension unless you know what you're doing.\n        \"\"\"\n\n        trim: Trim | list[Trim] | None = None\n        preserve_delay: bool = False\n        trim_use_ms: bool = False\n        timesource: TimeSourceT = Fraction(24000, 1001)\n        timescale: TimeScaleT = TimeScale.MKV\n        num_frames: int = 0\n        output: PathLike | None = None\n\n        def _calc_delay(self, delay: int = 0, num_samples: int = 0, sample_rate: int = 48000) -&gt; int:\n            \"\"\"\n            Calculates the delay needed to fix the remaining sync for lossy audio.\n            \"\"\"\n            from math import ceil, floor\n\n            frame = num_samples * 1000 / sample_rate\n            leftover = (round(delay / frame) * frame) - delay\n            return ceil(leftover) if leftover &gt; 0 else floor(leftover)\n\n        def _targs(self, trim: Trim) -&gt; str:\n            \"\"\"\n            Converts trim to ffmpeg seek args.\n            \"\"\"\n            arg = \"\"\n            if trim[1] and trim[1] &lt; 0 and not self.trim_use_ms:\n                raise error(\"Negative input is not allowed for ms based trims.\", FFMpeg())\n\n            if trim[0] is not None and trim[0] &gt; 0:\n                if self.trim_use_ms:\n                    arg += f\" -ss {format_timedelta(timedelta(milliseconds=trim[0]))}\"\n                else:\n                    millis = self.resolved_ts.frame_to_time(trim[0], TimeType.EXACT, 3)\n                    arg += f\" -ss {format_timedelta(timedelta(milliseconds=millis))}\"\n            if trim[1] is not None and trim[1] != 0:\n                end_frame = self.num_frames + trim[1] if trim[1] &lt; 0 else trim[1]\n                if self.trim_use_ms:\n                    arg += f\" -to {format_timedelta(timedelta(milliseconds=trim[1]))}\"\n                else:\n                    millis = self.resolved_ts.frame_to_time(end_frame, TimeType.EXACT, 3)\n                    arg += f\" -to {format_timedelta(timedelta(milliseconds=millis))}\"\n            return arg\n\n        def trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n            if not isinstance(input, AudioFile):\n                input = AudioFile.from_file(input, self)\n            self.resolved_ts = resolve_timesource_and_scale(self.timesource, self.timescale, caller=self)\n            self.trim = sanitize_trims(self.trim, self.num_frames, not self.trim_use_ms, caller=self)\n\n            parsed = ParsedFile.from_file(input.file, self)\n            track = parsed.find_tracks(relative_id=0, type=TrackType.AUDIO, caller=self, error_if_empty=True)[0]\n            form = track.get_audio_format()\n            if not form:\n                raise error(f\"Unrecognized format: {track.codec_name}\", self)\n\n            lossy = form.is_lossy\n            args = [get_executable(\"ffmpeg\"), \"-hide_banner\", \"-i\", str(input.file.resolve()), \"-map\", \"0:a:0\"]\n            if form.should_not_transcode():\n                args.extend([\"-c:a\", \"copy\"])\n                extension = form.extension\n            else:\n                args.extend([\"-c:a\", \"flac\", \"-compression_level\", \"0\"])\n                extension = \"flac\"\n\n            out = make_output(input.file, extension, \"trimmed\", self.output)\n            ainfo = parse_audioinfo(input.file, is_thd=True, caller=self)\n\n            if len(self.trim) == 1:\n                info(f\"Trimming '{input.file.stem}' with ffmpeg...\", self)\n                tr = self.trim[0]\n                if lossy:\n                    args[2:1] = splitcommand(self._targs(tr))\n                else:\n                    args.extend(splitcommand(self._targs(tr)))\n                args.append(str(out.resolve()))\n                if not run_commandline(args, quiet):\n                    if tr[0] and lossy:\n                        ms = tr[0] if self.trim_use_ms else self.resolved_ts.frame_to_time(tr[0], TimeType.EXACT, 3)\n                        cont_delay = self._calc_delay(ms, ainfo.num_samples(), track.raw_ffprobe.sample_rate or 48000)\n                        debug(f\"Additional delay of {cont_delay} ms will be applied to fix remaining sync\", self)\n                        if self.preserve_delay:\n                            cont_delay += input.container_delay\n                    else:\n                        cont_delay = input.container_delay if self.preserve_delay else 0\n\n                    debug(\"Done\", self)\n                    return AudioFile(out, cont_delay, input.source)\n                else:\n                    raise error(\"Failed to trim audio using FFMPEG!\", self)\n            else:\n                info(f\"Generating trimmed tracks for '{input.file.stem}'...\", self)\n                concat: list = []\n                first = True\n                for i, tr in enumerate(self.trim):\n                    nArgs = args.copy()\n                    if lossy:\n                        nArgs[2:1] = splitcommand(self._targs(tr))\n                        if first:\n                            if tr[0]:\n                                ms = tr[0] if self.trim_use_ms else self.resolved_ts.frame_to_time(tr[0], TimeType.EXACT, 3)\n                                cont_delay = self._calc_delay(ms, ainfo.num_samples(), track.raw_ffprobe.sample_rate or 48000)\n                                debug(f\"Additional delay of {cont_delay} ms will be applied to fix remaining sync\", self)\n                            first = False\n                    else:\n                        nArgs.extend(splitcommand(self._targs(tr)))\n                        if first:\n                            cont_delay = input.container_delay if self.preserve_delay else 0\n                            first = False\n                    nout = os.path.join(get_temp_workdir(), f\"{input.file.stem}_part{i}.{extension}\")\n                    nArgs.append(nout)\n                    if not run_commandline(nArgs, quiet):\n                        concat.append(nout)\n                    else:\n                        raise error(\"Failed to trim audio using FFMPEG!\", self)\n                info(\"Concatenating the tracks...\", self)\n                concat_f = os.path.join(get_temp_workdir(), \"concat.txt\")\n                with open(concat_f, \"w\") as f:\n                    f.writelines([f\"file {_escape_name(c)}\\n\" for c in concat])\n\n                args[3] = concat_f\n                args[2:1] = [\"-f\", \"concat\", \"-safe\", \"0\"]\n                args.append(str(out.resolve()))\n\n                if not run_commandline(args, quiet):\n                    debug(\"Done\", self)\n                    clean_temp_files()\n                    return AudioFile(out, cont_delay, input.source)\n                else:\n                    clean_temp_files()\n                    raise error(\"Failed to trim audio using FFMPEG!\", self)\n\n    @dataclass\n    class Concat:\n        \"\"\"\n        Concat two or more audio files using FFMPEG.\n        (Also transcodes to FLAC if the formats don't match)\n\n        :param files:       List of PathLike or AudioFile to concat.\n\n        \"\"\"\n\n        files: Sequence[PathLike] | Sequence[AudioFile]\n        output: PathLike | None = None\n\n        def concat_audio(self, quiet: bool = True) -&gt; AudioFile:\n            audio_files = list[AudioFile]()\n            for f in self.files:\n                if isinstance(f, AudioFile):\n                    audio_files.append(f)\n                    continue\n                audio_files.append(FFMpeg.Extractor().extract_audio(f))\n\n            if any([af.has_multiple_tracks(self) for af in audio_files]):\n                raise error(\"One or more files passed have more than one audio track!\", self)\n\n            info(f\"Concatenating {len(audio_files)} audio tracks...\", self)\n\n            concat_file = get_temp_workdir() / \"concat.txt\"\n            with open(concat_file, \"w\", encoding=\"utf-8\") as f:\n                f.writelines([f\"file {_escape_name(str(af.file.resolve()))}\\n\" for af in audio_files])\n\n            first_format = audio_files[0].get_trackinfo().get_audio_format()\n            if not first_format:\n                raise error(f\"Concat cannot work with unknown formats! ({audio_files[0].get_trackinfo().codec_name})\", self)\n\n            format_mismatch = not all([af.get_trackinfo().get_audio_format() == first_format for af in audio_files[1:]])\n            if format_mismatch or first_format.extension == \"wav\":\n                out_codec = \"flac\"\n                out_ext = \"flac\"\n            else:\n                out_codec = \"copy\"\n                out_ext = first_format.extension\n\n            output = make_output(audio_files[0].file, out_ext, \"concat\", self.output)\n            args = [get_executable(\"ffmpeg\"), \"-f\", \"concat\", \"-safe\", \"0\", \"-i\", str(concat_file), \"-c\", out_codec, str(output)]\n\n            if not run_commandline(args, quiet):\n                debug(\"Done\", self)\n                clean_temp_files()\n\n                durations = [af.duration for af in audio_files if af.duration]\n                final_dura = timedelta(milliseconds=0)\n                for dura in durations:\n                    final_dura += dura\n\n                return AudioFile(output, audio_files[0].container_delay, audio_files[0].source, duration=final_dura)\n            else:\n                clean_temp_files()\n                raise error(\"Failed to trim audio using FFMPEG!\", self)\n</code></pre>"},{"location":"muxtools/audio/extractors/#muxtools.audio.extractors.FFMpeg.Concat","title":"<code>Concat</code>  <code>dataclass</code>","text":"<p>Concat two or more audio files using FFMPEG. (Also transcodes to FLAC if the formats don't match)</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Sequence[PathLike] | Sequence[AudioFile]</code> <p>List of PathLike or AudioFile to concat.</p> required Source code in <code>           muxtools/audio/extractors.py         </code> <pre><code>@dataclass\nclass Concat:\n    \"\"\"\n    Concat two or more audio files using FFMPEG.\n    (Also transcodes to FLAC if the formats don't match)\n\n    :param files:       List of PathLike or AudioFile to concat.\n\n    \"\"\"\n\n    files: Sequence[PathLike] | Sequence[AudioFile]\n    output: PathLike | None = None\n\n    def concat_audio(self, quiet: bool = True) -&gt; AudioFile:\n        audio_files = list[AudioFile]()\n        for f in self.files:\n            if isinstance(f, AudioFile):\n                audio_files.append(f)\n                continue\n            audio_files.append(FFMpeg.Extractor().extract_audio(f))\n\n        if any([af.has_multiple_tracks(self) for af in audio_files]):\n            raise error(\"One or more files passed have more than one audio track!\", self)\n\n        info(f\"Concatenating {len(audio_files)} audio tracks...\", self)\n\n        concat_file = get_temp_workdir() / \"concat.txt\"\n        with open(concat_file, \"w\", encoding=\"utf-8\") as f:\n            f.writelines([f\"file {_escape_name(str(af.file.resolve()))}\\n\" for af in audio_files])\n\n        first_format = audio_files[0].get_trackinfo().get_audio_format()\n        if not first_format:\n            raise error(f\"Concat cannot work with unknown formats! ({audio_files[0].get_trackinfo().codec_name})\", self)\n\n        format_mismatch = not all([af.get_trackinfo().get_audio_format() == first_format for af in audio_files[1:]])\n        if format_mismatch or first_format.extension == \"wav\":\n            out_codec = \"flac\"\n            out_ext = \"flac\"\n        else:\n            out_codec = \"copy\"\n            out_ext = first_format.extension\n\n        output = make_output(audio_files[0].file, out_ext, \"concat\", self.output)\n        args = [get_executable(\"ffmpeg\"), \"-f\", \"concat\", \"-safe\", \"0\", \"-i\", str(concat_file), \"-c\", out_codec, str(output)]\n\n        if not run_commandline(args, quiet):\n            debug(\"Done\", self)\n            clean_temp_files()\n\n            durations = [af.duration for af in audio_files if af.duration]\n            final_dura = timedelta(milliseconds=0)\n            for dura in durations:\n                final_dura += dura\n\n            return AudioFile(output, audio_files[0].container_delay, audio_files[0].source, duration=final_dura)\n        else:\n            clean_temp_files()\n            raise error(\"Failed to trim audio using FFMPEG!\", self)\n</code></pre>"},{"location":"muxtools/audio/extractors/#muxtools.audio.extractors.FFMpeg.Extractor","title":"<code>Extractor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extracts audio files using FFMPEG</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>int</code> <p>Relative audio track number</p> <code>0</code> <code>preserve_delay</code> <code>bool</code> <p>Will preserve existing container delay</p> <code>True</code> <code>output</code> <code>PathLike | None</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> <code>None</code> <code>skip_analysis</code> <code>bool</code> <p>Skip the audio analysis with FLAC for wasted bits on lossless audio.</p> <code>False</code> Source code in <code>           muxtools/audio/extractors.py         </code> <pre><code>@dataclass\nclass Extractor(Extractor):\n    \"\"\"\n    Extracts audio files using FFMPEG\n\n    :param track:               Relative audio track number\n    :param preserve_delay:      Will preserve existing container delay\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    :param skip_analysis:       Skip the audio analysis with FLAC for wasted bits on lossless audio.\n    \"\"\"\n\n    track: int = 0\n    preserve_delay: bool = True\n    output: PathLike | None = None\n    skip_analysis: bool = False\n\n    def __post_init__(self):\n        self.executable = get_executable(\"ffmpeg\")\n\n    def extract_audio(self, input: PathLike, quiet: bool = True, is_temp: bool = False, force_flac: bool = False) -&gt; AudioFile:\n        input = ensure_path_exists(input, self)\n        parsed = ParsedFile.from_file(input, self)\n        track = parsed.find_tracks(relative_id=self.track, type=TrackType.AUDIO, caller=self, error_if_empty=True)[0]\n        form = track.get_audio_format()\n        if not self._no_print:\n            info(f\"Extracting audio track {self.track} from '{parsed.source.stem}'...\", self)\n        if not form:\n            lossy = False\n            extension = \"wav\"\n            danger(\"Unrecognized format: {track.format}\\nWill extract as wav instead.\", self, 2)\n            out = make_output(input, extension, f\"extracted_{self.track}\", self.output, temp=is_temp)\n        else:\n            lossy = form.is_lossy\n            extension = form.extension\n            out = make_output(input, form.extension, f\"extracted_{self.track}\", self.output, temp=is_temp)\n\n        args = [self.executable, \"-hide_banner\", \"-i\", str(input.resolve()), \"-map_chapters\", \"-1\", \"-map\", f\"0:a:{self.track}\"]\n\n        specified_depth = track.bit_depth or 16\n        should_truncate = (\n            not self.skip_analysis\n            and not lossy\n            and form\n            and not form.should_not_transcode()\n            and bool(actual_depth := self._analyse_bitdepth(input, specified_depth, quiet))\n            and specified_depth &gt; actual_depth\n        )\n\n        if should_truncate:\n            if specified_depth &gt; actual_depth:\n                debug(f\"Detected fake/padded {specified_depth} bit. Actual depth is {actual_depth} bit.\", self)\n            if actual_depth &lt;= 16:\n                debug(\"Track will be converted to flac and truncated to 16 bit instead.\", self)\n                out = make_output(input, \"flac\", f\"extracted_{self.track}\", self.output, temp=is_temp)\n                args.extend([\"-c:a\", \"flac\", \"-sample_fmt\", \"s16\", \"-compression_level\", \"0\"])\n        else:\n            if force_flac and extension in [\"dts\", \"wav\"] and not lossy:\n                out = make_output(input, \"flac\", f\"extracted_{self.track}\", self.output, temp=is_temp)\n                args.extend([\"-c:a\", \"flac\", \"-compression_level\", \"0\"])\n            else:\n                if extension == \"wav\":\n                    args.extend([\"-c:a\", \"pcm_s16le\" if specified_depth &lt;= 16 else \"pcm_s24le\", \"-rf64\", \"auto\"])\n                else:\n                    args.extend([\"-c:a\", \"copy\"])\n                    if extension == \"dtshd\" or extension == \"dts\":\n                        # FFMPEG screams about dtshd not being a known output format but ffmpeg -formats lists it....\n                        args.extend([\"-f\", \"dts\"])\n\n        args.append(str(out))\n        duration = duration_from_file(input, self.track)\n        if not run_cmd_pb(args, quiet, ProgressBarConfig(\"Extracting...\", duration)):\n            return AudioFile(out, getattr(track, \"delay_relative_to_video\", 0) if self.preserve_delay else 0, input, None, duration)\n        else:\n            raise error(\"Failed to extract audio track using ffmpeg\", self)\n\n    def _analyse_bitdepth(self, file_in: PathLike, specified_depth: int, quiet: bool) -&gt; int:\n        flac = get_executable(\"flac\", can_error=False)\n        if not flac:\n            warn(\"No FLAC executable found. Please disable analysis explicitly or make sure you have FLAC in your path.\", self)\n            return 0\n        debug(\"Analysing audio track with libFLAC...\", self)\n        version = get_binary_version(flac, r\"flac .+? version (\\d\\.\\d+\\.\\d+)\")\n        temp_out = make_output(file_in, \"flac\", \"analysis\", temp=True)\n        args_ffmpeg = [\n            self.executable,\n            \"-hide_banner\",\n            \"-i\",\n            str(file_in),\n            \"-map\",\n            f\"0:a:{self.track}\",\n            \"-f\",\n            \"w64\",\n            \"-c:a\",\n            \"pcm_s16le\" if specified_depth &lt;= 16 else \"pcm_s24le\",\n            \"-\",\n        ]\n        ffmpeg_process = subprocess.Popen(\n            args_ffmpeg, stdin=subprocess.DEVNULL, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL if quiet else subprocess.STDOUT, text=False\n        )\n        args_flac = [flac, \"-0\", \"-o\", str(temp_out), \"-\"]\n        if re.search(r\"1\\.[2|3|4]\\.\\d+?\", version):\n            warn(\"Using outdated FLAC encoder that does not support threading!\", self)\n        else:\n            args_flac.append(f\"--threads={min(os.cpu_count(), 8)}\")\n\n        flac_returncode = run_commandline(args_flac, quiet, stdin=ffmpeg_process.stdout)\n        if flac_returncode:\n            danger(\"Failed to encode temp file via flac for analysis!\", self)\n            clean_temp_files()\n            return 0\n        returncode, stdout = communicate_stdout([flac, \"-sac\", str(temp_out)])\n        if returncode:\n            danger(\"Failed to analyse the temporary flac file!\", self)\n            clean_temp_files()\n            return 0\n\n        total = 0\n        n = 0\n        for line in stdout.splitlines():\n            if \"wasted_bits\" not in line:\n                continue\n            idx = line.index(\"wasted_bits\") + len(\"wasted_bits\") + 1\n            try:\n                wasted_bits = int(\"\".join(takewhile(str.isdigit, line[idx : idx + 3])))\n                total += specified_depth - wasted_bits\n                n += 1\n            except:\n                debug(line, self)\n\n        average_bits = 0\n        if n &gt; 0:\n            average_bits = ((total * 10 // n) + 5) // 10\n        else:\n            danger(\"Audio analysis resulted in no valid bit depth entries!\", self)\n\n        clean_temp_files()\n        return average_bits\n</code></pre>"},{"location":"muxtools/audio/extractors/#muxtools.audio.extractors.FFMpeg.Trimmer","title":"<code>Trimmer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Trimmer</code></p> <p>Trims audio files using FFMPEG. If you're working with lossless files it is strongly recommended to use SoX instead.</p> <p>Parameters:</p> Name Type Description Default <code>trim</code> <code>Trim | list[Trim] | None</code> <p>Can be a single trim or a sequence of trims.</p> <code>None</code> <code>preserve_delay</code> <code>bool</code> <p>Will preserve existing container delay</p> <code>False</code> <code>trim_use_ms</code> <code>bool</code> <p>Will use milliseconds instead of frame numbers</p> <code>False</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>Fraction(24000, 1001)</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>num_frames</code> <code>int</code> <p>Total number of frames used for calculations</p> <code>0</code> <code>output</code> <code>PathLike | None</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> <code>None</code> Source code in <code>           muxtools/audio/extractors.py         </code> <pre><code>@dataclass\nclass Trimmer(Trimmer):\n    \"\"\"\n    Trims audio files using FFMPEG.\n    If you're working with lossless files it is strongly recommended to use SoX instead.\n\n    :param trim:                Can be a single trim or a sequence of trims.\n    :param preserve_delay:      Will preserve existing container delay\n    :param trim_use_ms:         Will use milliseconds instead of frame numbers\n    :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n    :param num_frames:          Total number of frames used for calculations\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    trim: Trim | list[Trim] | None = None\n    preserve_delay: bool = False\n    trim_use_ms: bool = False\n    timesource: TimeSourceT = Fraction(24000, 1001)\n    timescale: TimeScaleT = TimeScale.MKV\n    num_frames: int = 0\n    output: PathLike | None = None\n\n    def _calc_delay(self, delay: int = 0, num_samples: int = 0, sample_rate: int = 48000) -&gt; int:\n        \"\"\"\n        Calculates the delay needed to fix the remaining sync for lossy audio.\n        \"\"\"\n        from math import ceil, floor\n\n        frame = num_samples * 1000 / sample_rate\n        leftover = (round(delay / frame) * frame) - delay\n        return ceil(leftover) if leftover &gt; 0 else floor(leftover)\n\n    def _targs(self, trim: Trim) -&gt; str:\n        \"\"\"\n        Converts trim to ffmpeg seek args.\n        \"\"\"\n        arg = \"\"\n        if trim[1] and trim[1] &lt; 0 and not self.trim_use_ms:\n            raise error(\"Negative input is not allowed for ms based trims.\", FFMpeg())\n\n        if trim[0] is not None and trim[0] &gt; 0:\n            if self.trim_use_ms:\n                arg += f\" -ss {format_timedelta(timedelta(milliseconds=trim[0]))}\"\n            else:\n                millis = self.resolved_ts.frame_to_time(trim[0], TimeType.EXACT, 3)\n                arg += f\" -ss {format_timedelta(timedelta(milliseconds=millis))}\"\n        if trim[1] is not None and trim[1] != 0:\n            end_frame = self.num_frames + trim[1] if trim[1] &lt; 0 else trim[1]\n            if self.trim_use_ms:\n                arg += f\" -to {format_timedelta(timedelta(milliseconds=trim[1]))}\"\n            else:\n                millis = self.resolved_ts.frame_to_time(end_frame, TimeType.EXACT, 3)\n                arg += f\" -to {format_timedelta(timedelta(milliseconds=millis))}\"\n        return arg\n\n    def trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n        if not isinstance(input, AudioFile):\n            input = AudioFile.from_file(input, self)\n        self.resolved_ts = resolve_timesource_and_scale(self.timesource, self.timescale, caller=self)\n        self.trim = sanitize_trims(self.trim, self.num_frames, not self.trim_use_ms, caller=self)\n\n        parsed = ParsedFile.from_file(input.file, self)\n        track = parsed.find_tracks(relative_id=0, type=TrackType.AUDIO, caller=self, error_if_empty=True)[0]\n        form = track.get_audio_format()\n        if not form:\n            raise error(f\"Unrecognized format: {track.codec_name}\", self)\n\n        lossy = form.is_lossy\n        args = [get_executable(\"ffmpeg\"), \"-hide_banner\", \"-i\", str(input.file.resolve()), \"-map\", \"0:a:0\"]\n        if form.should_not_transcode():\n            args.extend([\"-c:a\", \"copy\"])\n            extension = form.extension\n        else:\n            args.extend([\"-c:a\", \"flac\", \"-compression_level\", \"0\"])\n            extension = \"flac\"\n\n        out = make_output(input.file, extension, \"trimmed\", self.output)\n        ainfo = parse_audioinfo(input.file, is_thd=True, caller=self)\n\n        if len(self.trim) == 1:\n            info(f\"Trimming '{input.file.stem}' with ffmpeg...\", self)\n            tr = self.trim[0]\n            if lossy:\n                args[2:1] = splitcommand(self._targs(tr))\n            else:\n                args.extend(splitcommand(self._targs(tr)))\n            args.append(str(out.resolve()))\n            if not run_commandline(args, quiet):\n                if tr[0] and lossy:\n                    ms = tr[0] if self.trim_use_ms else self.resolved_ts.frame_to_time(tr[0], TimeType.EXACT, 3)\n                    cont_delay = self._calc_delay(ms, ainfo.num_samples(), track.raw_ffprobe.sample_rate or 48000)\n                    debug(f\"Additional delay of {cont_delay} ms will be applied to fix remaining sync\", self)\n                    if self.preserve_delay:\n                        cont_delay += input.container_delay\n                else:\n                    cont_delay = input.container_delay if self.preserve_delay else 0\n\n                debug(\"Done\", self)\n                return AudioFile(out, cont_delay, input.source)\n            else:\n                raise error(\"Failed to trim audio using FFMPEG!\", self)\n        else:\n            info(f\"Generating trimmed tracks for '{input.file.stem}'...\", self)\n            concat: list = []\n            first = True\n            for i, tr in enumerate(self.trim):\n                nArgs = args.copy()\n                if lossy:\n                    nArgs[2:1] = splitcommand(self._targs(tr))\n                    if first:\n                        if tr[0]:\n                            ms = tr[0] if self.trim_use_ms else self.resolved_ts.frame_to_time(tr[0], TimeType.EXACT, 3)\n                            cont_delay = self._calc_delay(ms, ainfo.num_samples(), track.raw_ffprobe.sample_rate or 48000)\n                            debug(f\"Additional delay of {cont_delay} ms will be applied to fix remaining sync\", self)\n                        first = False\n                else:\n                    nArgs.extend(splitcommand(self._targs(tr)))\n                    if first:\n                        cont_delay = input.container_delay if self.preserve_delay else 0\n                        first = False\n                nout = os.path.join(get_temp_workdir(), f\"{input.file.stem}_part{i}.{extension}\")\n                nArgs.append(nout)\n                if not run_commandline(nArgs, quiet):\n                    concat.append(nout)\n                else:\n                    raise error(\"Failed to trim audio using FFMPEG!\", self)\n            info(\"Concatenating the tracks...\", self)\n            concat_f = os.path.join(get_temp_workdir(), \"concat.txt\")\n            with open(concat_f, \"w\") as f:\n                f.writelines([f\"file {_escape_name(c)}\\n\" for c in concat])\n\n            args[3] = concat_f\n            args[2:1] = [\"-f\", \"concat\", \"-safe\", \"0\"]\n            args.append(str(out.resolve()))\n\n            if not run_commandline(args, quiet):\n                debug(\"Done\", self)\n                clean_temp_files()\n                return AudioFile(out, cont_delay, input.source)\n            else:\n                clean_temp_files()\n                raise error(\"Failed to trim audio using FFMPEG!\", self)\n</code></pre>"},{"location":"muxtools/audio/extractors/#muxtools.audio.extractors.Sox","title":"<code>Sox</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Trimmer</code></p> <p>Trim lossless audio using SoX.</p> <p>Parameters:</p> Name Type Description Default <code>trim</code> <code>Trim | list[Trim] | None</code> <p>List of Trims or a single Trim, which is a Tuple of two frame numbers or milliseconds</p> <code>None</code> <code>preserve_delay</code> <code>bool</code> <p>Keeps existing container delay if True</p> <code>False</code> <code>trim_use_ms</code> <code>bool</code> <p>Will use milliseconds instead of frame numbers</p> <code>False</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>Fraction(24000, 1001)</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>num_frames</code> <code>int</code> <p>Total number of frames used for calculations</p> <code>0</code> <code>output</code> <code>PathLike | None</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> <code>None</code> Source code in <code>           muxtools/audio/extractors.py         </code> <pre><code>@dataclass\nclass Sox(Trimmer):\n    \"\"\"\n    Trim lossless audio using SoX.\n\n    :param trim:                List of Trims or a single Trim, which is a Tuple of two frame numbers or milliseconds\n    :param preserve_delay:      Keeps existing container delay if True\n    :param trim_use_ms:         Will use milliseconds instead of frame numbers\n    :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n    :param num_frames:          Total number of frames used for calculations\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    trim: Trim | list[Trim] | None = None\n    preserve_delay: bool = False\n    trim_use_ms: bool = False\n    timesource: TimeSourceT = Fraction(24000, 1001)\n    timescale: TimeScaleT = TimeScale.MKV\n    num_frames: int = 0\n    output: PathLike | None = None\n\n    def _conv(self, val: int | None):\n        if val is None:\n            return None\n\n        if self.trim_use_ms:\n            return abs(val) / 1000\n        else:\n            return self.resolved_ts.frame_to_time(abs(val), TimeType.EXACT).__float__()\n\n    def trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n        import sox\n\n        if not isinstance(input, AudioFile):\n            input = AudioFile.from_file(input, self)\n        out = make_output(input.file, \"flac\", \"trimmed\", self.output)\n        self.resolved_ts = resolve_timesource_and_scale(self.timesource, self.timescale, caller=self)\n        self.trim = sanitize_trims(self.trim, self.num_frames, not self.trim_use_ms, allow_negative_start=True, caller=self)\n        source = ensure_valid_in(input, caller=self, supports_pipe=False)\n\n        if len(self.trim) &gt; 1:\n            files_to_concat = []\n            first = True\n            info(f\"Generating trimmed tracks for '{input.file.stem}'...\", self)\n            for i, t in enumerate(self.trim):\n                soxr = sox.Transformer()\n                soxr.set_globals(multithread=True, verbosity=0 if quiet else 1)\n                if t[0] &lt; 0 and first:\n                    soxr.trim(0, self._conv(t[1]))\n                    soxr.pad(self._conv(t[0]))\n                else:\n                    soxr.trim(self._conv(t[0]), self._conv(t[1]))\n                first = False\n                tout = os.path.join(get_temp_workdir(), f\"{input.file.stem}_trimmed_part{i}.wav\")\n                soxr.build(str(source.file.resolve()), tout)\n                files_to_concat.append(tout)\n\n            info(\"Concatenating the tracks...\", self)\n            soxr = sox.Combiner()\n            soxr.set_globals(multithread=True, verbosity=0 if quiet else 1)\n            formats = [\"wav\" for file in files_to_concat]\n            soxr.set_input_format(file_type=formats)\n            soxr.build(files_to_concat, str(out.resolve()), \"concatenate\")\n            debug(\"Done\", self)\n        else:\n            soxr = sox.Transformer()\n            soxr.set_globals(multithread=True, verbosity=0 if quiet else 1)\n            info(f\"Applying trim to '{input.file.stem}'\", self)\n            t = self.trim[0]\n            if t[0] &lt; 0:\n                soxr.trim(0, self._conv(t[1]))\n                soxr.pad(self._conv(t[0]))\n            else:\n                soxr.trim(self._conv(t[0]), self._conv(t[1]))\n            soxr.build(str(source.file), str(out.resolve()))\n            debug(\"Done\", self)\n\n        clean_temp_files()\n        return AudioFile(out.resolve(), input.container_delay if self.preserve_delay else 0, input.source)\n</code></pre>"},{"location":"muxtools/audio/memecoders/","title":"memecoders","text":"<p>This contains a few either amusing or mostly useless codecs/encoders.</p> <p>Thought they might be cool to have atleast.</p>"},{"location":"muxtools/audio/memecoders/#muxtools.audio.memecoders.LossyWav","title":"<code>LossyWav</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>A lossy (lol) preprocessor for wav/pcm audio that selectively reduces bitdepth by zero'ing out certain bits. Certain lossless encoders like FLAC (only the reference one) will get a massive size reduction that way. I don't really see a use for this over actual lossy codecs besides making a meme release.</p> <p>Parameters:</p> Name Type Description Default <code>quality</code> <p>Lossywav Quality Preset</p> required <code>target_encoder</code> <p>Whatever encoder the lossy wav file will be fed to. (lossless encoders only) Only properly supports libFLAC and wavpack (will be added later) out of what we have.</p> required <code>override_options</code> <p>Automatically sets the appropriate options for each encoder to work as intended.</p> required <code>limit</code> <p>Frequency cutoff in hz.</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/memecoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass LossyWav(Encoder):\n    \"\"\"\n    A lossy (lol) preprocessor for wav/pcm audio that selectively reduces bitdepth by zero'ing out certain bits.\n    Certain lossless encoders like FLAC (only the reference one) will get a massive size reduction that way.\n    I don't really see a use for this over actual lossy codecs besides making a meme release.\n\n\n    :param quality:             Lossywav Quality Preset\n    :param target_encoder:      Whatever encoder the lossy wav file will be fed to. (lossless encoders only)\n                                Only properly supports libFLAC and wavpack (will be added later) out of what we have.\n\n    :param override_options:    Automatically sets the appropriate options for each encoder to work as intended.\n    :param limit:               Frequency cutoff in hz.\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    quality: LossyWavQuality = LossyWavQuality.INSANE\n    target_encoder: LosslessEncoder | None = None\n    override_options: bool = True\n    limit: int = 20000\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not self.target_encoder:\n            self.target_encoder = FLAC()\n        if not self.target_encoder.lossless:\n            raise error(\"Target Encoder can only be a lossless one.\", self)\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n\n        output = ensure_valid_in(fileIn, False, self.preprocess, valid_type=ValidInputType.W64, caller=self)\n\n        args = [\n            get_executable(\"lossyWAV\", False),\n            str(output.file),\n            \"--quality\",\n            self.quality.name.lower(),\n            \"-l\",\n            str(self.limit),\n            \"-o\",\n            str(get_temp_workdir()),\n        ]\n        info(\"Creating LossyWAV intermediary...\", self)\n        if run_cmd_pb(args, quiet, ProgressBarConfig(\"Encoding...\")):\n            raise crit(\"LossyWAV conversion failed!\", self)\n\n        lossy = Path(get_temp_workdir(), output.file.with_stem(output.file.stem + \".lossy\").name)\n        setattr(self.target_encoder, \"preprocess\", None)\n        if self.override_options:\n            if isinstance(self.target_encoder, FLAC):\n                setattr(self.target_encoder, \"compression_level\", 5)\n                setattr(self.target_encoder, \"append\", \"-b 512\")\n            elif isinstance(self.target_encoder, Wavpack):\n                setattr(self.target_encoder, \"append\", \"--blocksize=512 --merge-blocks\")\n\n        encoded = self.target_encoder.encode_audio(AudioFile(lossy, fileIn.container_delay, fileIn.source), quiet)\n        clean_temp_files()\n        return encoded\n</code></pre>"},{"location":"muxtools/audio/memecoders/#muxtools.audio.memecoders.TTA","title":"<code>TTA</code>","text":"<p>               Bases: <code>LosslessEncoder</code></p> <p>Uses ffmpeg to encode audio to TTA/The True Audio. (I could not get the reference encoder to work with any ffmpeg wav or any flac) This doesn't really seem to have any benefit over FLAC except for maybe encode speed? Definitely has a cool name tho.</p> <p>Parameters:</p> Name Type Description Default <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/memecoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass TTA(LosslessEncoder):\n    \"\"\"\n    Uses ffmpeg to encode audio to TTA/The True Audio.\n    (I could not get the reference encoder to work with any ffmpeg wav or any flac)\n    This doesn't really seem to have any benefit over FLAC except for maybe encode speed?\n    Definitely has a cool name tho.\n\n\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        output = make_output(fileIn.file, \"tta\", \"encoded\", self.output)\n        tags = dict[str, str](ENCODER=\"ffmpeg -c:a tta\")\n\n        args = [get_executable(\"ffmpeg\"), \"-hide_banner\", \"-i\", str(fileIn.file.resolve()), \"-map\", \"0:a:0\", \"-c:a\", \"tta\"]\n        args.extend(get_preprocess_args(fileIn, self.preprocess, fileIn.get_trackinfo(), self) + self.get_custom_args())\n        args.append(str(output))\n\n        info(f\"Encoding '{fileIn.file.stem}' to TTA using ffmpeg...\", self)\n        if not run_cmd_pb(args, quiet, ProgressBarConfig(\"Encoding...\", duration_from_file(fileIn))):\n            tags.update(ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to TTA using ffmpeg failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/memecoders/#muxtools.audio.memecoders.Wavpack","title":"<code>Wavpack</code>","text":"<p>               Bases: <code>LosslessEncoder</code></p> <p>Another interesting lossless codec even if solely for the fact that it supports 32bit float and an arbitrary amount of channels. Compression seems to be ever so slightly worse than FLAC from my very scarce testing.</p> <p>Parameters:</p> Name Type Description Default <code>fast</code> <p>Use either fast or high quality modes. Obviously fast means less compression.</p> required <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/memecoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass Wavpack(LosslessEncoder):\n    \"\"\"\n    Another interesting lossless codec even if solely for the fact that it supports 32bit float and an arbitrary amount of channels.\n    Compression seems to be ever so slightly worse than FLAC from my very scarce testing.\n\n    :param fast:                Use either fast or high quality modes. Obviously fast means less compression.\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    fast: bool = False\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n\n        valid_in = ensure_valid_in(fileIn, False, self.preprocess, valid_type=ValidInputType.RF64, caller=self)\n        output = make_output(fileIn.file, \"wv\", \"wavpack\", self.output)\n\n        wavpack = get_executable(\"wavpack\")\n\n        args = [wavpack, \"-f\" if self.fast else \"-h\"] + self.get_custom_args()\n        args.extend([str(valid_in.file), str(output)])\n        info(f\"Encoding '{fileIn.file.stem}' to wavpack...\", self)\n        if run_cmd_pb(args, quiet, ProgressBarConfig(\"Encoding...\")):\n            raise error(\"Failed to encode audio to wavpack!\", self)\n\n        tags = version_settings_dict(self.get_mediainfo_settings(args), wavpack, r\"WAVPACK .+? Version (\\d\\.\\d+\\.\\d+)\", prepend=\"WavPack\")\n        clean_temp_files()\n        return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n</code></pre>"},{"location":"muxtools/audio/memecoders/#muxtools.audio.memecoders.qALAC","title":"<code>qALAC</code>","text":"<p>               Bases: <code>Encoder</code></p> <p>Uses qAAC encoder to encode audio to ALAC. This is basically just worse FLAC and the only real use is good Apple hardware support.</p> <p>Parameters:</p> Name Type Description Default <code>preprocess</code> <p>Any amount of preprocessors to run before passing it to the encoder.</p> required <code>output</code> <p>Custom output. Can be a dir or a file. Do not specify an extension unless you know what you're doing.</p> required Source code in <code>           muxtools/audio/memecoders.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass qALAC(Encoder):\n    \"\"\"\n    Uses qAAC encoder to encode audio to ALAC.\n    This is basically just worse FLAC and the only real use is good Apple hardware support.\n\n    :param preprocess:          Any amount of preprocessors to run before passing it to the encoder.\n    :param output:              Custom output. Can be a dir or a file.\n                                Do not specify an extension unless you know what you're doing.\n    \"\"\"\n\n    preprocess: Preprocessor | Sequence[Preprocessor] | None = Field(default_factory=Resample)\n    output: PathLike | None = None\n\n    def encode_audio(self, fileIn: AudioFile | PathLike, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        if not isinstance(fileIn, AudioFile):\n            fileIn = AudioFile.from_file(fileIn, self)\n        output = make_output(fileIn.file, \"alac\", \"qaac\", self.output)\n        source = ensure_valid_in(fileIn, preprocess=self.preprocess, caller=self, valid_type=ValidInputType.RF64, supports_pipe=True)\n        qaac = get_executable(\"qaac\")\n        ver = qaac_compatcheck()\n        tags = dict[str, str](ENCODER=f\"qaac {ver}\")\n\n        info(f\"Encoding '{fileIn.file.stem}' to ALAC using qAAC...\", self)\n        args = [qaac, \"-A\", \"--no-optimize\", \"--threading\"] + self.get_custom_args()\n        args.extend([\"-o\", str(output), str(source.file.resolve()) if isinstance(source, AudioFile) else \"-\"])\n\n        stdin = subprocess.DEVNULL if isinstance(source, AudioFile) else source.stdout\n\n        if isinstance(source, AudioFile):\n            config = ProgressBarConfig(\"Encoding...\")\n        else:\n            config = ProgressBarConfig(\"Encoding...\", duration_from_file(fileIn, 0), regex=r\".*\\] (\\d+:\\d+:\\d+.\\d+).*\")\n\n        if not run_cmd_pb(args, quiet, config, shell=False, stdin=stdin):\n            tags.update(ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n            clean_temp_files()\n            return AudioFile(output, fileIn.container_delay, fileIn.source, tags=tags)\n        else:\n            raise crit(\"Encoding to ALAC using qAAC failed!\", self)\n</code></pre>"},{"location":"muxtools/audio/preprocess/","title":"preprocess","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.__all__","title":"<code>__all__ = ['Resample', 'Loudnorm', 'Downmix', 'Pan', 'CustomPreprocessor']</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Pan","title":"<code>Pan = Downmix</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Preprocessor","title":"<code>Preprocessor</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>class Preprocessor(ABC):\n    refresh_metadata = False\n\n    def get_filter(self, caller: Any = None) -&gt; str | None:\n        return None\n\n    def get_args(self, caller: Any = None) -&gt; Sequence[str]:\n        return []\n\n    def analyze(self, file: AudioFile):\n        return None\n\n    @abstractmethod\n    def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool: ...\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Preprocessor.refresh_metadata","title":"<code>refresh_metadata = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Preprocessor.get_filter","title":"<code>get_filter(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_filter(self, caller: Any = None) -&gt; str | None:\n    return None\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Preprocessor.get_args","title":"<code>get_args(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_args(self, caller: Any = None) -&gt; Sequence[str]:\n    return []\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Preprocessor.analyze","title":"<code>analyze(file)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def analyze(self, file: AudioFile):\n    return None\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Preprocessor.can_run","title":"<code>can_run(track, preprocessors)</code>  <code>abstractmethod</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>@abstractmethod\ndef can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool: ...\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample","title":"<code>Resample</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>A FFMPEG Resampling preprocessor. This is used to dither down to 16 bit and resample to 48kHz by default. Uses the sox resampler internally for best results.</p> <p>Parameters:</p> Name Type Description Default <code>dither</code> <code>DitherType</code> <p>The dither algorithm to use. Uses SoX's default by default.</p> <code>TRIANGULAR</code> <code>depth</code> <code>int | None</code> <p>The bitdepth to dither to. <code>None</code> will not change the depth. You can technically only choose 16 or 32 as 24 is apparently just 32 with padding and needs specific codec support.</p> <code>16</code> <code>sample_rate</code> <code>int</code> <p>The sample rate to resample to. Defaults to 48kHz because most encoders support it.</p> <code>48000</code> Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>@dataclass\nclass Resample(Preprocessor):\n    \"\"\"\n    A FFMPEG Resampling preprocessor.\n    This is used to dither down to 16 bit and resample to 48kHz by default.\n    Uses the sox resampler internally for best results.\n\n    :param dither:          The dither algorithm to use. Uses SoX's default by default.\n    :param depth:           The bitdepth to dither to. `None` will not change the depth.\n                            You can technically only choose 16 or 32 as 24 is apparently just 32 with padding and needs specific codec support.\n    :param sample_rate:     The sample rate to resample to. Defaults to 48kHz because most encoders support it.\n    \"\"\"\n\n    dither: DitherType = DitherType.TRIANGULAR\n    depth: int | None = 16\n    sample_rate: int = 48000\n    refresh_metadata = True\n\n    def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n        # Run if depth or sample rate differ. Also run if loudnorm is being used.\n        return (\n            (self.depth and track.bit_depth != self.depth)\n            or track.raw_ffprobe.sample_rate != self.sample_rate\n            or [p for p in preprocessors if isinstance(p, Loudnorm)]\n        )\n\n    def get_args(self, caller: Any = None) -&gt; Sequence[str]:\n        if caller:\n            debug(\n                (\n                    f\"Resampling to {self.depth} bit and {self.sample_rate / 1000} kHz...\"\n                    if self.depth\n                    else f\"Resampling to {self.sample_rate / 1000} kHz...\"\n                ),\n                caller,\n            )\n        return (\n            []\n            if not self.depth\n            else [\"-sample_fmt\", f\"s{self.depth}\"]\n            + [\n                \"-ar\",\n                str(self.sample_rate),\n                \"-resampler\",\n                \"soxr\",\n                \"-precision\",\n                \"24\",\n                \"-dither_method\",\n                self.dither.name.lower(),\n            ]\n        )\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.dither","title":"<code>dither = DitherType.TRIANGULAR</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.depth","title":"<code>depth = 16</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.sample_rate","title":"<code>sample_rate = 48000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.refresh_metadata","title":"<code>refresh_metadata = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.__init__","title":"<code>__init__(dither=DitherType.TRIANGULAR, depth=16, sample_rate=48000)</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.can_run","title":"<code>can_run(track, preprocessors)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n    # Run if depth or sample rate differ. Also run if loudnorm is being used.\n    return (\n        (self.depth and track.bit_depth != self.depth)\n        or track.raw_ffprobe.sample_rate != self.sample_rate\n        or [p for p in preprocessors if isinstance(p, Loudnorm)]\n    )\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Resample.get_args","title":"<code>get_args(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_args(self, caller: Any = None) -&gt; Sequence[str]:\n    if caller:\n        debug(\n            (\n                f\"Resampling to {self.depth} bit and {self.sample_rate / 1000} kHz...\"\n                if self.depth\n                else f\"Resampling to {self.sample_rate / 1000} kHz...\"\n            ),\n            caller,\n        )\n    return (\n        []\n        if not self.depth\n        else [\"-sample_fmt\", f\"s{self.depth}\"]\n        + [\n            \"-ar\",\n            str(self.sample_rate),\n            \"-resampler\",\n            \"soxr\",\n            \"-precision\",\n            \"24\",\n            \"-dither_method\",\n            self.dither.name.lower(),\n        ]\n    )\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.classproperty","title":"<code>classproperty</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>class classproperty(object):\n    def __init__(self, f):\n        self.f = classmethod(f)\n\n    def __get__(self, *a):\n        return self.f.__get__(*a)()\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.classproperty.f","title":"<code>f = classmethod(f)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.classproperty.__init__","title":"<code>__init__(f)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def __init__(self, f):\n    self.f = classmethod(f)\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.classproperty.__get__","title":"<code>__get__(*a)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def __get__(self, *a):\n    return self.f.__get__(*a)()\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix","title":"<code>Downmix</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>A FFMPEG downmixing/pan preprocessor. This essentially just uses the pan filter and offers a few presets.</p> <p>If you're looking for explanations or other infos feel free to read these threads: https://superuser.com/questions/852400/properly-downmix-5-1-to-stereo-using-ffmpeg https://github.com/mpv-player/mpv/issues/6343</p> <p>Parameters:</p> Name Type Description Default <code>mixing</code> <code>str | None</code> <p>The Pan filter string. Defaults to the Dave_750 preset. Honestly no recommendations here. Try them all and use what you prefer.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Force processing even if there are only 2 channels.</p> <code>False</code> Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>@dataclass\nclass Downmix(Preprocessor):\n    \"\"\"\n    A FFMPEG downmixing/pan preprocessor.\n    This essentially just uses the [pan](http://ffmpeg.org/ffmpeg-all.html#pan-1) filter and offers a few presets.\n\n    If you're looking for explanations or other infos feel free to read these threads:\n    https://superuser.com/questions/852400/properly-downmix-5-1-to-stereo-using-ffmpeg\n    https://github.com/mpv-player/mpv/issues/6343\n\n    :param mixing:      The Pan filter string. Defaults to the Dave_750 preset.\n                        Honestly no recommendations here. Try them all and use what you prefer.\n    :param force:       Force processing even if there are only 2 channels.\n    \"\"\"\n\n    mixing: str | None = None\n    force: bool = False\n    refresh_metadata = True\n\n    def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n        return (track.raw_ffprobe.channels or 2) &gt; 2 or self.force\n\n    def get_filter(self, caller: Any = None) -&gt; str:\n        if not self.mixing:\n            self.mixing = Downmix.Dave_750\n        if caller:\n            debug(\"Applying downmix/pan filter...\", caller)\n        return f\"pan={self.mixing}\"\n\n    @classproperty\n    def ATSC(self) -&gt; str:\n        return \"stereo|FL&lt;1.0*FL+0.707*FC+0.707*BL+0.707*SL|FR&lt;1.0*FR+0.707*FC+0.707*BR+0.707*SR\"\n\n    @classproperty\n    def Collier(self) -&gt; str:\n        return \"stereo|FL=FC+0.30*FL+0.30*BL+0.30*SL|FR=FC+0.30*FR+0.30*BR+0.30*SR\"\n\n    @classproperty\n    def Dave_750(self) -&gt; str:\n        return \"stereo|FL=0.5*FC+0.707*FL+0.707*BL+0.707*SL+0.5*LFE|FR=0.5*FC+0.707*FR+0.707*BR+0.707*SR+0.35*LFE\"\n\n    @classproperty\n    def RFC_7845(self) -&gt; str:\n        return \"stereo|FL=0.374107*FC+0.529067*FL+0.458186*BL+0.458186*SL+0.264534*BR+0.264534*SR+0.374107*LFE|FR=0.374107*FC+0.529067*FR+0.458186*BR+0.458186*SR+0.264534*BL+0.264534*SL+0.374107*LFE\"\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.mixing","title":"<code>mixing = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.force","title":"<code>force = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.refresh_metadata","title":"<code>refresh_metadata = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.__init__","title":"<code>__init__(mixing=None, force=False)</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.can_run","title":"<code>can_run(track, preprocessors)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n    return (track.raw_ffprobe.channels or 2) &gt; 2 or self.force\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.get_filter","title":"<code>get_filter(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_filter(self, caller: Any = None) -&gt; str:\n    if not self.mixing:\n        self.mixing = Downmix.Dave_750\n    if caller:\n        debug(\"Applying downmix/pan filter...\", caller)\n    return f\"pan={self.mixing}\"\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.ATSC","title":"<code>ATSC()</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>@classproperty\ndef ATSC(self) -&gt; str:\n    return \"stereo|FL&lt;1.0*FL+0.707*FC+0.707*BL+0.707*SL|FR&lt;1.0*FR+0.707*FC+0.707*BR+0.707*SR\"\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.Collier","title":"<code>Collier()</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>@classproperty\ndef Collier(self) -&gt; str:\n    return \"stereo|FL=FC+0.30*FL+0.30*BL+0.30*SL|FR=FC+0.30*FR+0.30*BR+0.30*SR\"\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.Dave_750","title":"<code>Dave_750()</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>@classproperty\ndef Dave_750(self) -&gt; str:\n    return \"stereo|FL=0.5*FC+0.707*FL+0.707*BL+0.707*SL+0.5*LFE|FR=0.5*FC+0.707*FR+0.707*BR+0.707*SR+0.35*LFE\"\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Downmix.RFC_7845","title":"<code>RFC_7845()</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>@classproperty\ndef RFC_7845(self) -&gt; str:\n    return \"stereo|FL=0.374107*FC+0.529067*FL+0.458186*BL+0.458186*SL+0.264534*BR+0.264534*SR+0.374107*LFE|FR=0.374107*FC+0.529067*FR+0.458186*BR+0.458186*SR+0.264534*BL+0.264534*SL+0.374107*LFE\"\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm","title":"<code>Loudnorm</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>A FFMPEG normalization preprocessor according to EBU-R128 standards. It's strongly recommended to also put a <code>Resample</code> preprocessor into the chain as this filter needs to upsample to 192kHz and we don't want to encode that after.</p> <p>This will do a dynamic pass first to measure various values and then do the proper pass so it might take a while.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>float</code> <p>The integrated loudness target. Range is <code>-70.0</code> - <code>-5.0</code>. Default value is <code>-24.0</code>.</p> <code>-24.0</code> <code>lra</code> <code>float</code> <p>The loudness range target. Range is <code>1.0</code> - <code>50.0</code>. Default value is <code>7.0</code>.</p> <code>7.0</code> <code>tp</code> <code>float</code> <p>The maximum true peak. Range is <code>-9.0</code> - <code>+0.0</code>. Default value is <code>-2.0</code>.</p> <code>-2.0</code> <code>offset</code> <code>float | None</code> <p>Offset gain. Gain is applied before the true-peak limiter. Will be taken from the analysis in the first pass if None.</p> <code>None</code> Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>@dataclass\nclass Loudnorm(Preprocessor):\n    \"\"\"\n    A FFMPEG normalization preprocessor according to EBU-R128 standards.\n    It's strongly recommended to also put a `Resample` preprocessor into the chain as this filter needs to upsample to 192kHz and we don't want to encode that after.\n\n    This will do a dynamic pass first to measure various values and then do the proper pass so it might take a while.\n\n    :param i:           The integrated loudness target. Range is `-70.0` - `-5.0`. Default value is `-24.0`.\n    :param lra:         The loudness range target. Range is `1.0` - `50.0`. Default value is `7.0`.\n    :param tp:          The maximum true peak. Range is `-9.0` - `+0.0`. Default value is `-2.0`.\n    :param offset:      Offset gain. Gain is applied before the true-peak limiter.\n                        Will be taken from the analysis in the first pass if None.\n    \"\"\"\n\n    i: float = -24.0\n    lra: float = 7.0\n    tp: float = -2.0\n    offset: float | None = None\n\n    @dataclass\n    class Measurements:\n        i: float\n        lra: float\n        tp: float\n        thresh: float\n        target_offset: float\n\n    def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n        return True\n\n    def analyze(self, file: AudioFile):\n        debug(\"Analyzing file loudness...\", self)\n        ffmpeg = get_executable(\"ffmpeg\")\n        out_var = \"NUL\" if os.name == \"nt\" else \"/dev/null\"\n        args = [\n            ffmpeg,\n            \"-y\",\n            \"-hide_banner\",\n            \"-i\",\n            str(ensure_path_exists(file.file, self).resolve()),\n            \"-map\",\n            \"0:a:0\",\n            \"-filter:a\",\n            \"loudnorm=print_format=json\",\n            \"-f\",\n            \"null\",\n            out_var,\n        ]\n        out = subprocess.run(args, capture_output=True, text=True, encoding=\"utf-8\", errors=\"ignore\")\n        output = (out.stderr or \"\") + (out.stdout or \"\")\n        output = output.replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n        i_match = re.findall(r\"input_i.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n        tp_match = re.findall(r\"input_tp.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n        lra_match = re.findall(r\"input_lra.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n        thresh_match = re.findall(r\"input_thresh.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n        offset_match = re.findall(r\"target_offset.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n        if not all([i_match, tp_match, lra_match, thresh_match, offset_match]):\n            raise error(\"Could not properly measure the input file!\", self)\n\n        self.measurements = self.Measurements(\n            float(i_match[0]),\n            float(lra_match[0]),\n            float(tp_match[0]),\n            float(thresh_match[0]),\n            float(offset_match[0]),\n        )\n\n    def get_filter(self, caller: Any = None) -&gt; str | None:\n        if caller:\n            debug(\"Applying loudnorm...\", caller)\n        if not hasattr(self, \"measurements\"):\n            # Ideally shouldn't run into this lmfao\n            return \"\"\n        return (\n            f\"loudnorm=linear=true:i={self.i}:lra={self.lra}:tp={self.tp}:offset={self.offset if self.offset else self.measurements.target_offset}\"\n            f\":measured_I={self.measurements.i}:measured_tp={self.measurements.tp}:measured_LRA={self.measurements.lra}:measured_thresh={self.measurements.thresh}\"\n        )\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.i","title":"<code>i = -24.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.lra","title":"<code>lra = 7.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.tp","title":"<code>tp = -2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.offset","title":"<code>offset = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements","title":"<code>Measurements</code>  <code>dataclass</code>","text":"Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>@dataclass\nclass Measurements:\n    i: float\n    lra: float\n    tp: float\n    thresh: float\n    target_offset: float\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements.i","title":"<code>i</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements.lra","title":"<code>lra</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements.tp","title":"<code>tp</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements.thresh","title":"<code>thresh</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements.target_offset","title":"<code>target_offset</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.Measurements.__init__","title":"<code>__init__(i, lra, tp, thresh, target_offset)</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.__init__","title":"<code>__init__(i=-24.0, lra=7.0, tp=-2.0, offset=None)</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.can_run","title":"<code>can_run(track, preprocessors)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n    return True\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.analyze","title":"<code>analyze(file)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def analyze(self, file: AudioFile):\n    debug(\"Analyzing file loudness...\", self)\n    ffmpeg = get_executable(\"ffmpeg\")\n    out_var = \"NUL\" if os.name == \"nt\" else \"/dev/null\"\n    args = [\n        ffmpeg,\n        \"-y\",\n        \"-hide_banner\",\n        \"-i\",\n        str(ensure_path_exists(file.file, self).resolve()),\n        \"-map\",\n        \"0:a:0\",\n        \"-filter:a\",\n        \"loudnorm=print_format=json\",\n        \"-f\",\n        \"null\",\n        out_var,\n    ]\n    out = subprocess.run(args, capture_output=True, text=True, encoding=\"utf-8\", errors=\"ignore\")\n    output = (out.stderr or \"\") + (out.stdout or \"\")\n    output = output.replace(\"\\n\", \"\").replace(\"\\r\", \"\")\n    i_match = re.findall(r\"input_i.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n    tp_match = re.findall(r\"input_tp.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n    lra_match = re.findall(r\"input_lra.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n    thresh_match = re.findall(r\"input_thresh.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n    offset_match = re.findall(r\"target_offset.+?(-?\\d+(?:\\.\\d+)?)\", output, re.I)\n    if not all([i_match, tp_match, lra_match, thresh_match, offset_match]):\n        raise error(\"Could not properly measure the input file!\", self)\n\n    self.measurements = self.Measurements(\n        float(i_match[0]),\n        float(lra_match[0]),\n        float(tp_match[0]),\n        float(thresh_match[0]),\n        float(offset_match[0]),\n    )\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.Loudnorm.get_filter","title":"<code>get_filter(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_filter(self, caller: Any = None) -&gt; str | None:\n    if caller:\n        debug(\"Applying loudnorm...\", caller)\n    if not hasattr(self, \"measurements\"):\n        # Ideally shouldn't run into this lmfao\n        return \"\"\n    return (\n        f\"loudnorm=linear=true:i={self.i}:lra={self.lra}:tp={self.tp}:offset={self.offset if self.offset else self.measurements.target_offset}\"\n        f\":measured_I={self.measurements.i}:measured_tp={self.measurements.tp}:measured_LRA={self.measurements.lra}:measured_thresh={self.measurements.thresh}\"\n    )\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor","title":"<code>CustomPreprocessor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Preprocessor</code></p> <p>A custom preprocessor class to pass arbitrary filters or arguments to ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>filt</code> <code>str | None</code> <p>Audio filter to append to the filterchain. Don't include any flags or whatever. It should look like this <code>afade=t=in:ss=0:d=15</code></p> <code>None</code> <code>args</code> <code>str | Sequence[str] | None</code> <p>Other args you may want to pass to ffmpeg.</p> <code>None</code> Source code in <code>           muxtools/audio/preprocess.py         </code> <pre><code>@dataclass\nclass CustomPreprocessor(Preprocessor):\n    \"\"\"\n    A custom preprocessor class to pass arbitrary filters or arguments to ffmpeg.\n\n    :param filt:        Audio filter to append to the filterchain. Don't include any flags or whatever.\n                        It should look like this `afade=t=in:ss=0:d=15`\n    :param args:        Other args you may want to pass to ffmpeg.\n    \"\"\"\n\n    filt: str | None = None\n    args: str | Sequence[str] | None = None\n\n    def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n        return True\n\n    def get_filter(self, caller: Any = None) -&gt; str | None:\n        return self.filt\n\n    def get_args(self, caller: Any = None) -&gt; Sequence[str]:\n        if isinstance(self.args, str) and not isinstance(self.args, Sequence):\n            self.args = [self.args]\n        return list(self.args) if self.args else []\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor.filt","title":"<code>filt = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor.args","title":"<code>args = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor.__init__","title":"<code>__init__(filt=None, args=None)</code>","text":""},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor.can_run","title":"<code>can_run(track, preprocessors)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def can_run(self, track: TrackInfo, preprocessors: Sequence[Any]) -&gt; bool:\n    return True\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor.get_filter","title":"<code>get_filter(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_filter(self, caller: Any = None) -&gt; str | None:\n    return self.filt\n</code></pre>"},{"location":"muxtools/audio/preprocess/#muxtools.audio.preprocess.CustomPreprocessor.get_args","title":"<code>get_args(caller=None)</code>","text":"Source code in <code>         muxtools/audio/preprocess.py       </code> <pre><code>def get_args(self, caller: Any = None) -&gt; Sequence[str]:\n    if isinstance(self.args, str) and not isinstance(self.args, Sequence):\n        self.args = [self.args]\n    return list(self.args) if self.args else []\n</code></pre>"},{"location":"muxtools/audio/tools/","title":"tools","text":""},{"location":"muxtools/audio/tools/#muxtools.audio.tools.AutoEncoder","title":"<code>AutoEncoder</code>","text":"<p>               Bases: <code>Encoder</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class AutoEncoder(Encoder):\n    def encode_audio(self, input: AudioFile, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        # Dummy func\n        ...\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.AutoEncoder.encode_audio","title":"<code>encode_audio(input, quiet=True, **kwargs)</code>","text":"Source code in <code>         muxtools/audio/tools.py       </code> <pre><code>def encode_audio(self, input: AudioFile, quiet: bool = True, **kwargs) -&gt; AudioFile:\n    # Dummy func\n    ...\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.AutoTrimmer","title":"<code>AutoTrimmer</code>","text":"<p>               Bases: <code>Trimmer</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class AutoTrimmer(Trimmer):\n    def trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n        # Dummy func\n        ...\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.AutoTrimmer.trim_audio","title":"<code>trim_audio(input, quiet=True)</code>","text":"Source code in <code>         muxtools/audio/tools.py       </code> <pre><code>def trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n    # Dummy func\n    ...\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Encoder","title":"<code>Encoder</code>","text":"<p>               Bases: <code>CLIKwargs</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class Encoder(CLIKwargs):\n    lossless = False\n\n    @abstractmethod\n    def encode_audio(self, input: AudioFile, quiet: bool = True, **kwargs) -&gt; AudioFile:\n        pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Encoder.lossless","title":"<code>lossless = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Encoder.encode_audio","title":"<code>encode_audio(input, quiet=True, **kwargs)</code>  <code>abstractmethod</code>","text":"Source code in <code>         muxtools/audio/tools.py       </code> <pre><code>@abstractmethod\ndef encode_audio(self, input: AudioFile, quiet: bool = True, **kwargs) -&gt; AudioFile:\n    pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Extractor","title":"<code>Extractor</code>","text":"<p>               Bases: <code>CLIKwargs</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class Extractor(CLIKwargs):\n    _no_print = False\n\n    @abstractmethod\n    def extract_audio(self, input: PathLike, quiet: bool = True) -&gt; AudioFile:\n        pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Extractor.extract_audio","title":"<code>extract_audio(input, quiet=True)</code>  <code>abstractmethod</code>","text":"Source code in <code>         muxtools/audio/tools.py       </code> <pre><code>@abstractmethod\ndef extract_audio(self, input: PathLike, quiet: bool = True) -&gt; AudioFile:\n    pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.HasExtractor","title":"<code>HasExtractor</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class HasExtractor(ABC):\n    pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.HasTrimmer","title":"<code>HasTrimmer</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class HasTrimmer(ABC):\n    pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.LosslessEncoder","title":"<code>LosslessEncoder</code>","text":"<p>               Bases: <code>Encoder</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class LosslessEncoder(Encoder):\n    lossless = True\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.LosslessEncoder.lossless","title":"<code>lossless = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Trimmer","title":"<code>Trimmer</code>","text":"<p>               Bases: <code>CLIKwargs</code></p> Source code in <code>           muxtools/audio/tools.py         </code> <pre><code>class Trimmer(CLIKwargs):\n    @abstractmethod\n    def trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n        pass\n</code></pre>"},{"location":"muxtools/audio/tools/#muxtools.audio.tools.Trimmer.trim_audio","title":"<code>trim_audio(input, quiet=True)</code>  <code>abstractmethod</code>","text":"Source code in <code>         muxtools/audio/tools.py       </code> <pre><code>@abstractmethod\ndef trim_audio(self, input: AudioFile, quiet: bool = True) -&gt; AudioFile:\n    pass\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/","title":"bitstream-filters","text":""},{"location":"muxtools/helpers/bitstream_filters/#enums","title":"Enums","text":""},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_generic.BSF_ChromaLocation","title":"<code>BSF_ChromaLocation</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Collection of known chroma sample location values.</p> <p>For more documentation on these, check out the H265 Specification (Figure E.1) or JET Documentation.</p> Source code in <code>           muxtools/helpers/bsf/bsf_generic.py         </code> <pre><code>class BSF_ChromaLocation(IntEnum):\n    \"\"\"\n    Collection of known chroma sample location values.\n\n    For more documentation on these, check out the [H265 Specification](https://www.itu.int/rec/t-rec-h.265) (Figure E.1) or [JET Documentation](https://jaded-encoding-thaumaturgy.github.io/vs-jetpack/api/vstools/enums/generic/#vstools.enums.generic.ChromaLocation).\n    \"\"\"\n\n    LEFT = 0\n    CENTER = 1\n    TOP_LEFT = 2\n    TOP = 3\n    BOTTOM_LEFT = 4\n    BOTTOM = 5\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_generic.BSF_Matrix","title":"<code>BSF_Matrix</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Collection of known bitstream matrix values.</p> <p>For more documentation on these, check out the H265 Specification (Table E.5) or JET Documentation.</p> Source code in <code>           muxtools/helpers/bsf/bsf_generic.py         </code> <pre><code>class BSF_Matrix(IntEnum):\n    \"\"\"\n    Collection of known bitstream matrix values.\n\n    For more documentation on these, check out the [H265 Specification](https://www.itu.int/rec/t-rec-h.265) (Table E.5) or [JET Documentation](https://jaded-encoding-thaumaturgy.github.io/vs-jetpack/api/vstools/enums/color/#vstools.enums.color.Matrix).\n    \"\"\"\n\n    RGB = 0\n    GBR = RGB\n    IDENTITY = RGB\n    BT709 = 1\n    UNKNOWN = 2\n    FCC = 3\n    BT470BG = 5\n    BT601_625 = BT470BG\n    SMPTE170M = 6\n    BT601_525 = SMPTE170M\n    SMPTE240M = 7\n    YCGCO = 8\n    BT2020NCL = 9\n    BT2020CL = 10\n    CHROMANCL = 12\n    CHROMACL = 13\n    ICTCP = 14\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_generic.BSF_Transfer","title":"<code>BSF_Transfer</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Collection of known bitstream transfer values.</p> <p>For more documentation on these, check out the H265 Specification (Table E.4) or JET Documentation.</p> Source code in <code>           muxtools/helpers/bsf/bsf_generic.py         </code> <pre><code>class BSF_Transfer(IntEnum):\n    \"\"\"\n    Collection of known bitstream transfer values.\n\n    For more documentation on these, check out the [H265 Specification](https://www.itu.int/rec/t-rec-h.265) (Table E.4) or [JET Documentation](https://jaded-encoding-thaumaturgy.github.io/vs-jetpack/api/vstools/enums/color/#vstools.enums.color.Transfer).\n    \"\"\"\n\n    BT709 = 1\n    BT1886 = BT709\n    UNKNOWN = 2\n    BT470M = 4\n    BT470BG = 5\n    SMPTE170M = 6\n    BT601 = SMPTE170M\n    SMPTE240M = 7\n    LINEAR = 8\n    LOG100 = 9\n    LOG316 = 10\n    XVYCC = 11\n    SRGB = 13\n    BT2020_10 = 14\n    BT2020_12 = 15\n    ST2084 = 16\n    PQ = ST2084\n    STD_B67 = 18\n    HLG = STD_B67\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_generic.BSF_Primaries","title":"<code>BSF_Primaries</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Collection of known bitstream color primaries values.</p> <p>For more documentation on these, check out the H265 Specification (Table E.3) or JET Documentation.</p> Source code in <code>           muxtools/helpers/bsf/bsf_generic.py         </code> <pre><code>class BSF_Primaries(IntEnum):\n    \"\"\"\n    Collection of known bitstream color primaries values.\n\n    For more documentation on these, check out the [H265 Specification](https://www.itu.int/rec/t-rec-h.265) (Table E.3) or [JET Documentation](https://jaded-encoding-thaumaturgy.github.io/vs-jetpack/api/vstools/enums/color/#vstools.enums.color.Primaries).\n    \"\"\"\n\n    BT709 = 1\n    UNKNOWN = 2\n    BT470M = 4\n    BT470BG = 5\n    BT601_625 = BT470BG\n    SMPTE170M = 6\n    BT601_525 = SMPTE170M\n    SMPTE240M = 7\n    FILM = 8\n    BT2020 = 9\n    ST428 = 10\n    XYZ = ST428\n    CIE1931 = ST428\n    ST431_2 = 11\n    DCI_P3 = ST431_2\n    ST432_1 = 12\n    DISPLAY_P3 = ST432_1\n    JEDEC_P22 = 22\n    EBU3213 = JEDEC_P22\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_generic.BSF_Format","title":"<code>BSF_Format</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Collection of known bitstream video_format values.</p> <p>For more documentation on these, check out the H265 Specification (Table E.2)</p> Source code in <code>           muxtools/helpers/bsf/bsf_generic.py         </code> <pre><code>class BSF_Format(IntEnum):\n    \"\"\"\n    Collection of known bitstream video_format values.\n\n    For more documentation on these, check out the [H265 Specification](https://www.itu.int/rec/t-rec-h.265) (Table E.2)\n    \"\"\"\n\n    COMPONENT = 0\n    PAL = 1\n    NTSC = 2\n    SECAM = 3\n    MAC = 4\n    UNSPECIFIED = 5\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#functions","title":"Functions","text":""},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_mpeg2.apply_mpeg2_bsf","title":"<code>apply_mpeg2_bsf(fileIn, dar=None, fps=None, format=None, primaries=None, transfer=None, matrix=None, quiet=True)</code>","text":"<p>A helper for the FFMpeg mpeg2_metadata bitstream filter.</p> <p><code>None</code> values will do nothing to the respective metadata flags.</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike</code> <p>The file to modify</p> required <code>dar</code> <code>MPEG2_DAR | str | None</code> <p>Set the display aspect ratio in the stream</p> <code>None</code> <code>fps</code> <code>MPEG2_FPS | str | None</code> <p>Set the frame rate in the stream</p> <code>None</code> <code>format</code> <code>BSF_Format | int | None</code> <p>Set the video format in the stream</p> <code>None</code> <code>primaries</code> <code>BSF_Primaries | int | None</code> <p>Set the color primaries in the stream</p> <code>None</code> <code>transfer</code> <code>BSF_Transfer | int | None</code> <p>Set the transfer characteristics in the stream</p> <code>None</code> <code>matrix</code> <code>BSF_Matrix | int | None</code> <p>Set the matrix coefficients in the stream</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppresses the output of ffmpeg</p> <code>True</code> Source code in <code>         muxtools/helpers/bsf/bsf_mpeg2.py       </code> <pre><code>def apply_mpeg2_bsf(\n    fileIn: PathLike,\n    dar: MPEG2_DAR | str | None = None,\n    fps: MPEG2_FPS | str | None = None,\n    format: BSF_Format | int | None = None,\n    primaries: BSF_Primaries | int | None = None,\n    transfer: BSF_Transfer | int | None = None,\n    matrix: BSF_Matrix | int | None = None,\n    quiet: bool = True,\n):\n    \"\"\"\n    A helper for the FFMpeg [mpeg2_metadata](https://ffmpeg.org/ffmpeg-bitstream-filters.html#mpeg2_005fmetadata) bitstream filter.\n\n    `None` values will do nothing to the respective metadata flags.\n\n    :param fileIn:                      The file to modify\n    :param dar:                         Set the display aspect ratio in the stream\n    :param fps:                         Set the frame rate in the stream\n    :param format:                      Set the video format in the stream\n    :param primaries:                   Set the color primaries in the stream\n    :param transfer:                    Set the transfer characteristics in the stream\n    :param matrix:                      Set the matrix coefficients in the stream\n    :param quiet:                       Suppresses the output of ffmpeg\n    \"\"\"\n    f = ensure_path_exists(fileIn, apply_mpeg2_bsf)\n    filter_options = list[str]()\n\n    if dar is not None:\n        filter_options.append(f\"display_aspect_ratio={str(dar.value) if isinstance(dar, MPEG2_DAR) else str(dar)}\")\n\n    if fps is not None:\n        filter_options.append(f\"frame_rate={str(fps.value) if isinstance(fps, MPEG2_FPS) else str(fps)}\")\n\n    if format is not None and (format := BSF_Format(format)) is not None:\n        filter_options.append(f\"video_format={str(format.value)}\")\n\n    if primaries is not None and (primaries := BSF_Primaries(primaries)) is not None:\n        if primaries.value not in range(1, 8):\n            raise error(f\"'{primaries}' is not a valid primaries value for MPEG2 streams!\")\n        filter_options.append(f\"colour_primaries={str(primaries.value)}\")\n\n    if transfer is not None and (transfer := BSF_Transfer(transfer)) is not None:\n        if transfer.value not in range(1, 9):\n            raise error(f\"'{transfer}' is not a valid transfer value for MPEG2 streams!\")\n        filter_options.append(f\"transfer_characteristics={str(transfer.value)}\")\n\n    if matrix is not None and (matrix := BSF_Matrix(matrix)) is not None:\n        if matrix.value not in range(1, 8):\n            raise error(f\"'{matrix}' is not a valid matrix value for MPEG2 streams!\")\n        filter_options.append(f\"matrix_coefficients={str(matrix.value)}\")\n\n    if not filter_options:\n        raise error(\"No changes to be made!\", apply_mpeg2_bsf)\n\n    _apply_bsf(f, \"mpeg2_metadata\", filter_options, apply_mpeg2_bsf, quiet)\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_hevc_avc.apply_avc_bsf","title":"<code>apply_avc_bsf(fileIn, sar=None, cloc_type=None, full_range=None, format=None, primaries=None, transfer=None, matrix=None, crop=None, quiet=True, **kwargs)</code>","text":"<p>A helper for the FFMpeg h264_metadata bitstream filter.</p> <p><code>None</code> values will do nothing to the respective metadata flags.</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike</code> <p>The file to modify</p> required <code>sar</code> <code>int | None</code> <p>Set the sample aspect ratio in the stream</p> <code>None</code> <code>cloc_type</code> <code>BSF_ChromaLocation | int | None</code> <p>Set the chroma sample location in the stream</p> <code>None</code> <code>full_range</code> <code>bool | int | None</code> <p>Set the full range flag in the stream</p> <code>None</code> <code>format</code> <code>BSF_Format | int | None</code> <p>Set the video format in the stream</p> <code>None</code> <code>primaries</code> <code>BSF_Primaries | int | None</code> <p>Set the color primaries in the stream</p> <code>None</code> <code>transfer</code> <code>BSF_Transfer | int | None</code> <p>Set the transfer characteristics in the stream</p> <code>None</code> <code>matrix</code> <code>BSF_Matrix | int | None</code> <p>Set the matrix coefficients in the stream</p> <code>None</code> <code>crop</code> <code>int | tuple[int, int] | tuple[int, int, int, int] | None</code> <p>Set the crop values in the stream</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppresses the output of ffmpeg</p> <code>True</code> <code>kwargs</code> <code>bool | str</code> <p>Additional options for the filter.  For other available options, check the hyperlink to the filter above.</p> <code>{}</code> Source code in <code>         muxtools/helpers/bsf/bsf_hevc_avc.py       </code> <pre><code>def apply_avc_bsf(\n    fileIn: PathLike,\n    sar: int | None = None,\n    cloc_type: BSF_ChromaLocation | int | None = None,\n    full_range: bool | int | None = None,\n    format: BSF_Format | int | None = None,\n    primaries: BSF_Primaries | int | None = None,\n    transfer: BSF_Transfer | int | None = None,\n    matrix: BSF_Matrix | int | None = None,\n    crop: int | tuple[int, int] | tuple[int, int, int, int] | None = None,\n    quiet: bool = True,\n    **kwargs: bool | str,\n):\n    \"\"\"\n    A helper for the FFMpeg [h264_metadata](https://ffmpeg.org/ffmpeg-bitstream-filters.html#h264_005fmetadata) bitstream filter.\n\n    `None` values will do nothing to the respective metadata flags.\n\n    :param fileIn:                      The file to modify\n    :param sar:                         Set the sample aspect ratio in the stream\n    :param cloc_type:                   Set the chroma sample location in the stream\n    :param full_range:                  Set the full range flag in the stream\n    :param format:                      Set the video format in the stream\n    :param primaries:                   Set the color primaries in the stream\n    :param transfer:                    Set the transfer characteristics in the stream\n    :param matrix:                      Set the matrix coefficients in the stream\n    :param crop:                        Set the crop values in the stream\n    :param quiet:                       Suppresses the output of ffmpeg\n    :param kwargs:                      Additional options for the filter.\\n\n                                        For other available options, check the hyperlink to the filter above.\n    \"\"\"\n\n    _apply_avc_hevc_bsf(\n        fileIn,\n        \"h264_metadata\",\n        sar=sar,\n        cloc_type=cloc_type,\n        full_range=full_range,\n        format=format,\n        primaries=primaries,\n        transfer=transfer,\n        matrix=matrix,\n        crop=crop,\n        quiet=quiet,\n        caller=apply_avc_bsf,\n        **kwargs,\n    )\n</code></pre>"},{"location":"muxtools/helpers/bitstream_filters/#muxtools.helpers.bsf.bsf_hevc_avc.apply_hevc_bsf","title":"<code>apply_hevc_bsf(fileIn, sar=None, cloc_type=None, full_range=None, format=None, primaries=None, transfer=None, matrix=None, crop=None, quiet=True, **kwargs)</code>","text":"<p>A helper for the FFMpeg hevc_metadata bitstream filter.</p> <p><code>None</code> values will do nothing to the respective metadata flags.</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike</code> <p>The file to modify</p> required <code>sar</code> <code>int | None</code> <p>Set the sample aspect ratio in the stream</p> <code>None</code> <code>cloc_type</code> <code>BSF_ChromaLocation | int | None</code> <p>Set the chroma sample location in the stream</p> <code>None</code> <code>full_range</code> <code>bool | int | None</code> <p>Set the full range flag in the stream</p> <code>None</code> <code>format</code> <code>BSF_Format | int | None</code> <p>Set the video format in the stream</p> <code>None</code> <code>primaries</code> <code>BSF_Primaries | int | None</code> <p>Set the color primaries in the stream</p> <code>None</code> <code>transfer</code> <code>BSF_Transfer | int | None</code> <p>Set the transfer characteristics in the stream</p> <code>None</code> <code>matrix</code> <code>BSF_Matrix | int | None</code> <p>Set the matrix coefficients in the stream</p> <code>None</code> <code>crop</code> <code>int | tuple[int, int] | tuple[int, int, int, int] | None</code> <p>Set the crop values in the stream</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppresses the output of ffmpeg</p> <code>True</code> <code>kwargs</code> <code>bool | str</code> <p>Additional options for the filter.  For available options, check the hyperlink to the filter above.</p> <code>{}</code> Source code in <code>         muxtools/helpers/bsf/bsf_hevc_avc.py       </code> <pre><code>def apply_hevc_bsf(\n    fileIn: PathLike,\n    sar: int | None = None,\n    cloc_type: BSF_ChromaLocation | int | None = None,\n    full_range: bool | int | None = None,\n    format: BSF_Format | int | None = None,\n    primaries: BSF_Primaries | int | None = None,\n    transfer: BSF_Transfer | int | None = None,\n    matrix: BSF_Matrix | int | None = None,\n    crop: int | tuple[int, int] | tuple[int, int, int, int] | None = None,\n    quiet: bool = True,\n    **kwargs: bool | str,\n):\n    \"\"\"\n    A helper for the FFMpeg [hevc_metadata](https://ffmpeg.org/ffmpeg-bitstream-filters.html#hevc_005fmetadata) bitstream filter.\n\n    `None` values will do nothing to the respective metadata flags.\n\n    :param fileIn:                      The file to modify\n    :param sar:                         Set the sample aspect ratio in the stream\n    :param cloc_type:                   Set the chroma sample location in the stream\n    :param full_range:                  Set the full range flag in the stream\n    :param format:                      Set the video format in the stream\n    :param primaries:                   Set the color primaries in the stream\n    :param transfer:                    Set the transfer characteristics in the stream\n    :param matrix:                      Set the matrix coefficients in the stream\n    :param crop:                        Set the crop values in the stream\n    :param quiet:                       Suppresses the output of ffmpeg\n    :param kwargs:                      Additional options for the filter.\\n\n                                        For available options, check the hyperlink to the filter above.\n    \"\"\"\n\n    _apply_avc_hevc_bsf(\n        fileIn,\n        \"hevc_metadata\",\n        sar=sar,\n        cloc_type=cloc_type,\n        full_range=full_range,\n        format=format,\n        primaries=primaries,\n        transfer=transfer,\n        matrix=matrix,\n        crop=crop,\n        quiet=quiet,\n        caller=apply_hevc_bsf,\n        **kwargs,\n    )\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/","title":"mkvpropedit","text":""},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit","title":"<code>MKVPropEdit</code>","text":"Source code in <code>           muxtools/helpers/propedit.py         </code> <pre><code>class MKVPropEdit:\n    _main_args: list[str]\n    _track_args: list[str]\n    _fileIn: Path\n    _parsed: ParsedFile\n    _has_info: bool = False\n    _video_index: int = 1\n    _audio_index: int = 1\n    _subtitle_index: int = 1\n    _executable: Path\n\n    def __init__(\n        self, fileIn: PathLike, track_statistics: bool | None = None, chapters: PathLike | Chapters = None, tags: dict[str, str] | None = None\n    ):\n        \"\"\"\n        Creates the mkvpropedit helper including any modifications possible on the global scope.\n\n        :param fileIn:              File to edit.\n        :param track_statistics:    Whether to update or remove track statistics like bitrate.\\n\n                                    `None` will do nothing while `True` will add/replace them and `False` will remove them.\n\n        :param chapters:            Chapters to add to the file. This can be any txt or xml file in the same formats that mkvmerge takes.\\n\n                                    It can also take a muxtools Chapters object and create a txt from that.\\n\n                                    An empty string will remove any chapters. `None` will do nothing.\n\n        :param tags:                Global tags to add/replace. An empty string as value will remove a tag.\\n\n                                    An empty dict will remove any global tags. `None` will do nothing.\n        \"\"\"\n        self._executable = ensure_path(get_executable(\"mkvpropedit\"), self)\n        self._fileIn = ensure_path_exists(fileIn, self)\n        self._parsed = ParsedFile.from_file(self._fileIn, self)\n        self._main_args = []\n        self._track_args = []\n\n        if track_statistics is not None:\n            self._main_args.append(\"--add-track-statistics-tags\" if track_statistics else \"--delete-track-statistics-tags\")\n\n        if chapters is not None:\n            if isinstance(chapters, str) and not chapters:\n                self._main_args.extend([\"-c\", \"\"])\n            else:\n                if isinstance(chapters, Chapters):\n                    chapters = chapters.to_file()\n                chapters = ensure_path_exists(chapters, self)\n                if chapters.suffix.lower() not in [\".txt\", \".xml\"]:\n                    raise error(\"Chapters have to be a txt or xml file.\", self)\n                self._main_args.extend([\"-c\", str(chapters)])\n        if tags is not None:\n            out = \"\"\n            if len(tags) &gt; 0:\n                if self._parsed.container_info.tags:\n                    tags = dict(**self._parsed.container_info.tags) | tags\n                out = make_output(fileIn, \"xml\", \"global_tags\", temp=True)\n                create_tags_xml(out, tags)\n            self._main_args.extend([\"-t\", f\"global:{str(out)}\"])\n\n    def _edit_args(self, name: str, value: bool | str | None) -&gt; list[str]:\n        if value is None:\n            return []\n\n        if isinstance(value, bool):\n            return [\"-s\", f\"{name}={str(int(value))}\"]\n        else:\n            if not value:\n                return [\"-d\", name]\n            else:\n                return [\"-s\", f\"{name}={value}\"]\n\n    def _edit_track(\n        self,\n        type: str,\n        index: int,\n        title: str | None,\n        language: str | None,\n        default: bool | None,\n        forced: bool | None,\n        tags: dict[str, str] | None,\n        **kwargs: bool | str | None,\n    ):\n        selector = type if index &lt;= 0 else f\"track:{type}{index}\"\n        if tags is not None and type != \"info\":\n            out = \"\"\n            if len(tags) &gt; 0:\n                match type:\n                    case \"v\":\n                        tracktype = TrackType.VIDEO\n                    case \"a\":\n                        tracktype = TrackType.AUDIO\n                    case _:\n                        tracktype = TrackType.SUB\n                track = self._parsed.find_tracks(type=tracktype, relative_id=index - 1, error_if_empty=True, caller=self)[0]\n                if track.other_tags:\n                    tags = dict(**track.other_tags) | tags\n                out = make_output(self._fileIn, \"xml\", f\"{type}{index}_tags\", temp=True)\n                create_tags_xml(out, tags)\n            self._main_args.extend([\"-t\", f\"{selector}:{str(out)}\"])\n        if not any([not_none for not_none in (title, language, default, forced) if not_none is not None]) and not kwargs:\n            return\n\n        args = [\"-e\", selector]\n        to_append = [\n            *self._edit_args(\"title\" if type == \"info\" else \"name\", title),\n            *self._edit_args(\"language\", language),\n            *self._edit_args(\"flag-default\", default),\n            *self._edit_args(\"flag-forced\", forced),\n        ]\n        args.extend(to_append)\n\n        for k, v in kwargs.items():\n            if not k.endswith(\"_\"):\n                k = k.replace(\"_\", \"-\")\n            else:\n                k = k[:-1]\n            if e_args := self._edit_args(k, v):\n                args.extend(e_args)\n\n        self._track_args.extend(args)\n\n    def info(\n        self,\n        title: str | None = None,\n        date: str | None = None,\n        muxing_application: str | None = None,\n        writing_application: str | None = None,\n        **kwargs: bool | str | None,\n    ):\n        \"\"\"\n        Edit properties for the main info section.\n\n        `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n        Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n        :param title:               The title for the whole movie\n        :param date:                The date the file was created\n        :param muxing_application:  The name of the application or library used for multiplexing the file\n        :param writing_application: The name of the application or library used for writing the file\n        :param kwargs:              Any other properties to set or remove.\\n\n                                    Check out the 'Segment information' section in `mkvpropedit -l` to see what's available.\n        \"\"\"\n        if self._has_info:\n            raise error(\"Info tagging was already added!\", self)\n        self._edit_track(\"info\", -1, title, date=date, muxing_application=muxing_application, writing_application=writing_application, **kwargs)\n        self._has_info = True\n        return self\n\n    def video_track(\n        self,\n        name: str | None = None,\n        language: str | None = None,\n        default: bool | None = None,\n        forced: bool | None = None,\n        tags: dict[str, str] | None = None,\n        crop: int | tuple[int, int] | tuple[int, int, int, int] | None = None,\n        **kwargs: bool | str | None,\n    ) -&gt; Self:\n        \"\"\"\n        Edit properties for the next video track in the file.\n\n        `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n        Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n        :param name:                A human-readable track name\n        :param language:            Specifies the language of the track\n        :param default:             Specifies whether a track should be eligible for automatic selection\n        :param forced:              Specifies whether a track should be played with tracks of a different type but same language\n\n        :param tags:                Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag\\n\n                                    An empty dict will remove any custom tags. `None` will do nothing.\n\n        :param crop:                Container based cropping with (horizontal, vertical) or (left, top, right, bottom).\\n\n                                    Will crop the same on all sides if passed a single integer.\n\n        :param kwargs:              Any other properties to set or remove.\\n\n                                    Check out the 'Track headers' section in `mkvpropedit -l` to see what's available.\n        \"\"\"\n        if crop is not None:\n            if isinstance(crop, int):\n                crop = tuple([crop] * 4)\n            elif len(crop) == 2:\n                crop = crop * 2\n            kwargs.update(pixel_crop_left=str(crop[0]), pixel_crop_top=str(crop[1]), pixel_crop_right=str(crop[2]), pixel_crop_bottom=str(crop[3]))\n        self._edit_track(\"v\", self._video_index, name, language, default, forced, tags, **kwargs)\n        self._video_index += 1\n        return self\n\n    def audio_track(\n        self,\n        name: str | None = None,\n        language: str | None = None,\n        default: bool | None = None,\n        forced: bool | None = None,\n        tags: dict[str, str] | None = None,\n        **kwargs: bool | str | None,\n    ) -&gt; Self:\n        \"\"\"\n        Edit properties for the next audio track in the file.\n\n        `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n        Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n        :param name:                A human-readable track name\n        :param language:            Specifies the language of the track\n        :param default:             Specifies whether a track should be eligible for automatic selection\n        :param forced:              Specifies whether a track should be played with tracks of a different type but same language\n\n        :param tags:                Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag.\\n\n                                    An empty dict will remove any custom tags. `None` will do nothing.\n\n        :param kwargs:              Any other properties to set or remove.\\n\n                                    Check out the 'Track headers' section in `mkvpropedit -l` to see what's available.\n        \"\"\"\n        self._edit_track(\"a\", self._audio_index, name, language, default, forced, tags, **kwargs)\n        self._audio_index += 1\n        return self\n\n    def sub_track(\n        self,\n        name: str | None = None,\n        language: str | None = None,\n        default: bool | None = None,\n        forced: bool | None = None,\n        tags: dict[str, str] | None = None,\n        **kwargs: bool | str | None,\n    ) -&gt; Self:\n        \"\"\"\n        Edit properties for the next subtitle track in the file.\n\n        `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n        Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n        :param name:                A human-readable track name\n        :param language:            Specifies the language of the track\n        :param default:             Specifies whether a track should be eligible for automatic selection\n        :param forced:              Specifies whether a track should be played with tracks of a different type but same language\n\n        :param tags:                Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag.\\n\n                                    An empty dict will remove any custom tags. `None` will do nothing.\n\n        :param kwargs:              Any other properties to set or remove.\\n\n                                    Check out the 'Track headers' section in `mkvpropedit -l` to see what's available.\n        \"\"\"\n        self._edit_track(\"s\", self._subtitle_index, name, language, default, forced, tags, **kwargs)\n        self._subtitle_index += 1\n        return self\n\n    def run(self, quiet: bool = True, error_on_failure: bool = True) -&gt; bool:\n        \"\"\"\n        Run the mkvpropedit process.\n\n        :param quiet:               Suppresses the output.\\n\n                                    The stdout will still be printed on failure regardless of this setting.\n\n        :param error_on_failure:    Raise an exception on failure.\\n\n                                    Otherwise this function will return a bool indicating the success.\n        \"\"\"\n        if not self._main_args and not self._track_args:\n            raise error(\"No changes made to the file!\", self)\n        args = [str(self._executable), str(self._fileIn)] + self._main_args + self._track_args\n        code = run_commandline(args, quiet, mkvmerge=True)\n        clean_temp_files()\n        if code &gt; 1 and error_on_failure:\n            raise error(f\"Failed to edit properties for '{self._fileIn.name}'!\")\n\n        return code &lt; 2\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit.__init__","title":"<code>__init__(fileIn, track_statistics=None, chapters=None, tags=None)</code>","text":"<p>Creates the mkvpropedit helper including any modifications possible on the global scope.</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike</code> <p>File to edit.</p> required <code>track_statistics</code> <code>bool | None</code> <p>Whether to update or remove track statistics like bitrate.  <code>None</code> will do nothing while <code>True</code> will add/replace them and <code>False</code> will remove them.</p> <code>None</code> <code>chapters</code> <code>PathLike | Chapters</code> <p>Chapters to add to the file. This can be any txt or xml file in the same formats that mkvmerge takes.  It can also take a muxtools Chapters object and create a txt from that.  An empty string will remove any chapters. <code>None</code> will do nothing.</p> <code>None</code> <code>tags</code> <code>dict[str, str] | None</code> <p>Global tags to add/replace. An empty string as value will remove a tag.  An empty dict will remove any global tags. <code>None</code> will do nothing.</p> <code>None</code> Source code in <code>         muxtools/helpers/propedit.py       </code> <pre><code>def __init__(\n    self, fileIn: PathLike, track_statistics: bool | None = None, chapters: PathLike | Chapters = None, tags: dict[str, str] | None = None\n):\n    \"\"\"\n    Creates the mkvpropedit helper including any modifications possible on the global scope.\n\n    :param fileIn:              File to edit.\n    :param track_statistics:    Whether to update or remove track statistics like bitrate.\\n\n                                `None` will do nothing while `True` will add/replace them and `False` will remove them.\n\n    :param chapters:            Chapters to add to the file. This can be any txt or xml file in the same formats that mkvmerge takes.\\n\n                                It can also take a muxtools Chapters object and create a txt from that.\\n\n                                An empty string will remove any chapters. `None` will do nothing.\n\n    :param tags:                Global tags to add/replace. An empty string as value will remove a tag.\\n\n                                An empty dict will remove any global tags. `None` will do nothing.\n    \"\"\"\n    self._executable = ensure_path(get_executable(\"mkvpropedit\"), self)\n    self._fileIn = ensure_path_exists(fileIn, self)\n    self._parsed = ParsedFile.from_file(self._fileIn, self)\n    self._main_args = []\n    self._track_args = []\n\n    if track_statistics is not None:\n        self._main_args.append(\"--add-track-statistics-tags\" if track_statistics else \"--delete-track-statistics-tags\")\n\n    if chapters is not None:\n        if isinstance(chapters, str) and not chapters:\n            self._main_args.extend([\"-c\", \"\"])\n        else:\n            if isinstance(chapters, Chapters):\n                chapters = chapters.to_file()\n            chapters = ensure_path_exists(chapters, self)\n            if chapters.suffix.lower() not in [\".txt\", \".xml\"]:\n                raise error(\"Chapters have to be a txt or xml file.\", self)\n            self._main_args.extend([\"-c\", str(chapters)])\n    if tags is not None:\n        out = \"\"\n        if len(tags) &gt; 0:\n            if self._parsed.container_info.tags:\n                tags = dict(**self._parsed.container_info.tags) | tags\n            out = make_output(fileIn, \"xml\", \"global_tags\", temp=True)\n            create_tags_xml(out, tags)\n        self._main_args.extend([\"-t\", f\"global:{str(out)}\"])\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit.info","title":"<code>info(title=None, date=None, muxing_application=None, writing_application=None, **kwargs)</code>","text":"<p>Edit properties for the main info section.</p> <p><code>None</code> always means the property will be left untouched while an empty string will remove the property outright.</p> <p>Bool values are converted to their respective integer to be passed on to mkvpropedit.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str | None</code> <p>The title for the whole movie</p> <code>None</code> <code>date</code> <code>str | None</code> <p>The date the file was created</p> <code>None</code> <code>muxing_application</code> <code>str | None</code> <p>The name of the application or library used for multiplexing the file</p> <code>None</code> <code>writing_application</code> <code>str | None</code> <p>The name of the application or library used for writing the file</p> <code>None</code> <code>kwargs</code> <code>bool | str | None</code> <p>Any other properties to set or remove.  Check out the 'Segment information' section in <code>mkvpropedit -l</code> to see what's available.</p> <code>{}</code> Source code in <code>         muxtools/helpers/propedit.py       </code> <pre><code>def info(\n    self,\n    title: str | None = None,\n    date: str | None = None,\n    muxing_application: str | None = None,\n    writing_application: str | None = None,\n    **kwargs: bool | str | None,\n):\n    \"\"\"\n    Edit properties for the main info section.\n\n    `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n    Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n    :param title:               The title for the whole movie\n    :param date:                The date the file was created\n    :param muxing_application:  The name of the application or library used for multiplexing the file\n    :param writing_application: The name of the application or library used for writing the file\n    :param kwargs:              Any other properties to set or remove.\\n\n                                Check out the 'Segment information' section in `mkvpropedit -l` to see what's available.\n    \"\"\"\n    if self._has_info:\n        raise error(\"Info tagging was already added!\", self)\n    self._edit_track(\"info\", -1, title, date=date, muxing_application=muxing_application, writing_application=writing_application, **kwargs)\n    self._has_info = True\n    return self\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit.video_track","title":"<code>video_track(name=None, language=None, default=None, forced=None, tags=None, crop=None, **kwargs)</code>","text":"<p>Edit properties for the next video track in the file.</p> <p><code>None</code> always means the property will be left untouched while an empty string will remove the property outright.</p> <p>Bool values are converted to their respective integer to be passed on to mkvpropedit.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>A human-readable track name</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Specifies the language of the track</p> <code>None</code> <code>default</code> <code>bool | None</code> <p>Specifies whether a track should be eligible for automatic selection</p> <code>None</code> <code>forced</code> <code>bool | None</code> <p>Specifies whether a track should be played with tracks of a different type but same language</p> <code>None</code> <code>tags</code> <code>dict[str, str] | None</code> <p>Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag  An empty dict will remove any custom tags. <code>None</code> will do nothing.</p> <code>None</code> <code>crop</code> <code>int | tuple[int, int] | tuple[int, int, int, int] | None</code> <p>Container based cropping with (horizontal, vertical) or (left, top, right, bottom).  Will crop the same on all sides if passed a single integer.</p> <code>None</code> <code>kwargs</code> <code>bool | str | None</code> <p>Any other properties to set or remove.  Check out the 'Track headers' section in <code>mkvpropedit -l</code> to see what's available.</p> <code>{}</code> Source code in <code>         muxtools/helpers/propedit.py       </code> <pre><code>def video_track(\n    self,\n    name: str | None = None,\n    language: str | None = None,\n    default: bool | None = None,\n    forced: bool | None = None,\n    tags: dict[str, str] | None = None,\n    crop: int | tuple[int, int] | tuple[int, int, int, int] | None = None,\n    **kwargs: bool | str | None,\n) -&gt; Self:\n    \"\"\"\n    Edit properties for the next video track in the file.\n\n    `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n    Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n    :param name:                A human-readable track name\n    :param language:            Specifies the language of the track\n    :param default:             Specifies whether a track should be eligible for automatic selection\n    :param forced:              Specifies whether a track should be played with tracks of a different type but same language\n\n    :param tags:                Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag\\n\n                                An empty dict will remove any custom tags. `None` will do nothing.\n\n    :param crop:                Container based cropping with (horizontal, vertical) or (left, top, right, bottom).\\n\n                                Will crop the same on all sides if passed a single integer.\n\n    :param kwargs:              Any other properties to set or remove.\\n\n                                Check out the 'Track headers' section in `mkvpropedit -l` to see what's available.\n    \"\"\"\n    if crop is not None:\n        if isinstance(crop, int):\n            crop = tuple([crop] * 4)\n        elif len(crop) == 2:\n            crop = crop * 2\n        kwargs.update(pixel_crop_left=str(crop[0]), pixel_crop_top=str(crop[1]), pixel_crop_right=str(crop[2]), pixel_crop_bottom=str(crop[3]))\n    self._edit_track(\"v\", self._video_index, name, language, default, forced, tags, **kwargs)\n    self._video_index += 1\n    return self\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit.audio_track","title":"<code>audio_track(name=None, language=None, default=None, forced=None, tags=None, **kwargs)</code>","text":"<p>Edit properties for the next audio track in the file.</p> <p><code>None</code> always means the property will be left untouched while an empty string will remove the property outright.</p> <p>Bool values are converted to their respective integer to be passed on to mkvpropedit.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>A human-readable track name</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Specifies the language of the track</p> <code>None</code> <code>default</code> <code>bool | None</code> <p>Specifies whether a track should be eligible for automatic selection</p> <code>None</code> <code>forced</code> <code>bool | None</code> <p>Specifies whether a track should be played with tracks of a different type but same language</p> <code>None</code> <code>tags</code> <code>dict[str, str] | None</code> <p>Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag.  An empty dict will remove any custom tags. <code>None</code> will do nothing.</p> <code>None</code> <code>kwargs</code> <code>bool | str | None</code> <p>Any other properties to set or remove.  Check out the 'Track headers' section in <code>mkvpropedit -l</code> to see what's available.</p> <code>{}</code> Source code in <code>         muxtools/helpers/propedit.py       </code> <pre><code>def audio_track(\n    self,\n    name: str | None = None,\n    language: str | None = None,\n    default: bool | None = None,\n    forced: bool | None = None,\n    tags: dict[str, str] | None = None,\n    **kwargs: bool | str | None,\n) -&gt; Self:\n    \"\"\"\n    Edit properties for the next audio track in the file.\n\n    `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n    Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n    :param name:                A human-readable track name\n    :param language:            Specifies the language of the track\n    :param default:             Specifies whether a track should be eligible for automatic selection\n    :param forced:              Specifies whether a track should be played with tracks of a different type but same language\n\n    :param tags:                Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag.\\n\n                                An empty dict will remove any custom tags. `None` will do nothing.\n\n    :param kwargs:              Any other properties to set or remove.\\n\n                                Check out the 'Track headers' section in `mkvpropedit -l` to see what's available.\n    \"\"\"\n    self._edit_track(\"a\", self._audio_index, name, language, default, forced, tags, **kwargs)\n    self._audio_index += 1\n    return self\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit.sub_track","title":"<code>sub_track(name=None, language=None, default=None, forced=None, tags=None, **kwargs)</code>","text":"<p>Edit properties for the next subtitle track in the file.</p> <p><code>None</code> always means the property will be left untouched while an empty string will remove the property outright.</p> <p>Bool values are converted to their respective integer to be passed on to mkvpropedit.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>A human-readable track name</p> <code>None</code> <code>language</code> <code>str | None</code> <p>Specifies the language of the track</p> <code>None</code> <code>default</code> <code>bool | None</code> <p>Specifies whether a track should be eligible for automatic selection</p> <code>None</code> <code>forced</code> <code>bool | None</code> <p>Specifies whether a track should be played with tracks of a different type but same language</p> <code>None</code> <code>tags</code> <code>dict[str, str] | None</code> <p>Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag.  An empty dict will remove any custom tags. <code>None</code> will do nothing.</p> <code>None</code> <code>kwargs</code> <code>bool | str | None</code> <p>Any other properties to set or remove.  Check out the 'Track headers' section in <code>mkvpropedit -l</code> to see what's available.</p> <code>{}</code> Source code in <code>         muxtools/helpers/propedit.py       </code> <pre><code>def sub_track(\n    self,\n    name: str | None = None,\n    language: str | None = None,\n    default: bool | None = None,\n    forced: bool | None = None,\n    tags: dict[str, str] | None = None,\n    **kwargs: bool | str | None,\n) -&gt; Self:\n    \"\"\"\n    Edit properties for the next subtitle track in the file.\n\n    `None` always means the property will be left untouched while an empty string will remove the property outright.\\n\n    Bool values are converted to their respective integer to be passed on to mkvpropedit.\n\n    :param name:                A human-readable track name\n    :param language:            Specifies the language of the track\n    :param default:             Specifies whether a track should be eligible for automatic selection\n    :param forced:              Specifies whether a track should be played with tracks of a different type but same language\n\n    :param tags:                Any custom/arbitrary tags to set for the track. An empty string as value will remove a tag.\\n\n                                An empty dict will remove any custom tags. `None` will do nothing.\n\n    :param kwargs:              Any other properties to set or remove.\\n\n                                Check out the 'Track headers' section in `mkvpropedit -l` to see what's available.\n    \"\"\"\n    self._edit_track(\"s\", self._subtitle_index, name, language, default, forced, tags, **kwargs)\n    self._subtitle_index += 1\n    return self\n</code></pre>"},{"location":"muxtools/helpers/mkvpropedit/#muxtools.helpers.propedit.MKVPropEdit.run","title":"<code>run(quiet=True, error_on_failure=True)</code>","text":"<p>Run the mkvpropedit process.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>Suppresses the output.  The stdout will still be printed on failure regardless of this setting.</p> <code>True</code> <code>error_on_failure</code> <code>bool</code> <p>Raise an exception on failure.  Otherwise this function will return a bool indicating the success.</p> <code>True</code> Source code in <code>         muxtools/helpers/propedit.py       </code> <pre><code>def run(self, quiet: bool = True, error_on_failure: bool = True) -&gt; bool:\n    \"\"\"\n    Run the mkvpropedit process.\n\n    :param quiet:               Suppresses the output.\\n\n                                The stdout will still be printed on failure regardless of this setting.\n\n    :param error_on_failure:    Raise an exception on failure.\\n\n                                Otherwise this function will return a bool indicating the success.\n    \"\"\"\n    if not self._main_args and not self._track_args:\n        raise error(\"No changes made to the file!\", self)\n    args = [str(self._executable), str(self._fileIn)] + self._main_args + self._track_args\n    code = run_commandline(args, quiet, mkvmerge=True)\n    clean_temp_files()\n    if code &gt; 1 and error_on_failure:\n        raise error(f\"Failed to edit properties for '{self._fileIn.name}'!\")\n\n    return code &lt; 2\n</code></pre>"},{"location":"muxtools/muxing/mux/","title":"mux","text":""},{"location":"muxtools/muxing/mux/#muxtools.muxing.mux.clean_name","title":"<code>clean_name(name)</code>","text":"<p>This removes every unused token and delimiter aswell as empty brackets/parentheses. Ideally should be called before inserting the show name to not cause false positives with that. The .hack series would definitely cause some :)</p> Source code in <code>         muxtools/muxing/mux.py       </code> <pre><code>def clean_name(name: str) -&gt; str:\n    \"\"\"\n    This removes every unused token and delimiter aswell as empty brackets/parentheses.\n    Ideally should be called before inserting the show name to not cause false positives with that.\n    The .hack series would definitely cause some :)\n    \"\"\"\n    stripped = name.strip()\n\n    dont_match = [R\"$show$\", R\"$ep$\", \"$crc32$\"]\n    for match in re.findall(r\"\\$[^ ]+?\\$\", name):\n        if match not in dont_match:\n            stripped = stripped.replace(match, \"\").strip()\n            warn(f\"Unknown token '{match}' was removed.\", \"Mux\")\n\n    delimiters = [\"-\", \"/\"]\n    if not stripped.endswith(\"...\"):\n        delimiters.append(\".\")\n\n    while any([stripped.startswith(delim) for delim in delimiters]):\n        stripped = stripped.lstrip(\"\".join(delimiters)).strip()\n\n    while any([stripped.endswith(delim) for delim in delimiters]):\n        stripped = stripped.rstrip(\"\".join(delimiters)).strip()\n\n    stripped = stripped.replace(\"()\", \"\")\n    stripped = stripped.replace(\"[]\", \"\")\n\n    return stripped\n</code></pre>"},{"location":"muxtools/muxing/mux/#muxtools.muxing.mux.mux","title":"<code>mux(*tracks, tmdb=None, outfile=None, quiet=True, print_cli=False)</code>","text":"<p>Runs the mux.</p> <p>Parameters:</p> Name Type Description Default <code>*tracks</code> <p>Any amount of track objects and a Chapters object</p> <code>()</code> <code>tmdb</code> <code>TmdbConfig | None</code> <p>A TMDB Config used for additional tagging if you so desire.</p> <code>None</code> <code>outfile</code> <code>PathLike | None</code> <p>If you want to overwrite the output file path</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Whether or not to print the mkvmerge output</p> <code>True</code> <code>print_cli</code> <code>bool</code> <p>Print the final muxing command before running it if True</p> <code>False</code> Source code in <code>         muxtools/muxing/mux.py       </code> <pre><code>def mux(*tracks, tmdb: TmdbConfig | None = None, outfile: PathLike | None = None, quiet: bool = True, print_cli: bool = False) -&gt; PathLike:\n    \"\"\"\n    Runs the mux.\n\n    :param *tracks:     Any amount of track objects and a Chapters object\n    :param tmdb:        A TMDB Config used for additional tagging if you so desire.\n    :param outfile:     If you want to overwrite the output file path\n    :param quiet:       Whether or not to print the mkvmerge output\n    :param print_cli:   Print the final muxing command before running it if True\n    \"\"\"\n    check_mkvmerge_version()\n    tracks = list(tracks)\n    out_dir = ensure_path(get_setup_attr(\"out_dir\", \"premux\"), \"Mux\")\n    args: list[str] = [get_executable(\"mkvmerge\")]\n\n    filename, mkvtitle = output_names(tmdb, args, tracks)\n\n    if not outfile:\n        outfile = Path(out_dir, f\"{filename}.mkv\")\n\n    outfile = ensure_path(outfile, \"Mux\")\n\n    args.extend([\"-o\", str(outfile)])\n\n    for track in tracks:\n        if isinstance(track, _track):\n            args.extend(track.mkvmerge_args())\n            continue\n        elif isinstance(track, MuxingFile):\n            if not isinstance(track, FontFile):\n                warn(\"It's strongly recommended to pass tracks to ensure naming and tagging instead of MuxingFiles directly!\", \"Mux\", 1)\n            track = track.to_track()\n            args.extend(track.mkvmerge_args())\n            continue\n        elif isinstance(track, Chapters):\n            if not track.chapters:\n                warn(\"Chapters are None or empty!\", \"Mux\")\n                continue\n\n            args.extend([\"--chapters\", track.to_file()])\n            continue\n        elif isinstance(track, Path) or isinstance(track, str) or isinstance(track, GlobSearch):\n            # Failsave for if someone passes Chapters().to_file() or a txt/xml file\n            track = ensure_path_exists(track, \"Mux\")\n            if track.suffix.lower() in [\".txt\", \".xml\"]:\n                args.extend([\"--chapters\", str(track.resolve())])\n                continue\n        elif track is None:\n            continue\n\n        raise error(\"Only _track, MuxingFiles or Chapters types are supported as muxing input!\", \"Mux\")\n\n    if mkvtitle:\n        args.extend([\"--title\", mkvtitle])\n\n    if print_cli:\n        info(joincommand(args), \"Mux\")\n\n    debug(\"Running the mux...\", \"Mux\")\n    if run_commandline(args, quiet, mkvmerge=True) &gt; 1:\n        raise error(\"Muxing failed!\", \"Mux\")\n\n    try:\n        from importlib.metadata import version\n\n        parsed = ParsedFile.from_file(outfile, \"Mux\")\n        tags = parsed.container_info.tags\n        if not tags:\n            debug(\"File does not contain writing library tags. Skipping the muxtools branding.\", \"Mux\")\n\n        mkvpropedit = get_executable(\"mkvpropedit\", False, False)\n        if not mkvpropedit:\n            warn(\"Mkvpropedit could not be found!\", \"Mux\", 0)\n        muxtools_version = version(\"muxtools\")\n        version_tag = f\" + muxtools v{muxtools_version}\"\n\n        muxing_application = tags.get(\"encoder\", None)\n\n        if mkvpropedit and muxing_application and (match := writing_lib_regex.search(muxing_application)):\n            muxing_application = f\"libebml v{match.group(1)} + libmatroska v{match.group(2)}\" + version_tag\n            args = [mkvpropedit, \"--edit\", \"info\", \"--set\", f\"muxing-application={muxing_application}\", str(outfile.resolve())]\n            if run_commandline(args, mkvmerge=True) &gt; 1:\n                danger(\"Failed to add muxtools information via mkvpropedit!\", \"Mux\")\n    except Exception as e:\n        print(e)\n        danger(\"Failed to add muxtools information via mkvpropedit!\", \"Mux\")\n\n    if \"#crc32#\" in outfile.stem:\n        debug(\"Generating CRC32 for the muxed file...\", \"Mux\")\n        outfile = outfile.rename(outfile.with_stem(re.sub(re.escape(\"#crc32#\"), get_crc32(outfile), outfile.stem)))\n\n    if get_setup_attr(\"clean_work_dirs\", False):\n        if os.path.samefile(get_workdir(), os.getcwd()):\n            error(\"Clearing workdir not supported when your workdir is cwd.\", \"Mux\")\n        else:\n            rmtree(get_workdir())\n\n    clean_temp_files()\n    debug(\"Done\", \"Mux\")\n    return outfile\n</code></pre>"},{"location":"muxtools/muxing/tmdb/","title":"tmdb","text":""},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder","title":"<code>TMDBOrder</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>TMDB Episode groups or orders. Don't think there is a universally agreed on name.</p> <p>This enum is for automatically selecting one with the given type.</p> Source code in <code>           muxtools/muxing/tmdb.py         </code> <pre><code>class TMDBOrder(IntEnum):\n    \"\"\"\n    TMDB Episode groups or orders. Don't think there is a universally agreed on name.\\n\n    This enum is for automatically selecting one with the given type.\n    \"\"\"\n\n    ORIGINAL_AIR_DATE = 1\n    \"\"\"Original air date order\"\"\"\n    ABSOLUTE = 2\n    \"\"\"Absolute numbering order\"\"\"\n    DVD = 3\n    \"\"\"DVD order\"\"\"\n    DIGITAL = 4\n    \"\"\"Digital order\"\"\"\n    STORY_ARC = 5\n    \"\"\"Story Arc order\"\"\"\n    PRODUCTION = 6\n    \"\"\"\n    Production order, this is usually what contains the proper seasons now that \n    TMDB mods decided to be weird.\n\n    See https://www.themoviedb.org/tv/95479/discuss/64a5672ada10f0011cb49f99\n    \"\"\"\n    TV = 7\n    \"\"\"TV order\"\"\"\n</code></pre>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.ABSOLUTE","title":"<code>ABSOLUTE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Absolute numbering order</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.DIGITAL","title":"<code>DIGITAL = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Digital order</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.DVD","title":"<code>DVD = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>DVD order</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.ORIGINAL_AIR_DATE","title":"<code>ORIGINAL_AIR_DATE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Original air date order</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.PRODUCTION","title":"<code>PRODUCTION = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Production order, this is usually what contains the proper seasons now that  TMDB mods decided to be weird.</p> <p>See https://www.themoviedb.org/tv/95479/discuss/64a5672ada10f0011cb49f99</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.STORY_ARC","title":"<code>STORY_ARC = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Story Arc order</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TMDBOrder.TV","title":"<code>TV = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TV order</p>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TmdbConfig","title":"<code>TmdbConfig</code>  <code>dataclass</code>","text":"<p>A simple configuration class for TMDB Usage in muxing.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>TMDB Media ID. The numerical part in URLs like https://www.themoviedb.org/tv/82684/...</p> required <code>season</code> <code>int</code> <p>The number of the season. If given an order this will be the Nth subgroup in that order.</p> <code>1</code> <code>movie</code> <code>bool</code> <p>Is this a movie?</p> <code>False</code> <code>order</code> <code>TMDBOrder | str | None</code> <p>Episode group/order enum or a string for an exact ID. Obviously not applicable to a movie.</p> <code>None</code> <code>language</code> <code>str</code> <p>The metadata language. Defaults to english. This requires ISO 639-1 codes. See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes Be aware that some metadata might just not exist in your requested language. Check beforehand.</p> <code>'en-US'</code> <code>offset</code> <code>int</code> <p>Offset to apply to the current number used in the setup that will be matched to the TMDB number.</p> <code>0</code> <code>write_title</code> <code>bool</code> <p>Writes the episode title to the <code>DESCRIPTION</code> mkv tag if True</p> <code>False</code> <code>write_ids</code> <code>bool</code> <p>Writes the IDs (IMDB, TVDB, TMDB) to their respective mkv tags if True</p> <code>True</code> <code>write_date</code> <code>bool</code> <p>Writes the episode release date to the <code>DATE_RELEASED</code> mkv tag if True</p> <code>True</code> <code>write_cover</code> <code>bool</code> <p>Download episode thumbnail from TMDB to use as cover art attachment for the MKV.</p> <code>False</code> <code>write_summary</code> <code>bool</code> <p>Writes the series summary/synopsis to the <code>SUMMARY</code> mkv tag if True</p> <code>False</code> <code>write_synopsis</code> <code>bool</code> <p>Writes the individual episode synopsis to the <code>SYNOPSIS</code> mkv tag if True</p> <code>False</code> <code>replace_spaces</code> <code>str | bool</code> <p>Replaces spaces in titles with dots if True and with whatever string you passed if a string.</p> <code>False</code> <code>title_sanitization</code> <code>dict[str, str]</code> <p>A dictionary of characters to replace in titles. Defaults to removing <code>&lt;&gt;:\"/\\|?*</code> characters.</p> <code>(lambda: {'&lt;&gt;:\"/\\\\|?*': ''})()</code> Source code in <code>           muxtools/muxing/tmdb.py         </code> <pre><code>@dataclass\nclass TmdbConfig:\n    \"\"\"\n    A simple configuration class for TMDB Usage in muxing.\n\n    :param id:                  TMDB Media ID. The numerical part in URLs like https://www.themoviedb.org/tv/82684/...\n    :param season:              The number of the season. If given an order this will be the Nth subgroup in that order.\n    :param movie:               Is this a movie?\n    :param order:               Episode group/order enum or a string for an exact ID. Obviously not applicable to a movie.\n    :param language:            The metadata language. Defaults to english.\n                                This requires ISO 639-1 codes. See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n                                Be aware that some metadata might just not exist in your requested language. Check beforehand.\n\n    :param offset:              Offset to apply to the current number used in the setup that will be matched to the TMDB number.\n\n    :param write_title:         Writes the episode title to the `DESCRIPTION` mkv tag if True\n    :param write_ids:           Writes the IDs (IMDB, TVDB, TMDB) to their respective mkv tags if True\n    :param write_date:          Writes the episode release date to the `DATE_RELEASED` mkv tag if True\n    :param write_cover:         Download episode thumbnail from TMDB to use as cover art attachment for the MKV.\n    :param write_summary:       Writes the series summary/synopsis to the `SUMMARY` mkv tag if True\n    :param write_synopsis:      Writes the individual episode synopsis to the `SYNOPSIS` mkv tag if True\n    :param replace_spaces:      Replaces spaces in titles with dots if True and with whatever string you passed if a string.\n    :param title_sanitization:  A dictionary of characters to replace in titles. Defaults to removing `&lt;&gt;:\"/\\|?*` characters.\n    \"\"\"\n\n    id: int\n    season: int = 1\n    movie: bool = False\n    order: TMDBOrder | str | None = None\n    language: str = \"en-US\"\n    offset: int = 0\n\n    write_ids: bool = True\n    write_date: bool = True\n    write_title: bool = False\n    write_cover: bool = False\n    write_summary: bool = False\n    write_synopsis: bool = False\n    replace_spaces: str | bool = False\n    title_sanitization: dict[str, str] = field(default_factory=lambda: {'&lt;&gt;:\"/\\\\|?*': \"\"})\n\n    def needs_xml(self) -&gt; bool:\n        return self.write_ids or self.write_date or self.write_title or self.write_summary or self.write_synopsis\n\n    def get_media_meta(self) -&gt; MediaMetadata:\n        url = f\"{BASE_URL}/{'movie' if self.movie else 'tv'}/{self.id}?language={self.language}\"\n        headers = {\"accept\": \"application/json\", \"Authorization\": f\"Bearer {API_KEY}\"}\n        response = requests.get(url, headers=headers)\n\n        if response.status_code &gt; 202:\n            ex = error(f\"Media Metadata Request has failed! ({response.status_code})\", self)\n            debug(response.text)\n            raise ex\n\n        mediajson = response.json()\n\n        url = f\"{BASE_URL}/{'movie' if self.movie else 'tv'}/{self.id}/external_ids\"\n        response = requests.get(url, headers=headers)\n        other_ids = response.json()\n\n        return MediaMetadata(\n            self.id,\n            other_ids.get(\"tvdb_id\", 0),\n            other_ids.get(\"imdb_id\", \"\"),\n            mediajson.get(\"overview\", \"\"),\n            mediajson.get(\"release_date\", None) if self.movie else None,\n        )\n\n    def get_episode_meta(self, num: int) -&gt; EpisodeMetadata:\n        if not hasattr(self, \"episodes\"):\n            headers = {\"accept\": \"application/json\", \"Authorization\": f\"Bearer {API_KEY}\"}\n            if self.order:\n                if not hasattr(self, \"order_id\"):\n                    if isinstance(self.order, str):\n                        setattr(self, \"order_id\", self.order)\n                    else:\n                        orders_url = f\"{BASE_URL}/tv/{self.id}/episode_groups\"\n                        order_resp = requests.get(orders_url, headers=headers)\n                        orders = order_resp.json()[\"results\"]\n                        if not orders:\n                            raise error(\"Could not find any episode groups/orders for this show.\", self)\n                        filtered = [order for order in orders if order[\"type\"] == self.order]\n                        if not filtered:\n                            raise error(f\"Could not find an episode groups/orders for type {self.order.name}.\", self)\n\n                        wanted_order = sorted(filtered, key=lambda it: it[\"group_count\"])[0]\n                        info(f\"Selecting episode group '{wanted_order['name']}'.\", self)\n                        setattr(self, \"order_id\", str(wanted_order[\"id\"]))\n\n                url = f\"{BASE_URL}/tv/episode_group/{self.order_id}?language={self.language}\"\n            else:\n                url = f\"{BASE_URL}/tv/{self.id}/season/{self.season}?language={self.language}\"\n\n            meta_response = requests.get(url, headers=headers)\n\n            if meta_response.status_code &gt; 202:\n                ex = error(f\"Episode Metadata Request has failed! ({meta_response.status_code})\", self)\n                debug(meta_response.text)\n                raise ex\n\n            json_resp: dict = meta_response.json()\n            if \"groups\" in json_resp:\n                groups = json_resp[\"groups\"]\n                try:\n                    group = [group for group in groups if group[\"order\"] == self.season][0]\n                except:\n                    raise error(f\"Could not find subgroup for the number {self.season}.\", self)\n                self.episodes = group[\"episodes\"]\n            else:\n                self.episodes = json_resp[\"episodes\"]\n\n        try:\n            episode: dict = self.episodes[(num + self.offset) - 1]\n        except:\n            raise error(f\"Failed to find or parse episode {num:02}!\", self)\n\n        title = cast(str, episode.get(\"name\", \"\"))\n        if self.replace_spaces is True:\n            title = title.replace(\" \", \".\")\n        elif isinstance(self.replace_spaces, str):\n            title = title.replace(\" \", self.replace_spaces)\n\n        sanitized_title = title\n        for key, value in self.title_sanitization.items():\n            for char in sanitized_title:\n                if char in key:\n                    sanitized_title = sanitized_title.replace(char, value)\n\n        return EpisodeMetadata(\n            title,\n            episode.get(\"air_date\", \"\"),\n            episode.get(\"overview\", \"\"),\n            f\"https://image.tmdb.org/t/p/w780{episode.get('still_path')}\" if self.write_cover else \"\",\n            sanitized_title,\n        )\n\n    def make_xml(self, media: MediaMetadata, episode: EpisodeMetadata | None = None) -&gt; PathLike:\n        from ..utils.files import make_output\n\n        tags = dict()\n\n        if self.write_title and episode:\n            tags.update(DESCRIPTION=episode.title)\n        if self.write_ids:\n            if not self.movie and media.tvdb_id:\n                tags.update(TVDB=media.tvdb_id)\n            prefix = \"movie/\" if self.movie else \"tv/\"\n            tags.update(TMDB=prefix + str(media.tmdb_id))\n            tags.update(IMDB=media.imdb_id)\n        if self.write_date:\n            if self.movie:\n                if media.release_date:\n                    tags.update(DATE_RELEASED=media.release_date)\n            else:\n                tags.update(DATE_RELEASED=episode.release_date)\n        if self.write_summary:\n            tags.update(SUMMARY=media.summary)\n        if self.write_synopsis and not self.movie:\n            tags.update(SYNOPSIS=episode.synopsis)\n\n        outfile = make_output(\"tags\", \"xml\")\n        create_tags_xml(outfile, tags)\n\n        return outfile\n</code></pre>"},{"location":"muxtools/muxing/tmdb/#muxtools.muxing.tmdb.TitleTMDB","title":"<code>TitleTMDB(id, season=1, movie=False, language='en-US', offset=0, order=None)</code>","text":"<p>Shortcut function to get a TMDB config with just titles enabled.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>TMDB Media ID. The numerical part in URLs like https://www.themoviedb.org/tv/82684/...</p> required <code>season</code> <code>int</code> <p>The number of the season. If given an order this will be the Nth subgroup in that order.</p> <code>1</code> <code>movie</code> <code>bool</code> <p>Is this a movie?</p> <code>False</code> <code>order</code> <code>TMDBOrder | str | None</code> <p>Episode group/order enum or a string for an exact ID. Obviously not applicable to a movie.</p> <code>None</code> <code>language</code> <code>str</code> <p>The metadata language. Defaults to english. This requires ISO 639-1 codes. See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes Be aware that some metadata might just not exist in your requested language. Check beforehand.</p> <code>'en-US'</code> <code>offset</code> <code>int</code> <p>Offset to apply to the current number used in the setup that will be matched to the TMDB number.</p> <code>0</code> Source code in <code>         muxtools/muxing/tmdb.py       </code> <pre><code>def TitleTMDB(\n    id: int, season: int = 1, movie: bool = False, language: str = \"en-US\", offset: int = 0, order: TMDBOrder | str | None = None\n) -&gt; TmdbConfig:\n    \"\"\"\n    Shortcut function to get a TMDB config with just titles enabled.\n\n    :param id:              TMDB Media ID. The numerical part in URLs like https://www.themoviedb.org/tv/82684/...\n    :param season:          The number of the season. If given an order this will be the Nth subgroup in that order.\n    :param movie:           Is this a movie?\n    :param order:           Episode group/order enum or a string for an exact ID. Obviously not applicable to a movie.\n    :param language:        The metadata language. Defaults to english.\n                            This requires ISO 639-1 codes. See https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n                            Be aware that some metadata might just not exist in your requested language. Check beforehand.\n\n    :param offset:          Offset to apply to the current number used in the setup that will be matched to the TMDB number.\n    \"\"\"\n    return TmdbConfig(id, season, movie, order, language, offset, False, False, False, False, False, False)\n</code></pre>"},{"location":"muxtools/muxing/tracks/","title":"tracks","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VT","title":"<code>VT = VideoTrack</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AT","title":"<code>AT = AudioTrack</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.ST","title":"<code>ST = SubTrack</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.MkvTrack","title":"<code>MkvTrack = Premux</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track","title":"<code>_track</code>","text":"Source code in <code>           muxtools/muxing/tracks.py         </code> <pre><code>class _track:\n    file: Path\n    type: TrackType\n    default: bool\n    forced: bool\n    name: str\n    lang: str\n    delay: int\n    args: list[str] | None\n    tags: dict[str, str] | None\n\n    def __init__(\n        self,\n        file: PathLike,\n        type: str | int | TrackType,\n        name: str = \"\",\n        lang: str = \"\",\n        default: bool = True,\n        forced: bool = False,\n        delay: int = 0,\n        args: list[str] | None = None,\n        tags: dict[str, str] | None = None,\n    ) -&gt; None:\n        from .muxfiles import MuxingFile\n\n        \"\"\"\n        :param file:        Filepath as string or Path object\n        :param type:        TrackType enum, or int or string (1 = 'video', 2 = 'audio', 3 = 'sub')\n        :param name:        The track name in the resulting mkv file\n        :param lang:        The language tag for the track\n        :param default:     Default flag\n        :param forced:      Forced flag\n        :param delay:       Container delay of track in ms\n        \"\"\"\n        self.file = ensure_path_exists(file, self)\n        self.default = default\n        self.forced = forced\n        self.name = name\n        self.delay = file.container_delay if isinstance(file, MuxingFile) else delay\n        self.lang = lang\n        self.type = type if isinstance(type, TrackType) else (TrackType(type) if isinstance(type, int) else TrackType[type.upper()])\n        self.args = args\n        self.tags = tags\n\n    def mkvmerge_args(self) -&gt; list[str]:\n        filepath = str(self.file.resolve())\n        if self.type == TrackType.ATTACHMENT:\n            is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n            if not is_font and not self.lang:\n                raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n            if not is_font:\n                args = [\"--attachment-mime-type\", self.lang]\n            else:\n                args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n            if self.name:\n                args.extend([\"--attachment-name\", self.name])\n\n            args.extend([\"--attach-file\", filepath])\n            return args\n\n        elif self.type == TrackType.MKV:\n            return [*self.args, filepath]\n        elif self.type == TrackType.CHAPTERS:\n            return [\"--chapters\", filepath]\n\n        args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n        if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n            tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n            create_tags_xml(tags_file, self.tags)\n            args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n        if self.lang:\n            args.extend([\"--language\", f\"0:{self.lang}\"])\n        if self.delay:\n            args.extend([\"--sync\", f\"0:{self.delay}\"])\n        args.extend(\n            [\n                \"--default-track-flag\",\n                f\"0:{'yes' if self.default else 'no'}\",\n                \"--forced-display-flag\",\n                f\"0:{'yes' if self.forced else 'no'}\",\n            ]\n        )\n        if self.args:\n            args.extend(self.args)\n        args.append(filepath)\n        return args\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.args","title":"<code>args = args</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.default","title":"<code>default = default</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.delay","title":"<code>delay = file.container_delay if isinstance(file, MuxingFile) else delay</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.file","title":"<code>file = ensure_path_exists(file, self)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.forced","title":"<code>forced = forced</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.lang","title":"<code>lang = lang</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.tags","title":"<code>tags = tags</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.type","title":"<code>type = type if isinstance(type, TrackType) else TrackType(type) if isinstance(type, int) else TrackType[type.upper()]</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.__init__","title":"<code>__init__(file, type, name='', lang='', default=True, forced=False, delay=0, args=None, tags=None)</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def __init__(\n    self,\n    file: PathLike,\n    type: str | int | TrackType,\n    name: str = \"\",\n    lang: str = \"\",\n    default: bool = True,\n    forced: bool = False,\n    delay: int = 0,\n    args: list[str] | None = None,\n    tags: dict[str, str] | None = None,\n) -&gt; None:\n    from .muxfiles import MuxingFile\n\n    \"\"\"\n    :param file:        Filepath as string or Path object\n    :param type:        TrackType enum, or int or string (1 = 'video', 2 = 'audio', 3 = 'sub')\n    :param name:        The track name in the resulting mkv file\n    :param lang:        The language tag for the track\n    :param default:     Default flag\n    :param forced:      Forced flag\n    :param delay:       Container delay of track in ms\n    \"\"\"\n    self.file = ensure_path_exists(file, self)\n    self.default = default\n    self.forced = forced\n    self.name = name\n    self.delay = file.container_delay if isinstance(file, MuxingFile) else delay\n    self.lang = lang\n    self.type = type if isinstance(type, TrackType) else (TrackType(type) if isinstance(type, int) else TrackType[type.upper()])\n    self.args = args\n    self.tags = tags\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks._track.mkvmerge_args","title":"<code>mkvmerge_args()</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def mkvmerge_args(self) -&gt; list[str]:\n    filepath = str(self.file.resolve())\n    if self.type == TrackType.ATTACHMENT:\n        is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n        if not is_font and not self.lang:\n            raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n        if not is_font:\n            args = [\"--attachment-mime-type\", self.lang]\n        else:\n            args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n        if self.name:\n            args.extend([\"--attachment-name\", self.name])\n\n        args.extend([\"--attach-file\", filepath])\n        return args\n\n    elif self.type == TrackType.MKV:\n        return [*self.args, filepath]\n    elif self.type == TrackType.CHAPTERS:\n        return [\"--chapters\", filepath]\n\n    args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n    if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n        tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n        create_tags_xml(tags_file, self.tags)\n        args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n    if self.lang:\n        args.extend([\"--language\", f\"0:{self.lang}\"])\n    if self.delay:\n        args.extend([\"--sync\", f\"0:{self.delay}\"])\n    args.extend(\n        [\n            \"--default-track-flag\",\n            f\"0:{'yes' if self.default else 'no'}\",\n            \"--forced-display-flag\",\n            f\"0:{'yes' if self.forced else 'no'}\",\n        ]\n    )\n    if self.args:\n        args.extend(self.args)\n    args.append(filepath)\n    return args\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack","title":"<code>VideoTrack</code>","text":"<p>               Bases: <code>_track</code></p> <p>_track object with VIDEO type preselected and japanese language default</p> <p>Parameters:</p> Name Type Description Default <code>timecode_file</code> <code>PathLike | GlobSearch | None</code> <p>Pass a path for proper vfr playback if needed.</p> <code>None</code> <code>crop</code> <code>int | tuple[int, int] | tuple[int, int, int, int] | None</code> <p>Container based cropping with (horizontal, vertical) or (left, top, right, bottom). Will crop the same on all sides if passed a single integer.</p> <code>None</code> Source code in <code>           muxtools/muxing/tracks.py         </code> <pre><code>class VideoTrack(_track):\n    \"\"\"\n    _track object with VIDEO type preselected and japanese language default\n\n    :param timecode_file:       Pass a path for proper vfr playback if needed.\n    :param crop:                Container based cropping with (horizontal, vertical) or (left, top, right, bottom).\n                                Will crop the same on all sides if passed a single integer.\n    \"\"\"\n\n    def __init__(\n        self,\n        file: PathLike | GlobSearch,\n        name: str = \"\",\n        lang: str = \"ja\",\n        default: bool = True,\n        forced: bool = False,\n        delay: int = 0,\n        timecode_file: PathLike | GlobSearch | None = None,\n        crop: int | tuple[int, int] | tuple[int, int, int, int] | None = None,\n        args: list[str] = [],\n        tags: dict[str, str] | None = None,\n    ) -&gt; None:\n        if timecode_file is not None:\n            args.extend([\"--timestamps\", f\"0:{ensure_path_exists(timecode_file, self).resolve()}\"])\n        if crop:\n            if isinstance(crop, int):\n                crop = tuple([crop] * 4)\n            elif len(crop) == 2:\n                crop = crop * 2\n            args.extend([\"--cropping\", f\"0:{crop[0]},{crop[1]},{crop[2]},{crop[3]}\"])\n        super().__init__(file, TrackType.VIDEO, name, lang, default, forced, delay, args, tags)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.args","title":"<code>args = args</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.default","title":"<code>default = default</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.delay","title":"<code>delay = file.container_delay if isinstance(file, MuxingFile) else delay</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.file","title":"<code>file = ensure_path_exists(file, self)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.forced","title":"<code>forced = forced</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.lang","title":"<code>lang = lang</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.tags","title":"<code>tags = tags</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.type","title":"<code>type = type if isinstance(type, TrackType) else TrackType(type) if isinstance(type, int) else TrackType[type.upper()]</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.__init__","title":"<code>__init__(file, name='', lang='ja', default=True, forced=False, delay=0, timecode_file=None, crop=None, args=[], tags=None)</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def __init__(\n    self,\n    file: PathLike | GlobSearch,\n    name: str = \"\",\n    lang: str = \"ja\",\n    default: bool = True,\n    forced: bool = False,\n    delay: int = 0,\n    timecode_file: PathLike | GlobSearch | None = None,\n    crop: int | tuple[int, int] | tuple[int, int, int, int] | None = None,\n    args: list[str] = [],\n    tags: dict[str, str] | None = None,\n) -&gt; None:\n    if timecode_file is not None:\n        args.extend([\"--timestamps\", f\"0:{ensure_path_exists(timecode_file, self).resolve()}\"])\n    if crop:\n        if isinstance(crop, int):\n            crop = tuple([crop] * 4)\n        elif len(crop) == 2:\n            crop = crop * 2\n        args.extend([\"--cropping\", f\"0:{crop[0]},{crop[1]},{crop[2]},{crop[3]}\"])\n    super().__init__(file, TrackType.VIDEO, name, lang, default, forced, delay, args, tags)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.VideoTrack.mkvmerge_args","title":"<code>mkvmerge_args()</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def mkvmerge_args(self) -&gt; list[str]:\n    filepath = str(self.file.resolve())\n    if self.type == TrackType.ATTACHMENT:\n        is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n        if not is_font and not self.lang:\n            raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n        if not is_font:\n            args = [\"--attachment-mime-type\", self.lang]\n        else:\n            args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n        if self.name:\n            args.extend([\"--attachment-name\", self.name])\n\n        args.extend([\"--attach-file\", filepath])\n        return args\n\n    elif self.type == TrackType.MKV:\n        return [*self.args, filepath]\n    elif self.type == TrackType.CHAPTERS:\n        return [\"--chapters\", filepath]\n\n    args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n    if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n        tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n        create_tags_xml(tags_file, self.tags)\n        args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n    if self.lang:\n        args.extend([\"--language\", f\"0:{self.lang}\"])\n    if self.delay:\n        args.extend([\"--sync\", f\"0:{self.delay}\"])\n    args.extend(\n        [\n            \"--default-track-flag\",\n            f\"0:{'yes' if self.default else 'no'}\",\n            \"--forced-display-flag\",\n            f\"0:{'yes' if self.forced else 'no'}\",\n        ]\n    )\n    if self.args:\n        args.extend(self.args)\n    args.append(filepath)\n    return args\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack","title":"<code>AudioTrack</code>","text":"<p>               Bases: <code>_track</code></p> <p>_track object with AUDIO type preselected and japanese language default</p> Source code in <code>           muxtools/muxing/tracks.py         </code> <pre><code>class AudioTrack(_track):\n    \"\"\"\n    _track object with AUDIO type preselected and japanese language default\n    \"\"\"\n\n    def __init__(\n        self,\n        file: PathLike | GlobSearch,\n        name: str = \"\",\n        lang: str = \"ja\",\n        default: bool = True,\n        forced: bool = False,\n        delay: int = 0,\n        args: list[str] | None = None,\n        tags: dict[str, str] | None = None,\n    ) -&gt; None:\n        super().__init__(file, TrackType.AUDIO, name, lang, default, forced, delay, args, tags)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.args","title":"<code>args = args</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.default","title":"<code>default = default</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.delay","title":"<code>delay = file.container_delay if isinstance(file, MuxingFile) else delay</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.file","title":"<code>file = ensure_path_exists(file, self)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.forced","title":"<code>forced = forced</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.lang","title":"<code>lang = lang</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.tags","title":"<code>tags = tags</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.type","title":"<code>type = type if isinstance(type, TrackType) else TrackType(type) if isinstance(type, int) else TrackType[type.upper()]</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.__init__","title":"<code>__init__(file, name='', lang='ja', default=True, forced=False, delay=0, args=None, tags=None)</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def __init__(\n    self,\n    file: PathLike | GlobSearch,\n    name: str = \"\",\n    lang: str = \"ja\",\n    default: bool = True,\n    forced: bool = False,\n    delay: int = 0,\n    args: list[str] | None = None,\n    tags: dict[str, str] | None = None,\n) -&gt; None:\n    super().__init__(file, TrackType.AUDIO, name, lang, default, forced, delay, args, tags)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.AudioTrack.mkvmerge_args","title":"<code>mkvmerge_args()</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def mkvmerge_args(self) -&gt; list[str]:\n    filepath = str(self.file.resolve())\n    if self.type == TrackType.ATTACHMENT:\n        is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n        if not is_font and not self.lang:\n            raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n        if not is_font:\n            args = [\"--attachment-mime-type\", self.lang]\n        else:\n            args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n        if self.name:\n            args.extend([\"--attachment-name\", self.name])\n\n        args.extend([\"--attach-file\", filepath])\n        return args\n\n    elif self.type == TrackType.MKV:\n        return [*self.args, filepath]\n    elif self.type == TrackType.CHAPTERS:\n        return [\"--chapters\", filepath]\n\n    args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n    if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n        tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n        create_tags_xml(tags_file, self.tags)\n        args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n    if self.lang:\n        args.extend([\"--language\", f\"0:{self.lang}\"])\n    if self.delay:\n        args.extend([\"--sync\", f\"0:{self.delay}\"])\n    args.extend(\n        [\n            \"--default-track-flag\",\n            f\"0:{'yes' if self.default else 'no'}\",\n            \"--forced-display-flag\",\n            f\"0:{'yes' if self.forced else 'no'}\",\n        ]\n    )\n    if self.args:\n        args.extend(self.args)\n    args.append(filepath)\n    return args\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack","title":"<code>SubTrack</code>","text":"<p>               Bases: <code>_track</code></p> <p>_track object with SUB type preselected and english language default</p> <p>Supports merging multiple files by passing a List of Path objects or filepath strings and of course also a GlobSearch</p> Source code in <code>           muxtools/muxing/tracks.py         </code> <pre><code>class SubTrack(_track):\n    \"\"\"\n    _track object with SUB type preselected and english language default\n\n    Supports merging multiple files by passing a List of Path objects or filepath strings\n    and of course also a GlobSearch\n    \"\"\"\n\n    def __init__(\n        self,\n        file: PathLike | GlobSearch,\n        name: str = \"\",\n        lang: str = \"en\",\n        default: bool = True,\n        forced: bool = False,\n        delay: int = 0,\n        args: list[str] | None = None,\n        tags: dict[str, str] | None = None,\n    ) -&gt; None:\n        super().__init__(file, TrackType.SUB, name, lang, default, forced, delay, args, tags)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.args","title":"<code>args = args</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.default","title":"<code>default = default</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.delay","title":"<code>delay = file.container_delay if isinstance(file, MuxingFile) else delay</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.file","title":"<code>file = ensure_path_exists(file, self)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.forced","title":"<code>forced = forced</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.lang","title":"<code>lang = lang</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.tags","title":"<code>tags = tags</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.type","title":"<code>type = type if isinstance(type, TrackType) else TrackType(type) if isinstance(type, int) else TrackType[type.upper()]</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.__init__","title":"<code>__init__(file, name='', lang='en', default=True, forced=False, delay=0, args=None, tags=None)</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def __init__(\n    self,\n    file: PathLike | GlobSearch,\n    name: str = \"\",\n    lang: str = \"en\",\n    default: bool = True,\n    forced: bool = False,\n    delay: int = 0,\n    args: list[str] | None = None,\n    tags: dict[str, str] | None = None,\n) -&gt; None:\n    super().__init__(file, TrackType.SUB, name, lang, default, forced, delay, args, tags)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.SubTrack.mkvmerge_args","title":"<code>mkvmerge_args()</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def mkvmerge_args(self) -&gt; list[str]:\n    filepath = str(self.file.resolve())\n    if self.type == TrackType.ATTACHMENT:\n        is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n        if not is_font and not self.lang:\n            raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n        if not is_font:\n            args = [\"--attachment-mime-type\", self.lang]\n        else:\n            args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n        if self.name:\n            args.extend([\"--attachment-name\", self.name])\n\n        args.extend([\"--attach-file\", filepath])\n        return args\n\n    elif self.type == TrackType.MKV:\n        return [*self.args, filepath]\n    elif self.type == TrackType.CHAPTERS:\n        return [\"--chapters\", filepath]\n\n    args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n    if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n        tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n        create_tags_xml(tags_file, self.tags)\n        args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n    if self.lang:\n        args.extend([\"--language\", f\"0:{self.lang}\"])\n    if self.delay:\n        args.extend([\"--sync\", f\"0:{self.delay}\"])\n    args.extend(\n        [\n            \"--default-track-flag\",\n            f\"0:{'yes' if self.default else 'no'}\",\n            \"--forced-display-flag\",\n            f\"0:{'yes' if self.forced else 'no'}\",\n        ]\n    )\n    if self.args:\n        args.extend(self.args)\n    args.append(filepath)\n    return args\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux","title":"<code>Premux</code>","text":"<p>               Bases: <code>_track</code></p> Source code in <code>           muxtools/muxing/tracks.py         </code> <pre><code>class Premux(_track):\n    def __init__(\n        self,\n        file: PathLike | GlobSearch,\n        video: int | list[int] | None = -1,\n        audio: int | list[int] | None = -1,\n        subtitles: int | list[int] | None = -1,\n        keep_attachments: bool = True,\n        mkvmerge_args: str | list[str] = \"--no-global-tags\",\n        assume_absolute: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Custom Track object to arbitrarily grab tracks from an existing file.\n\n        For all track params:\n        `None` means there won't be any chosen and `-1` means all will be chosen.\n        You can also specify a single or multiple *relative* track numbers to choose any.\n\n        :param video:               Video Track(s) to choose\n        :param audio:               Audio Track(s) to choose\n        :param subtitles:           Subtitle Track(s) to choose\n        :param keep_attachments:    Whether to keep attachments from the file. Fonts for example.\n        :param mkvmerge_args:       Any other args you may want to pass.\n        :param assume_absolute:     Assume that the track numbers passed were already absolute to begin with.\n                                    If False it will simply get absolute numbers derived from the relative ones.\n        \"\"\"\n        args = \"\"\n        parsed = ParsedFile.from_file(file, self)\n        if video is None:\n            args += \" -D\"\n        elif video != -1:\n            if not isinstance(video, list):\n                video = [video]\n            lv = []\n            for num in video:\n                abso = parsed.find_tracks(relative_id=num, type=TrackType.VIDEO, error_if_empty=True)[0].index if not assume_absolute else num\n                lv.append(abso)\n            args += f\" -d {','.join(str(i) for i in lv)}\"\n\n        if audio is None:\n            args += \" -A\"\n        elif audio != -1:\n            if not isinstance(audio, list):\n                audio = [audio]\n            la = []\n            for num in audio:\n                abso = parsed.find_tracks(relative_id=num, type=TrackType.AUDIO, error_if_empty=True)[0].index if not assume_absolute else num\n                la.append(abso)\n            args += f\" -a {','.join(str(i) for i in la)}\"\n\n        if subtitles is None:\n            args += \" -S\"\n        elif subtitles != -1:\n            if not isinstance(subtitles, list):\n                subtitles = [subtitles]\n            ls = []\n            for num in subtitles:\n                abso = parsed.find_tracks(relative_id=num, type=TrackType.SUB, error_if_empty=True)[0].index if not assume_absolute else num\n                ls.append(abso)\n            args += f\" -s {','.join(str(i) for i in ls)}\"\n\n        if not keep_attachments:\n            args += \" -M\"\n\n        args = split_args(args.strip())\n        mkvmerge_args = split_args(mkvmerge_args.strip()) if isinstance(mkvmerge_args, str) else mkvmerge_args\n        super().__init__(file, TrackType.MKV, args=args + mkvmerge_args)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.args","title":"<code>args = args</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.default","title":"<code>default = default</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.delay","title":"<code>delay = file.container_delay if isinstance(file, MuxingFile) else delay</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.file","title":"<code>file = ensure_path_exists(file, self)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.forced","title":"<code>forced = forced</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.lang","title":"<code>lang = lang</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.tags","title":"<code>tags = tags</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.type","title":"<code>type = type if isinstance(type, TrackType) else TrackType(type) if isinstance(type, int) else TrackType[type.upper()]</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.__init__","title":"<code>__init__(file, video=-1, audio=-1, subtitles=-1, keep_attachments=True, mkvmerge_args='--no-global-tags', assume_absolute=False)</code>","text":"<p>Custom Track object to arbitrarily grab tracks from an existing file.</p> <p>For all track params: <code>None</code> means there won't be any chosen and <code>-1</code> means all will be chosen. You can also specify a single or multiple relative track numbers to choose any.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>int | list[int] | None</code> <p>Video Track(s) to choose</p> <code>-1</code> <code>audio</code> <code>int | list[int] | None</code> <p>Audio Track(s) to choose</p> <code>-1</code> <code>subtitles</code> <code>int | list[int] | None</code> <p>Subtitle Track(s) to choose</p> <code>-1</code> <code>keep_attachments</code> <code>bool</code> <p>Whether to keep attachments from the file. Fonts for example.</p> <code>True</code> <code>mkvmerge_args</code> <code>str | list[str]</code> <p>Any other args you may want to pass.</p> <code>'--no-global-tags'</code> <code>assume_absolute</code> <code>bool</code> <p>Assume that the track numbers passed were already absolute to begin with. If False it will simply get absolute numbers derived from the relative ones.</p> <code>False</code> Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def __init__(\n    self,\n    file: PathLike | GlobSearch,\n    video: int | list[int] | None = -1,\n    audio: int | list[int] | None = -1,\n    subtitles: int | list[int] | None = -1,\n    keep_attachments: bool = True,\n    mkvmerge_args: str | list[str] = \"--no-global-tags\",\n    assume_absolute: bool = False,\n) -&gt; None:\n    \"\"\"\n    Custom Track object to arbitrarily grab tracks from an existing file.\n\n    For all track params:\n    `None` means there won't be any chosen and `-1` means all will be chosen.\n    You can also specify a single or multiple *relative* track numbers to choose any.\n\n    :param video:               Video Track(s) to choose\n    :param audio:               Audio Track(s) to choose\n    :param subtitles:           Subtitle Track(s) to choose\n    :param keep_attachments:    Whether to keep attachments from the file. Fonts for example.\n    :param mkvmerge_args:       Any other args you may want to pass.\n    :param assume_absolute:     Assume that the track numbers passed were already absolute to begin with.\n                                If False it will simply get absolute numbers derived from the relative ones.\n    \"\"\"\n    args = \"\"\n    parsed = ParsedFile.from_file(file, self)\n    if video is None:\n        args += \" -D\"\n    elif video != -1:\n        if not isinstance(video, list):\n            video = [video]\n        lv = []\n        for num in video:\n            abso = parsed.find_tracks(relative_id=num, type=TrackType.VIDEO, error_if_empty=True)[0].index if not assume_absolute else num\n            lv.append(abso)\n        args += f\" -d {','.join(str(i) for i in lv)}\"\n\n    if audio is None:\n        args += \" -A\"\n    elif audio != -1:\n        if not isinstance(audio, list):\n            audio = [audio]\n        la = []\n        for num in audio:\n            abso = parsed.find_tracks(relative_id=num, type=TrackType.AUDIO, error_if_empty=True)[0].index if not assume_absolute else num\n            la.append(abso)\n        args += f\" -a {','.join(str(i) for i in la)}\"\n\n    if subtitles is None:\n        args += \" -S\"\n    elif subtitles != -1:\n        if not isinstance(subtitles, list):\n            subtitles = [subtitles]\n        ls = []\n        for num in subtitles:\n            abso = parsed.find_tracks(relative_id=num, type=TrackType.SUB, error_if_empty=True)[0].index if not assume_absolute else num\n            ls.append(abso)\n        args += f\" -s {','.join(str(i) for i in ls)}\"\n\n    if not keep_attachments:\n        args += \" -M\"\n\n    args = split_args(args.strip())\n    mkvmerge_args = split_args(mkvmerge_args.strip()) if isinstance(mkvmerge_args, str) else mkvmerge_args\n    super().__init__(file, TrackType.MKV, args=args + mkvmerge_args)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Premux.mkvmerge_args","title":"<code>mkvmerge_args()</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def mkvmerge_args(self) -&gt; list[str]:\n    filepath = str(self.file.resolve())\n    if self.type == TrackType.ATTACHMENT:\n        is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n        if not is_font and not self.lang:\n            raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n        if not is_font:\n            args = [\"--attachment-mime-type\", self.lang]\n        else:\n            args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n        if self.name:\n            args.extend([\"--attachment-name\", self.name])\n\n        args.extend([\"--attach-file\", filepath])\n        return args\n\n    elif self.type == TrackType.MKV:\n        return [*self.args, filepath]\n    elif self.type == TrackType.CHAPTERS:\n        return [\"--chapters\", filepath]\n\n    args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n    if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n        tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n        create_tags_xml(tags_file, self.tags)\n        args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n    if self.lang:\n        args.extend([\"--language\", f\"0:{self.lang}\"])\n    if self.delay:\n        args.extend([\"--sync\", f\"0:{self.delay}\"])\n    args.extend(\n        [\n            \"--default-track-flag\",\n            f\"0:{'yes' if self.default else 'no'}\",\n            \"--forced-display-flag\",\n            f\"0:{'yes' if self.forced else 'no'}\",\n        ]\n    )\n    if self.args:\n        args.extend(self.args)\n    args.append(filepath)\n    return args\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>_track</code></p> <p>pseudo _track object for attachments</p> Source code in <code>           muxtools/muxing/tracks.py         </code> <pre><code>class Attachment(_track):\n    \"\"\"\n    pseudo _track object for attachments\n    \"\"\"\n\n    def __init__(self, file: str | Path, mimetype: str = \"\", name: str = \"\") -&gt; None:\n        super().__init__(file, TrackType.ATTACHMENT, lang=mimetype, name=name)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.args","title":"<code>args = args</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.default","title":"<code>default = default</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.delay","title":"<code>delay = file.container_delay if isinstance(file, MuxingFile) else delay</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.file","title":"<code>file = ensure_path_exists(file, self)</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.forced","title":"<code>forced = forced</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.lang","title":"<code>lang = lang</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.tags","title":"<code>tags = tags</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.type","title":"<code>type = type if isinstance(type, TrackType) else TrackType(type) if isinstance(type, int) else TrackType[type.upper()]</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.__init__","title":"<code>__init__(file, mimetype='', name='')</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def __init__(self, file: str | Path, mimetype: str = \"\", name: str = \"\") -&gt; None:\n    super().__init__(file, TrackType.ATTACHMENT, lang=mimetype, name=name)\n</code></pre>"},{"location":"muxtools/muxing/tracks/#muxtools.muxing.tracks.Attachment.mkvmerge_args","title":"<code>mkvmerge_args()</code>","text":"Source code in <code>         muxtools/muxing/tracks.py       </code> <pre><code>def mkvmerge_args(self) -&gt; list[str]:\n    filepath = str(self.file.resolve())\n    if self.type == TrackType.ATTACHMENT:\n        is_font = self.file.suffix.lower() in [\".ttf\", \".otf\", \".ttc\", \".otc\"]\n        if not is_font and not self.lang:\n            raise ValueError(\"Please specify a mimetype for the attachments if they're not fonts!\")\n        if not is_font:\n            args = [\"--attachment-mime-type\", self.lang]\n        else:\n            args = [\"--attachment-mime-type\", \"application/x-truetype-font\"]\n        if self.name:\n            args.extend([\"--attachment-name\", self.name])\n\n        args.extend([\"--attach-file\", filepath])\n        return args\n\n    elif self.type == TrackType.MKV:\n        return [*self.args, filepath]\n    elif self.type == TrackType.CHAPTERS:\n        return [\"--chapters\", filepath]\n\n    args = [\"--no-global-tags\", \"--track-name\", f\"0:{self.name}\"]\n\n    if self.tags and not all([not bool(v) for _, v in self.tags.items()]):\n        tags_file = make_output(self.file, \"xml\", \"_tags\", temp=True)\n        create_tags_xml(tags_file, self.tags)\n        args.extend([\"--tags\", f\"0:{str(tags_file)}\"])\n\n    if self.lang:\n        args.extend([\"--language\", f\"0:{self.lang}\"])\n    if self.delay:\n        args.extend([\"--sync\", f\"0:{self.delay}\"])\n    args.extend(\n        [\n            \"--default-track-flag\",\n            f\"0:{'yes' if self.default else 'no'}\",\n            \"--forced-display-flag\",\n            f\"0:{'yes' if self.forced else 'no'}\",\n        ]\n    )\n    if self.args:\n        args.extend(self.args)\n    args.append(filepath)\n    return args\n</code></pre>"},{"location":"muxtools/subtitle/basesub/","title":"basesub","text":""},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line","title":"<code>_Line</code>","text":"Source code in <code>           muxtools/subtitle/basesub.py         </code> <pre><code>class _Line:\n    TYPE: str\n    \"\"\"The type of line. Should either be `Dialogue` or `Comment`.\"\"\"\n    layer: int\n    \"\"\"An integer value in the range `[0, 2\u00b3\u00b9-1]`. Events with a lower Layer value are placed behind events with a higher value.\"\"\"\n    start: timedelta\n    \"\"\"Start of this line as a timedelta.\"\"\"\n    end: timedelta\n    \"\"\"End of this line as a timedelta.\"\"\"\n    style: str\n    \"\"\"Style name used for this line. Must exactly match one of the styles in your subtitle file.\"\"\"\n    name: str\n    \"\"\"Usually used for what character is currently speaking. Known as `Actor` in aegisub.\"\"\"\n    margin_l: int\n    \"\"\"Left margin overriding the value in the current style.\"\"\"\n    margin_r: int\n    \"\"\"Right margin overriding the value in the current style.\"\"\"\n    margin_v: int\n    \"\"\"Vertical margin overriding the value in the current style.\"\"\"\n    effect: str\n    \"\"\"A legacy effect to be applied to the event. Can usually also be used as another freeform field.\"\"\"\n    text: str\n    \"\"\"The text displayed (or not, if this is a Comment)\"\"\"\n</code></pre>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.TYPE","title":"<code>TYPE</code>  <code>instance-attribute</code>","text":"<p>The type of line. Should either be <code>Dialogue</code> or <code>Comment</code>.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.effect","title":"<code>effect</code>  <code>instance-attribute</code>","text":"<p>A legacy effect to be applied to the event. Can usually also be used as another freeform field.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.end","title":"<code>end</code>  <code>instance-attribute</code>","text":"<p>End of this line as a timedelta.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.layer","title":"<code>layer</code>  <code>instance-attribute</code>","text":"<p>An integer value in the range <code>[0, 2\u00b3\u00b9-1]</code>. Events with a lower Layer value are placed behind events with a higher value.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.margin_l","title":"<code>margin_l</code>  <code>instance-attribute</code>","text":"<p>Left margin overriding the value in the current style.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.margin_r","title":"<code>margin_r</code>  <code>instance-attribute</code>","text":"<p>Right margin overriding the value in the current style.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.margin_v","title":"<code>margin_v</code>  <code>instance-attribute</code>","text":"<p>Vertical margin overriding the value in the current style.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>Usually used for what character is currently speaking. Known as <code>Actor</code> in aegisub.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.start","title":"<code>start</code>  <code>instance-attribute</code>","text":"<p>Start of this line as a timedelta.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.style","title":"<code>style</code>  <code>instance-attribute</code>","text":"<p>Style name used for this line. Must exactly match one of the styles in your subtitle file.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub._Line.text","title":"<code>text</code>  <code>instance-attribute</code>","text":"<p>The text displayed (or not, if this is a Comment)</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ShiftMode","title":"<code>ShiftMode</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>           muxtools/subtitle/basesub.py         </code> <pre><code>class ShiftMode(Enum):\n    FRAME = \"frame\"\n    \"\"\"Shift lines by converting everything (including the offset) to a frame.\"\"\"\n    TIME = \"time\"\n    \"\"\"Shift lines directly by using the offset as a timedelta.\\nYou have to use this if you want to match subKT.\"\"\"\n</code></pre>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ShiftMode.FRAME","title":"<code>FRAME = 'frame'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shift lines by converting everything (including the offset) to a frame.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ShiftMode.TIME","title":"<code>TIME = 'time'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shift lines directly by using the offset as a timedelta. You have to use this if you want to match subKT.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader","title":"<code>ASSHeader</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Basic enum class for some functional ASS headers.</p> <p>Check https://github.com/libass/libass/wiki/ASS-File-Format-Guide for more information on each member.</p> <p>Also contains the function to validate the input.</p> Source code in <code>           muxtools/subtitle/basesub.py         </code> <pre><code>class ASSHeader(IntEnum):\n    \"\"\"\n    Basic enum class for some functional ASS headers.\\n\n    Check https://github.com/libass/libass/wiki/ASS-File-Format-Guide for more information on each member.\n\n    Also contains the function to validate the input.\n    \"\"\"\n\n    LayoutResX = 1\n    \"\"\"Video width this subtitle was originally authored on.\"\"\"\n    LayoutResY = 2\n    \"\"\"Video height this subtitle was originally authored on.\"\"\"\n    PlayResX = 3\n    \"\"\"Video width this subtitle is used on.\"\"\"\n    PlayResY = 4\n    \"\"\"Video height this subtitle is used on.\"\"\"\n    WrapStyle = 5\n    \"\"\"The default line-wrapping behaviour.\"\"\"\n    ScaledBorderAndShadow = 6\n    \"\"\"Scale border and shadow with playback resolution. Should ideally always be yes.\"\"\"\n    YCbCr_Matrix = 7\n    \"\"\"The color range and matrix this subtitle was authored for.\"\"\"\n\n    def validate_input(self, value: str | int | bool | None, caller: Any = None) -&gt; str | int | None:\n        if self in range(1, 6) and not isinstance(value, int) and value is not None:\n            raise error(f\"{self.name} needs to be an integer!\", caller)\n        if self == 5 and value not in range(3) and value is not None:\n            raise error(f\"The valid values for {self.name} are 0, 1 and 2.\", caller)\n\n        if self == 6 and value is not None:\n            if not isinstance(value, bool) and str(value).lower() not in [\"yes\", \"no\"]:\n                raise error(f\"The valid values for {self.name} are 'yes', 'no' or a boolean with the same meaning.\", caller)\n            if str(value).lower() == \"no\" or value is False:\n                warn(f\"There's practically no good reason for {self.name} to be 'no'. Carry on if you are sure.\", caller, 1)\n            if isinstance(value, bool):\n                return \"yes\" if value else \"no\"\n            return str(value).lower()\n\n        if self == 7 and value is not None:\n            if not isinstance(value, str):\n                raise error(f\"{self.name} needs to be a string!\", caller)\n            if not value.startswith((\"TV.\", \"PC.\")):\n                raise error(f\"{self.name} needs to start with a range value of either 'TV' or 'PC'!\", caller)\n            known_matrices = [\"601\", \"709\", \"240M\", \"FCC\"]\n            contains_known = False\n            for matrix in known_matrices:\n                if matrix in value:\n                    contains_known = True\n            if not contains_known:\n                joined = \", \".join(known_matrices)\n                warn(f\"{self.name} doesn't contain a known valid matrix! ({joined})\", caller, 1)\n\n        return value\n</code></pre>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.LayoutResX","title":"<code>LayoutResX = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Video width this subtitle was originally authored on.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.LayoutResY","title":"<code>LayoutResY = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Video height this subtitle was originally authored on.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.PlayResX","title":"<code>PlayResX = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Video width this subtitle is used on.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.PlayResY","title":"<code>PlayResY = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Video height this subtitle is used on.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.ScaledBorderAndShadow","title":"<code>ScaledBorderAndShadow = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Scale border and shadow with playback resolution. Should ideally always be yes.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.WrapStyle","title":"<code>WrapStyle = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The default line-wrapping behaviour.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.ASSHeader.YCbCr_Matrix","title":"<code>YCbCr_Matrix = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color range and matrix this subtitle was authored for.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.BaseSubFile","title":"<code>BaseSubFile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code>, <code>MuxingFile</code></p> <p>A base class for the SubFile class.</p> <p>Mostly contains the functions to read/write the file and some commonly reused functions to manipulate headers/lines.</p> Source code in <code>           muxtools/subtitle/basesub.py         </code> <pre><code>class BaseSubFile(ABC, MuxingFile):\n    \"\"\"\n    A base class for the SubFile class.\\n\n    Mostly contains the functions to read/write the file and some commonly reused functions to manipulate headers/lines.\n    \"\"\"\n\n    def _read_doc(self, file: PathLike | None = None) -&gt; Document:\n        with open(self.file if not file else file, \"r\", encoding=self.encoding) as reader:\n            doc = parseDoc(reader)\n            self.__fix_style_definition(doc)\n            return doc\n\n    def _update_doc(self, doc: Document):\n        with open(self.file, \"w\", encoding=self.encoding) as writer:\n            doc.dump_file(writer)\n\n    def __fix_style_definition(self, doc: Document):\n        fields: list[str] = doc.styles.field_order\n        valid_casing = [\n            \"Name\",\n            \"Fontname\",\n            \"Fontsize\",\n            \"PrimaryColour\",\n            \"SecondaryColour\",\n            \"OutlineColour\",\n            \"BackColour\",\n            \"Bold\",\n            \"Italic\",\n            \"Underline\",\n            \"StrikeOut\",\n            \"ScaleX\",\n            \"ScaleY\",\n            \"Spacing\",\n            \"Angle\",\n            \"BorderStyle\",\n            \"Outline\",\n            \"Shadow\",\n            \"Alignment\",\n            \"MarginL\",\n            \"MarginR\",\n            \"MarginV\",\n            \"Encoding\",\n        ]\n\n        for i, f in enumerate(fields):\n            for valid in valid_casing:\n                if f.casefold() == valid.casefold():\n                    fields[i] = valid\n                    break\n\n        setattr(doc.styles, \"field_order\", fields)\n\n    def manipulate_lines(self, func: Callable[[list[_Line]], list[_Line] | None]) -&gt; None:\n        doc = self._read_doc()\n        returned = func(doc.events)  # type: ignore\n        if returned:\n            doc.events = returned\n        self._update_doc(doc)\n\n    def _warn_mismatched_properties(self, doc: Document, other: Document, doc_name: str, other_name: str) -&gt; None:\n        keys_to_check = [\"PlayResX\", \"PlayResY\", \"YCbCr Matrix\", \"LayoutResX\", \"LayoutResY\"]\n        for key in keys_to_check:\n            doc_value = doc.info.get(key, None)\n            other_value = other.info.get(key, None)\n            if doc_value != other_value:\n                if not doc_value or not other_value:\n                    if not doc_value:\n                        warn(f\"The {key} header is not set in '{doc_name}'.\", self)\n                    else:\n                        warn(f\"The {key} header is not set in '{other_name}'.\", self)\n                else:\n                    danger(f\"The {key} header is set to {doc_value} in '{doc_name}' and {other_value} in '{other_name}'!\", self)\n\n    def _shift_line_by_time(self, line: _Line, offset: timedelta, oob_mode: OutOfBoundsMode = OutOfBoundsMode.ERROR) -&gt; ShiftResult:\n        new_line = deepcopy(line)\n        outofbounds = False\n        new_line.start = new_line.start + offset\n        new_line.end = new_line.end + offset\n        if new_line.start &lt; timedelta(0) or new_line.end &lt; timedelta(0):\n            outofbounds = True\n            match oob_mode:\n                case OutOfBoundsMode.ERROR:\n                    raise error(f\"Line is out of bounds: {line.start} - {line.end}\\n{line.text}\")\n                case OutOfBoundsMode.MAX_TO_ZERO:\n                    new_line.start = timedelta(0)\n                    if new_line.end &lt; timedelta(0):\n                        new_line.end = timedelta(0)\n                case _:\n                    new_line.start = timedelta(0)\n                    new_line.end = timedelta(0)\n        return ShiftResult(new_line, outofbounds)\n\n    def _shift_line_by_frames(\n        self, line: _Line, offset: int, timestamps: ABCTimestamps, oob_mode: OutOfBoundsMode = OutOfBoundsMode.ERROR\n    ) -&gt; ShiftResult:\n        outofbounds = False\n        start_frame = timestamps.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n        new_start_frame = start_frame + offset\n\n        end_ms = int(line.end.total_seconds() * 1000)\n        if end_ms &lt;= timestamps.first_timestamps:\n            end_frame = new_start_frame\n        else:\n            end_frame = timestamps.time_to_frame(end_ms, TimeType.END, 3)\n\n        new_end_frame = end_frame + offset\n\n        if new_start_frame &lt; 0 or new_end_frame &lt; 0:\n            outofbounds = True\n            match oob_mode:\n                case OutOfBoundsMode.ERROR:\n                    raise error(f\"Line is out of bounds: {line.start} - {line.end}:\\n\\t{line.text}\")\n                case OutOfBoundsMode.MAX_TO_ZERO:\n                    new_start_frame = 0\n                    if new_end_frame &lt; 0:\n                        new_end_frame = 0\n                case _:\n                    new_start_frame = 0\n                    new_end_frame = 0\n\n        start = timestamps.frame_to_time(new_start_frame, TimeType.START, 2, True)\n\n        if new_end_frame &gt; 0:\n            end = timestamps.frame_to_time(new_end_frame, TimeType.END, 2, True)\n        else:\n            end = timestamps.frame_to_time(new_end_frame, TimeType.START, 2, True)\n\n        new_line = deepcopy(line)\n        new_line.start = timedelta(milliseconds=start * 10)\n        new_line.end = timedelta(milliseconds=end * 10)\n        return ShiftResult(new_line, outofbounds)\n\n    def set_header(self, header: str | ASSHeader, value: str | int | bool | None, opened_doc: None | Document = None) -&gt; None:\n        doc = opened_doc or self._read_doc()\n        functional_headers = ASSHeader._member_map_.items()\n        section: dict = doc.sections[\"Script Info\"]\n        if isinstance(header, str):\n            corr = [\n                head\n                for name, head in functional_headers\n                if name.casefold() == header.casefold() or name.replace(\"_\", \" \").casefold() == header.casefold()\n            ]\n            if corr:\n                corr = ASSHeader(corr[0])\n                value = corr.validate_input(value, \"SubFile.set_header\")\n                if value is None and corr.name != \"YCbCr_Matrix\":\n                    section.pop(corr.name)\n                section.update({corr.name.replace(\"_\", \" \"): str(value)})\n            else:\n                if value is None:\n                    section.pop(header, None)\n                else:\n                    section.update({header: str(value)})\n        else:\n            value = header.validate_input(value, \"SubFile.set_header\")\n            if value is None and header.name != \"YCbCr_Matrix\":\n                if header.name in section.keys():\n                    section.pop(header.name)\n            else:\n                section.update({header.name.replace(\"_\", \" \"): str(value)})\n\n        if not opened_doc:\n            self._update_doc(doc)\n</code></pre>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.OutOfBoundsMode","title":"<code>OutOfBoundsMode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>How lines that are below 0 after shifting/merging should be handled</p> Source code in <code>           muxtools/subtitle/basesub.py         </code> <pre><code>class OutOfBoundsMode(IntEnum):\n    \"\"\"How lines that are below 0 after shifting/merging should be handled\"\"\"\n\n    ERROR = 0\n    \"\"\"Raise an error\"\"\"\n    SET_TO_ZERO = 1\n    \"\"\"Set both start and end to 0. Essentially disabling the line.\"\"\"\n    MAX_TO_ZERO = 2\n    \"\"\"Set the start to 0 and the end to what it would be after shifting or also 0 if also below 0.\"\"\"\n    DROP_LINE = 3\n    \"\"\"Don't include the line in the output at all.\"\"\"\n</code></pre>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.OutOfBoundsMode.DROP_LINE","title":"<code>DROP_LINE = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Don't include the line in the output at all.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.OutOfBoundsMode.ERROR","title":"<code>ERROR = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Raise an error</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.OutOfBoundsMode.MAX_TO_ZERO","title":"<code>MAX_TO_ZERO = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set the start to 0 and the end to what it would be after shifting or also 0 if also below 0.</p>"},{"location":"muxtools/subtitle/basesub/#muxtools.subtitle.basesub.OutOfBoundsMode.SET_TO_ZERO","title":"<code>SET_TO_ZERO = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set both start and end to 0. Essentially disabling the line.</p>"},{"location":"muxtools/subtitle/styles/","title":"styles","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.AMAZON_EMBER_PRESET","title":"<code>AMAZON_EMBER_PRESET = [amazon_ember_default, *(get_complimenting_styles(amazon_ember_default))]</code>  <code>module-attribute</code>","text":"<p>https://developer.amazon.com/en-US/alexa/branding/echo-guidelines/identity-guidelines/typography</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.CABINF_PRESET","title":"<code>CABINF_PRESET = [cabinf_default, *(get_complimenting_styles(cabinf_default))]</code>  <code>module-attribute</code>","text":"<p>A custom Cabin variant with adjusted font size and margins and an em dash closer to Gandhi Sans.</p> <p>Made by RaptoR.</p> <p>From what I know there's no \"official\" page for this. You can download it here.</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.CABIN_PRESET","title":"<code>CABIN_PRESET = [cabin_default, *(get_complimenting_styles(cabin_default))]</code>  <code>module-attribute</code>","text":"<p>https://fonts.google.com/specimen/Cabin</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.FIRA_PRESET","title":"<code>FIRA_PRESET = [fira_default, *(get_complimenting_styles(fira_default))]</code>  <code>module-attribute</code>","text":"<p>Fira Sans Medium preset. https://fonts.google.com/specimen/Fira+Sans</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.GJM_GANDHI_PRESET","title":"<code>GJM_GANDHI_PRESET = [gandhi_default, *(get_complimenting_styles(gandhi_default))]</code>  <code>module-attribute</code>","text":"<p>A GandhiSans-Bold preset. The font is commonly used by GJM and MTBB and a few other groups. https://www.fontsquirrel.com/fonts/gandhi-sans</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.LATO_PRESET","title":"<code>LATO_PRESET = [lato_default, *(get_complimenting_styles(lato_default))]</code>  <code>module-attribute</code>","text":"<p>https://fonts.google.com/specimen/Lato</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.LTF_PRESET","title":"<code>LTF_PRESET = [ltf_default, *(get_complimenting_styles(ltf_default))]</code>  <code>module-attribute</code>","text":"<p>LinotypeFinnegan Medium preset. The font is commonly used by Commie and Kaleido.</p> <p>It's, apparently, technically a paid font,  but you can probably find it in a bunch of github repos or in the attachments of plenty of releases.</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.MERRIWEATHER_PRESET","title":"<code>MERRIWEATHER_PRESET = [merriweather_default, *(get_complimenting_styles(merriweather_default))]</code>  <code>module-attribute</code>","text":"<p>https://fonts.google.com/specimen/Merriweather</p>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.__all__","title":"<code>__all__ = ['gandhi_default', 'GJM_GANDHI_PRESET', 'cabin_default', 'CABIN_PRESET', 'cabinf_default', 'CABINF_PRESET', 'lato_default', 'LATO_PRESET', 'merriweather_default', 'MERRIWEATHER_PRESET', 'amazon_ember_default', 'AMAZON_EMBER_PRESET', 'ltf_default', 'LTF_PRESET', 'fira_default', 'FIRA_PRESET', 'edit_style', 'resize_preset', 'default_style_args', 'get_complimenting_styles']</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.amazon_ember_default","title":"<code>amazon_ember_default = Style(name='Default', fontname='Amazon Ember', fontsize=78.0, outline=3.5, shadow=1.3, margin_l=180, margin_r=180, margin_v=55, **default_style_args)</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.cabin_default","title":"<code>cabin_default = Style(name='Default', fontname='Cabin', fontsize=85.0, outline=3.2, shadow=1.5, margin_l=180, margin_r=180, margin_v=50, **default_style_args)</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.cabinf_default","title":"<code>cabinf_default = edit_style(cabin_default, 'Default', fontname='Cabin F', fontsize=75.0, margin_v=55)</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.default_style_args","title":"<code>default_style_args = {'bold': True, 'italic': False, 'underline': False, 'strike_out': False, 'scale_x': 100.0, 'scale_y': 100.0, 'spacing': 0.0, 'angle': 0.0, 'encoding': 1, 'alignment': 2, 'border_style': 1, 'primary_color': Color(r=255, g=255, b=255, a=0), 'secondary_color': Color(r=255, g=0, b=0, a=0), 'outline_color': Color(r=0, g=0, b=0, a=0), 'back_color': Color(r=0, g=0, b=0, a=160)}</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.fira_default","title":"<code>fira_default = Style(name='Default', fontname='Fira Sans Medium', fontsize=70.0, outline=3.6, shadow=2.5, margin_l=185, margin_r=185, margin_v=56, **(default_style_args | dict(bold=False, scale_x=103.0)))</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.gandhi_default","title":"<code>gandhi_default = Style(name='Default', fontname='Gandhi Sans', fontsize=75.0, outline=3.6, shadow=1.5, margin_l=180, margin_r=180, margin_v=55, **default_style_args)</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.lato_default","title":"<code>lato_default = Style(name='Default', fontname='Lato', fontsize=75.0, outline=3.2, shadow=1.5, margin_l=180, margin_r=180, margin_v=55, **default_style_args)</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.ltf_default","title":"<code>ltf_default = Style(name='Default', fontname='LTFinnegan Medium', fontsize=72.0, outline=3.6, shadow=1.5, margin_l=185, margin_r=185, margin_v=60, **(default_style_args | dict(bold=False)))</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.merriweather_default","title":"<code>merriweather_default = Style(name='Default', fontname='Merriweather', fontsize=78.0, outline=3.3, shadow=1.5, margin_l=180, margin_r=180, margin_v=55, **default_style_args)</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.edit_style","title":"<code>edit_style</code>","text":"<p>Copies a style to set a new name and other arguments via kwargs</p> Source code in <code>         muxtools/subtitle/styles.py       </code> <pre><code>def edit_style(style: Style, name: str, **kwargs) -&gt; Style:\n    \"\"\"\n    Copies a style to set a new name and other arguments via kwargs\n    \"\"\"\n    style = deepcopy(style)\n    style.name = name\n    for key, val in kwargs.items():\n        setattr(style, key, val)\n    return style\n</code></pre>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.get_complimenting_styles","title":"<code>get_complimenting_styles</code>","text":"<p>Generates colored Alt/Overlap and Flashback styles for a given style.</p> Source code in <code>         muxtools/subtitle/styles.py       </code> <pre><code>def get_complimenting_styles(style: Style) -&gt; list[Style]:\n    \"\"\"\n    Generates colored Alt/Overlap and Flashback styles for a given style.\n    \"\"\"\n    return [\n        edit_style(style, \"Overlap\", outline_color=Color(r=0x15, g=0x3E, b=0x74, a=0x00)),\n        edit_style(style, \"Alt\", outline_color=Color(r=0x15, g=0x3E, b=0x74, a=0x00)),\n        edit_style(style, \"Flashback\", outline_color=Color(r=0x12, g=0x3E, b=0x01, a=0x00)),\n    ]\n</code></pre>"},{"location":"muxtools/subtitle/styles/#muxtools.subtitle.styles.resize_preset","title":"<code>resize_preset</code>","text":"<p>Resize a list of styles to match a resolution.</p> <p>This assumes the passed styles are for a 1080p script.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <code>list[Style]</code> <p>List of styles to resize</p> required <code>target_height</code> <code>int | Document</code> <p>Either a height integer or an ass document to get the height from</p> <code>360</code> <p>Returns:</p> Type Description <code>list[Style]</code> <p>A list of deepcopied styles. This doesn't edit the input styles.</p> Source code in <code>         muxtools/subtitle/styles.py       </code> <pre><code>def resize_preset(preset: list[Style], target_height: int | Document = 360) -&gt; list[Style]:\n    \"\"\"\n    Resize a list of styles to match a resolution.\\n\n    This assumes the passed styles are for a 1080p script.\n\n    :param preset:          List of styles to resize\n    :param target_height:   Either a height integer or an ass document to get the height from\n\n    :return:                A list of deepcopied styles. This doesn't edit the input styles.\n    \"\"\"\n    if isinstance(target_height, Document):\n        target_height = int(target_height.info.get(\"PlayResY\", 360))\n\n    styles = list[Style]()\n    multiplier = target_height / 1080\n    for style in preset:\n        style = deepcopy(style)\n        setattr(style, \"fontsize\", int(getattr(style, \"fontsize\", 75.0) * multiplier))\n        setattr(style, \"margin_l\", int(getattr(style, \"margin_l\", 180) * multiplier))\n        setattr(style, \"margin_r\", int(getattr(style, \"margin_r\", 180) * multiplier))\n        setattr(style, \"margin_v\", int(getattr(style, \"margin_v\", 55) * multiplier))\n        setattr(style, \"shadow\", round(getattr(style, \"shadow\", 1.5) * multiplier, 1))\n        setattr(style, \"outline\", round(getattr(style, \"outline\", 3.2) * multiplier, 1))\n        styles.append(style)\n    return styles\n</code></pre>"},{"location":"muxtools/subtitle/sub/","title":"sub","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.DEFAULT_DIALOGUE_STYLES","title":"<code>DEFAULT_DIALOGUE_STYLES = ['default', 'main', 'alt', 'overlap', 'flashback', 'top', 'italics']</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.LINES","title":"<code>LINES = list[_Line]</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SRT_REGEX","title":"<code>SRT_REGEX = '\\\\d+[\\\\r\\\\n](?:(?P&lt;start&gt;\\\\d+:\\\\d+:\\\\d+,\\\\d+) --&gt; (?P&lt;end&gt;\\\\d+:\\\\d+:\\\\d+,\\\\d+))[\\\\r\\\\n](?P&lt;text&gt;(?:.+\\\\r?\\\\n)+(?=(\\\\r?\\\\n)?))'</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.__all__","title":"<code>__all__ = ['FontFile', 'SubFile', 'DEFAULT_DIALOGUE_STYLES']</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.FontFile","title":"<code>FontFile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MuxingFile</code></p> Source code in <code>           muxtools/subtitle/sub.py         </code> <pre><code>@dataclass\nclass FontFile(MuxingFile):\n    pass\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.FontFile.__init__","title":"<code>__init__(file, container_delay=0, source=None, tags=None)</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile","title":"<code>SubFile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseSubFile</code></p> <p>Utility class representing an ASS/SSA subtitle file with various functions to run on.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | list[PathLike] | GlobSearch</code> <p>Can be a string, Path object or GlobSearch. If the GlobSearch returns multiple results or if a list was passed it will merge them.</p> required <code>container_delay</code> <code>int</code> <p>Set a container delay used in the muxing process later.</p> <code>0</code> <code>source</code> <code>PathLike | None</code> <p>The file this sub originates from, will be set by the constructor.</p> <code>None</code> <code>encoding</code> <p>Encoding used for reading and writing the subtitle files.</p> required Source code in <code>           muxtools/subtitle/sub.py         </code> <pre><code>@dataclass\nclass SubFile(BaseSubFile):\n    \"\"\"\n    Utility class representing an ASS/SSA subtitle file with various functions to run on.\n\n    :param file:            Can be a string, Path object or GlobSearch.\n                            If the GlobSearch returns multiple results or if a list was passed it will merge them.\n\n    :param container_delay: Set a container delay used in the muxing process later.\n    :param source:          The file this sub originates from, will be set by the constructor.\n    :param encoding:        Encoding used for reading and writing the subtitle files.\n    \"\"\"\n\n    encoding = \"utf_8_sig\"\n\n    def __post_init__(self):\n        if isinstance(self.file, GlobSearch):\n            self.file = self.file.paths\n\n        if isinstance(self.file, list) and len(self.file) &gt; 1:\n            debug(\"Merging sub files...\", self)\n            docs: list[Document] = []\n            for i, f in enumerate(self.file):\n                f = ensure_path_exists(f, self)\n                with open(f, \"r\", encoding=self.encoding) as read:\n                    doc = parseDoc(read)\n                    docs.append(doc)\n                    if i != 0:\n                        self._warn_mismatched_properties(docs[0], doc, ensure_path(self.file[0], self).name, f.name)\n\n            main = docs[0]\n            existing_styles = [style.name for style in (main.styles)]\n            docs.remove(main)\n\n            for doc in docs:\n                main.events.extend(doc.events)\n                for style in doc.styles:\n                    if style.name.casefold() in [s.casefold() for s in existing_styles]:\n                        warn(f\"Ignoring style '{style.name}' due to preexisting style of the same name.\", self)\n                        continue\n                    main.styles.append(style)\n\n            self.source = self.file[0]\n            out = make_output(self.file[0], \"ass\", \"merged\")\n            with open(out, \"w\", encoding=self.encoding) as writer:\n                main.dump_file(writer)\n\n            self.file = out\n            debug(\"Done\")\n        else:\n            self.file = ensure_path_exists(self.file, self)\n            self.source = self.file\n            if not os.path.samefile(self.file.parent, get_workdir()):\n                out = make_output(self.file, \"ass\", \"vof\")\n                with open(out, \"w\", encoding=self.encoding) as writer:\n                    self._read_doc().dump_file(writer)\n                self.file = out\n\n    def manipulate_lines(self, func: Callable[[LINES], LINES | None]) -&gt; Self:\n        \"\"\"\n        Function to manipulate any lines.\n\n        :param func:        Your own function you want to run on the list of lines.\n                            This can return a new list or just edit the one passed into it.\n        \"\"\"\n        super().manipulate_lines(func)\n        return self\n\n    def set_header(self, header: str | ASSHeader, value: str | int | bool | None) -&gt; Self:\n        \"\"\"\n        A function to add headers to the \"Script Info\" section of the subtitle file.\n        This will validate the input for known functional headers but also allows arbitrary ones.\n        If you're planning on setting multiple at the same time, use the `set_headers` function instead to avoid a lot of I/O.\n\n        :param header:      The name of the header or a header chosen from the enum.\n        :param value:       The value of the header. None will remove the header unless it's the Matrix header because None has a meaning there.\n        \"\"\"\n        super().set_header(header, value)\n        return self\n\n    def set_headers(self, *headers: tuple[str | ASSHeader, str | int | bool | None]) -&gt; Self:\n        \"\"\"\n        A function to add headers to the \"Script Info\" section of the subtitle file.\n        This will validate the input for known functional headers but also allows arbitrary ones.\n\n        :param headers:     Any amount of tuples with the same typing as the single header function.\n        \"\"\"\n        doc = self._read_doc()\n        for header, value in headers:\n            super().set_header(header, value, doc)\n        self._update_doc(doc)\n        return self\n\n    def clean_styles(self) -&gt; Self:\n        \"\"\"\n        Deletes unused styles from the document.\n        \"\"\"\n        doc = self._read_doc()\n        used_styles = {line.style for line in doc.events if line.TYPE == \"Dialogue\"}\n        regex = re.compile(r\"\\{[^}]*\\\\r([^\\\\}]+)[^}]*\\}\")\n        for line in [line for line in doc.events if line.TYPE == \"Dialogue\"]:\n            for match in regex.finditer(line.text):\n                used_styles.add(match.group(1))\n        doc.styles = [style for style in doc.styles if style.name in used_styles]\n        self._update_doc(doc)\n        return self\n\n    def clean_garbage(self) -&gt; Self:\n        \"\"\"\n        Removes the \"Aegisub Project Garbage\" section from the file.\n        \"\"\"\n        doc = self._read_doc()\n        doc.sections.pop(\"Aegisub Project Garbage\", None)\n        self._update_doc(doc)\n        return self\n\n    def clean_extradata(self) -&gt; Self:\n        \"\"\"\n        Removes the \"Aegisub Extradata\" section from the file.\n        \"\"\"\n        doc = self._read_doc()\n        doc.sections.pop(\"Aegisub Extradata\", None)\n        self._update_doc(doc)\n        return self\n\n    def clean_comments(self) -&gt; Self:\n        \"\"\"\n        Removes all comment lines from the file.\n        \"\"\"\n        return self.manipulate_lines(lambda lines: list(filter(lambda line: str(line.TYPE).lower() != \"comment\", lines)))\n\n    def autoswapper(\n        self,\n        allowed_styles: list[str] | None = DEFAULT_DIALOGUE_STYLES,\n        print_swaps: bool = False,\n        inline_marker: str = \"*\",\n        line_marker: str = \"***\",\n        inline_tag_markers: str | None = None,\n    ) -&gt; Self:\n        r\"\"\"\n        autoswapper allows replacing text in the script with a different text.\n        Useful for creating honorific tracks.\n\n        Assuming the markers are as default:\n\n        - `{*}abc{*def}` becomes `{*}def{*abc}` (AB Swap)\n        - `abc{**def}` becomes `abc{*}def{*}` (Show Word)\n        - `abc{*}def{*}` becomes `abc{**def}` (Hide Word)\n\n        Note: AB Swap and Hide Word will remove `{}` from the swapped text, to ensure the comment isn't broken.\n\n        You can also comment in or out entire lines by using the line marker in either the `effect` or `name` field.\n        - A dialogue line with effect or name set to `***` will be commented.\n        - A comment line with effect or name set to `***` will be set to a dialogue.\n\n\n        `inline_tag_markers` can be used to swap ASS tags as well. Keep in mind that \"\\\" and \"/\" will be swapped, so override tags aren't applied.\n\n        Assuming the markers are as default, except inline_tag_markers = `[]`:\n        - `{*}{\\i1}abc{*[/b1]def}` becomes `{*}{\\b1}def{*[/i1]abc}` (AB Swap)\n        - `abc{**[/b1]def}` becomes `abc{*}{\\b1}def{*}` (Show Word)\n        - `abc{*}{\\b1}def{*}` becomes `abc{**[/b1]def}` (Hide Word)\n\n\n        :param allowed_styles:          List of allowed styles to do the swapping on\n                                        Will run on every line if passed `None`\n        :param print_swaps:             Prints the swaps\n        :param inline_marker:           Marker to use for inline swaps.\n                                        Should be one character. Default `*`\n        :param line_marker:             Marker to use for full-line swaps. Default `***`\n        :param inline_tag_markers:      Two characters that will be replaced with `{}` respectively in the inline swaps.\n                                        Defaults to `None`, which will just remove the `{}` from the swapped text.\n\n        :return:                        This SubTrack\n        \"\"\"\n        if not isinstance(inline_marker, str) or not inline_marker.strip():\n            warn(\"Given invalid inline marker. Using default '*'.\", self)\n            inline_marker = \"*\"\n\n        if not isinstance(line_marker, str) or not line_marker.strip():\n            warn(\"Given invalid line marker. Using default '***'.\", self)\n            line_marker = \"***\"\n\n        if inline_tag_markers:\n            if len(inline_tag_markers) != 2 or inline_tag_markers[0] == inline_tag_markers[1] or any([m in \"{}\" for m in inline_tag_markers]):\n                warn(\"Given invalid inline comment markers. Using default 'None'.\", self)\n                inline_tag_markers = None\n\n        marker = re.escape(inline_marker)\n\n        ab_swap_regex = re.compile(rf\"{{{marker}}}(.*?){{{marker}([^}}]+)}}\")\n        show_word_regex = re.compile(rf\"{{{marker}{marker}([^}}]+)}}\")\n        hide_word_regex = re.compile(rf\"{{{marker}}}(.*?){{{marker} *}}\")\n\n        backslash = \"\\\\\"  # This is to ensure support for previous python versions that don't allow backslashes in f-strings.\n\n        def _do_autoswap(lines: LINES):\n            for i, line in enumerate(lines):\n                if not allowed_styles or str(line.style).casefold() in {style.casefold() for style in allowed_styles}:\n                    to_swap: dict = {}\n                    # {*}This will be replaced{*With this}\n                    for match in re.finditer(ab_swap_regex, line.text):\n                        if inline_tag_markers:\n                            to_swap.update(\n                                {\n                                    f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(2).replace(inline_tag_markers[0], '{').replace(inline_tag_markers[1], '}').replace('/', backslash)}{{{inline_marker}{match.group(1).replace('{', inline_tag_markers[0]).replace('}', inline_tag_markers[1]).replace(backslash, '/')}}}\"\n                                }\n                            )\n                        else:\n                            to_swap.update(\n                                {\n                                    f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(2)}{{{inline_marker}{match.group(1).replace('{', '').replace('}', '')}}}\"\n                                }\n                            )\n\n                    # This sentence is no longer{** incomplete}\n                    for match in re.finditer(show_word_regex, line.text):\n                        if inline_tag_markers:\n                            to_swap.update(\n                                {\n                                    f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(1).replace(inline_tag_markers[0], '{').replace(inline_tag_markers[1], '}').replace('/', backslash)}{{{inline_marker}}}\"\n                                }\n                            )\n                        else:\n                            to_swap.update({f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(1)}{{{inline_marker}}}\"})\n\n                    # This sentence is no longer{*} complete{*}\n                    for match in re.finditer(hide_word_regex, line.text):\n                        if inline_tag_markers:\n                            to_swap.update(\n                                {\n                                    f\"{match.group(0)}\": f\"{{{inline_marker * 2}{match.group(1).replace('{', inline_tag_markers[0]).replace('}', inline_tag_markers[1]).replace(backslash, '/')}}}\"\n                                }\n                            )\n                        else:\n                            to_swap.update({f\"{match.group(0)}\": f\"{{{inline_marker * 2}{match.group(1).replace('{', '').replace('}', '')}}}\"})\n\n                    for key, val in to_swap.items():\n                        if print_swaps:\n                            info(f'autoswapper: Swapped \"{log_escape(key)}\" for \"{log_escape(val)}\" on line {i}', self)\n                        line.text = line.text.replace(key, val)\n\n                    if line.effect.strip() == line_marker or line.name.strip() == line_marker:\n                        if isinstance(line, Comment):\n                            line.TYPE = \"Dialogue\"\n                            if print_swaps:\n                                info(f'autoswapper: Uncommented Line {i} - \"{log_escape(line.text)}\"', self)\n                        elif isinstance(line, Dialogue):\n                            line.TYPE = \"Comment\"\n                            if print_swaps:\n                                info(f'autoswapper: Commented Line {i} - \"{log_escape(line.text)}\"', self)\n\n        self.manipulate_lines(_do_autoswap)\n        return self\n\n    def unfuck_cr(\n        self,\n        default_style: str = \"Default\",\n        keep_flashback: bool = True,\n        dialogue_styles: list[str] | None = [\"main\", \"default\", \"narrator\", \"narration\"],\n        top_styles: list[str] | None = [\"top\"],\n        italics_styles: list[str] | None = [\"italics\", \"internal\"],\n        alt_style: str = \"Alt\",\n        alt_styles: list[str] | None = None,\n    ) -&gt; Self:\n        \"\"\"\n        Removes any top and italics styles and replaces them with tags.\n\n        :param default_style:       The default style that everything will be set to\n        :param keep_flashback:      If not it will set the flashback styles to default_style\n        :param dialogue_styles:     Styles that will be set to default_style\n        :param top_styles:          Styles that will be set to default_style and an8 added to tags\n        :param italics_styles:      Styles that will be set to default_style and i1 added to tags\n        :param alt_style:           The default alt/overlap style that lines will be set to\n        :param alt_styles:          Possible identifiers for styles that should be set to the alt_style\n        \"\"\"\n\n        def get_default(line: _Line, allow_default: bool = True) -&gt; str:\n            placeholder = default_style\n            is_default = True\n            if alt_styles:\n                for s in alt_styles:\n                    if s.casefold() in line.style.casefold():\n                        placeholder = alt_style\n                        is_default = False\n            if \"flashback\" in line.style.lower():\n                return placeholder if not keep_flashback else \"Flashback\"\n\n            if is_default:\n                return placeholder if allow_default else line.style\n\n            return placeholder\n\n        def _func(lines: LINES):\n            for line in lines:\n                add_italics_tag = italics_styles and bool([s for s in italics_styles if s.casefold() in line.style.casefold()])\n                add_top_tag = top_styles and bool([s for s in top_styles if s.casefold() in line.style.casefold()])\n\n                if any([add_italics_tag, add_top_tag]):\n                    line.style = get_default(line)\n                    tags = \"\" if not add_italics_tag else R\"\\i1\"\n                    tags = tags if not add_top_tag else tags + R\"\\an8\"\n                    line.text = f\"{{{tags}}}{line.text}\"\n\n                line.style = get_default(line, False)\n\n                if dialogue_styles:\n                    for s in dialogue_styles:\n                        if s.casefold() in line.style.casefold():\n                            line.style = default_style\n\n        return self.manipulate_lines(_func).clean_styles()\n\n    def shift_0(\n        self,\n        timesource: TimeSourceT = None,\n        timescale: TimeScaleT = None,\n        allowed_styles: list[str] | None = DEFAULT_DIALOGUE_STYLES,\n    ) -&gt; Self:\n        \"\"\"\n        Does the famous shift by 0 frames to fix frame timing issues.\n        (It's basically just converting time to frame and back)\n\n        This does not currently exactly reproduce the aegisub behaviour but it should have the same effect.\n\n        :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n        :param allowed_styles:  A list of style names this will run on. Will run on every line if None.\n        \"\"\"\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n\n        def _func(lines: LINES):\n            for line in lines:\n                if not allowed_styles or line.style.lower() in allowed_styles:\n                    result = self._shift_line_by_frames(line, 0, resolved_ts, OutOfBoundsMode.ERROR)\n                    line = result.line\n\n        return self.manipulate_lines(_func)\n\n    def merge(\n        self,\n        file: PathLike | GlobSearch,\n        sync: None | int | str = None,\n        sync2: None | str = None,\n        timesource: TimeSourceT = None,\n        timescale: TimeScaleT = None,\n        use_actor_field: bool = False,\n        no_error: bool = False,\n        sort_lines: bool = False,\n        shift_mode: ShiftMode = ShiftMode.FRAME,\n        oob_mode: OutOfBoundsMode = OutOfBoundsMode.ERROR,\n    ) -&gt; Self:\n        \"\"\"\n        Merge another subtitle file with syncing if needed.\n\n        :param file:            The file to be merged.\n        :param sync:            Can be None to not adjust timing at all, an int for a frame number or a string for a syncpoint name.\n        :param sync2:           The syncpoint you want to use for the second file.\n                                This is needed if you specified a frame for sync and still want to use a specific syncpoint.\n        :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n        :param use_actor_field: Checks the actor field instead of effect for the names if True.\n        :param no_error:        Don't error and warn instead if syncpoint not found.\n        :param sort_lines:      Sort the lines by the starting timestamp.\n                                This was done by default before but may cause issues with subtitles relying on implicit layering.\n        :param shift_mode:      Choose what to shift by. Defaults to shifting by frames.\n        :param oob_mode:        What to do with lines that are out of bounds after shifting.\n        \"\"\"\n        if sync is not None or sync2 is not None and shift_mode == ShiftMode.FRAME:\n            resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n\n        file = ensure_path_exists(file, self)\n        mergedoc = self._read_doc(file)\n        doc = self._read_doc()\n        doc_name = ensure_path_exists(self.file, self).name if str(self.source).lower().endswith(\".mkv\") else ensure_path(self.source, self).name\n        self._warn_mismatched_properties(doc, mergedoc, doc_name, file.name)\n\n        events = []\n        tomerge = []\n        existing_styles = [style.name for style in doc.styles]\n        target = None if not isinstance(sync, int) else sync\n\n        # Find syncpoint in current document if sync is a string\n        for line in doc.events:\n            events.append(line)\n            line = cast(_Line, line)\n            if target is None and isinstance(sync, str):\n                field = line.name if use_actor_field else line.effect\n                if field.lower().strip() == sync.lower().strip() or line.text.lower().strip() == sync.lower().strip():\n                    if shift_mode == ShiftMode.FRAME:\n                        target = resolved_ts.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n                    else:\n                        target = line.start\n\n        if target is None and isinstance(sync, str):\n            msg = f\"Syncpoint '{sync}' was not found.\"\n            if no_error:\n                warn(msg, self)\n                return self\n            raise error(msg, self)\n\n        mergedoc.events = cast(list[_Line], mergedoc.events)\n\n        # Find second syncpoint if any\n        second_sync: int | timedelta | None = None\n        for line in mergedoc.events:\n            if not isinstance(sync, str) and not sync2:\n                break\n            else:\n                sync2 = sync2 or sync\n            field = line.name if use_actor_field else line.effect\n            if field.lower().strip() == sync2.lower().strip() or line.text.lower().strip() == sync2.lower().strip():\n                if shift_mode == ShiftMode.FRAME:\n                    second_sync = resolved_ts.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n                else:\n                    second_sync = line.start\n                mergedoc.events.remove(line)\n                break\n\n        sorted_lines = sorted(mergedoc.events, key=lambda event: event.start)\n\n        # Assume the first line to be the second syncpoint if none was found\n        if second_sync is None and target is not None:\n            for line in filter(lambda event: event.TYPE != \"Comment\", sorted_lines):\n                if shift_mode == ShiftMode.FRAME:\n                    second_sync = resolved_ts.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n                else:\n                    second_sync = line.start\n                break\n\n        # Merge lines from file\n        for line in sorted_lines if sort_lines else mergedoc.events:\n            # Don't apply any offset if sync=None for plain merging or if target == source\n            if target is None or target == second_sync:\n                tomerge.append(line)\n                continue\n\n            if shift_mode == ShiftMode.FRAME:\n                assert isinstance(target, int)\n                assert isinstance(second_sync, int)\n                offset = target - second_sync\n                line_result = self._shift_line_by_frames(line, offset, resolved_ts, oob_mode)\n            else:\n                assert isinstance(target, timedelta)\n                assert isinstance(second_sync, timedelta)\n                offset = target - second_sync\n                line_result = self._shift_line_by_time(line, offset, oob_mode)\n\n            if line_result.was_out_of_bounds:\n                warn(f\"Line is out of bounds: {line.start} - {line.end}:\\n\\t{line.text}\", self)\n                if oob_mode == OutOfBoundsMode.DROP_LINE:\n                    continue\n\n            tomerge.append(line_result.line)\n\n        if tomerge:\n            events.extend(tomerge)\n            doc.events = events\n            for style in mergedoc.styles:\n                if style.name in existing_styles:\n                    continue\n                doc.styles.append(style)\n\n        self._update_doc(doc)\n        return self\n\n    def collect_fonts(\n        self,\n        use_system_fonts: bool = True,\n        search_current_dir: bool = True,\n        additional_fonts: list[PathLike] = [],\n        collect_draw_fonts: bool = True,\n        error_missing: bool = False,\n        use_ntfs_compliant_names: bool | None = None,\n    ) -&gt; list[FontFile]:\n        \"\"\"\n        Collects fonts for current subtitle.\n        Note that this places all fonts into the workdir for the episode/Setup and all fonts in it.\n\n        :param use_system_fonts:            Parses and checks against all installed fonts\n        :param search_current_dir:          Recursively checks the current work directory for fonts\n        :param additional_fonts:            Can be a directory or a path to a file directly (or a list of either)\n        :param collect_draw_fonts:          Whether or not to include fonts used for drawing (usually Arial)\n                                            See https://github.com/libass/libass/issues/617 for details.\n        :param error_missing:               Raise an error instead of just warnings when a font is missing.\\n\n                                            This is **deprecated** and will be removed at some point in the future.\n                                            Please use `error_on_danger` in the Setup.\n        :param use_ntfs_compliant_names:    Ensure that filenames will work on a NTFS (Windows) filesystem.\n                                            The `None` default means it'll use them but only if you're running the script on windows.\n\n        :return:                        A list of FontFile objects\n        \"\"\"\n\n        if not isinstance(additional_fonts, list):\n            additional_fonts = [additional_fonts]\n\n        if search_current_dir:\n            additional_fonts.append(os.getcwd())\n\n        resolved_paths: list[Path] = []\n\n        for f in additional_fonts:\n            f = ensure_path_exists(f, self, True)\n            if f.is_dir():\n                resolved_paths.extend([file for file in f.rglob(\"*.[tT][tT][fF]\")])\n                resolved_paths.extend([file for file in f.rglob(\"*.[oO][tT][fF]\")])\n                resolved_paths.extend([file for file in f.rglob(\"*.[tT][tT][cC]\")])\n                resolved_paths.extend([file for file in f.rglob(\"*.[oO][tT][cC]\")])\n            else:\n                if f.suffix.lower() not in [\".ttf\", \".otf\", \".ttc\", \".otc\"]:\n                    raise error(f\"'{f.name}' is not a font!\", self)\n                resolved_paths.append(f)\n        from .font import collect_fonts as collect\n\n        info(f\"Collecting fonts for '{self.file.stem}'...\", self)\n\n        if error_missing:\n            warn(\"The 'error_missing' parameter is deprecated.\\nPlease use the 'error_on_danger' variable on the Setup.\", self, 1)\n\n        if use_ntfs_compliant_names is None:\n            use_ntfs_compliant_names = os.name == \"nt\"\n\n        return collect(self, use_system_fonts, resolved_paths, collect_draw_fonts, error_missing, use_ntfs_compliant_names)\n\n    def restyle(self, styles: Style | list[Style], clean_after: bool = True, delete_existing: bool = False, adjust_styles: bool = True) -&gt; Self:\n        \"\"\"\n        Add (and replace existing) styles to the subtitle file.\n\n        :param styles:          Either a single or a list of ass Styles\n        :param clean_after:     Clean unused styles after\n        :param delete_existing: Delete all existing styles before adding new ones\n        :param adjust_styles:   Resize the styles to match the script resolution.\n                                This assumes 1080p for the actual style res as all the presets are that.\n        \"\"\"\n        if not isinstance(styles, list):\n            styles = [styles]\n\n        styles = styles.copy()\n\n        doc = self._read_doc()\n        script_res = int(doc.info.get(\"PlayResY\", 360))\n        if script_res != 1080 and adjust_styles:\n            styles = resize_preset(styles, script_res)\n\n        if delete_existing:\n            doc.styles = []\n\n        names = [style.name.casefold() for style in styles]\n        existing = [style for style in doc.styles if style.name.casefold() not in names]\n        styles.extend(existing)\n        doc.styles = styles\n\n        self._update_doc(doc)\n        if clean_after:\n            return self.clean_styles()\n        else:\n            return self\n\n    def resample(\n        self,\n        video: PathLike | None = None,\n        src_width: int | None = None,\n        src_height: int | None = None,\n        use_arch: bool | None = None,\n        quiet: bool = True,\n    ) -&gt; Self:\n        \"\"\"\n        Resample subtitles to match the resolution of the specified video.\n\n        :param video:           Path to a video. Will resort to a 1080p dummy video if None.\n        :param src_width:       The width of the resolution the subs are currently at\n        :param src_height:      The height of the resolution the subs are currently at\n                                Both of the above params will be taken from the sub file if not given.\n                                (Assuming 640 x 360 if nothing is given in the document)\n\n        :param use_arch:        Uses arch1t3cht's perspective resampler script to fix any perspective stuff after resampling.\n                                This requires arch.Resample.moon in either of your autoload folders.\n                                None means it will use it if it can find the script. True will try to force it.\n        \"\"\"\n        aegicli = get_executable(\"aegisub-cli\", False)\n        video = dummy_video(1920, 1080) if not video else ensure_path_exists(video, self)\n        doc = self._read_doc()\n\n        if not src_width:\n            src_width = doc.info.get(\"PlayResX\", 640)\n\n        if not src_height:\n            src_height = doc.info.get(\"PlayResY\", 360)\n\n        if use_arch is None:\n            use_arch = has_arch_resampler()\n\n        output = Path(get_temp_workdir(), f\"{self.file.stem}_resampled.ass\")\n        args = [aegicli, \"--video\", str(video.resolve()), str(self.file.resolve()), str(output), \"tool/resampleres\"]\n        if run_commandline(args, quiet):\n            raise error(\"Failed to resample subtitles!\", self)\n\n        if use_arch:\n            prevout = output\n            output = Path(get_temp_workdir(), f\"{self.file.stem}_resampled_arch.ass\")\n\n            # fmt: off\n            dialog_json = json.dumps({\"button\": 0, \"values\": {\"srcresx\": src_width, \"srcresy\": src_height, \"centerorg\": \"false\"}})\n            args = [aegicli, \"--video\", str(video.resolve()), \"--dialog\", dialog_json, \"--automation\", \"arch.Resample.moon\", str(prevout), str(output), \"Resample Perspective\"]\n            # fmt: on\n            if run_commandline(args, quiet):\n                raise error(\"Failed to resample perspective of subtitles!\", self)\n\n        self.file.unlink(True)\n        self.file = shutil.copy(output, self.file)\n        clean_temp_files()\n        return self\n\n    def separate_signs(\n        self, styles: list[str] = DEFAULT_DIALOGUE_STYLES, inverse: bool = False, heuristics: bool = False, print_heuristics: bool = True\n    ) -&gt; Self:\n        \"\"\"\n        Basically deletes lines that have any of the passed styles.\n\n        :param styles:      List of style names to get rid of\n        :param inverse:     Treat the list as the opposite. Will remove lines that *don't* have any of those styles.\n        :param heuristics:  Also use heuristics for detecting signs.\n        \"\"\"\n\n        def _is_sign(line: _Line) -&gt; bool:\n            confidence = 0\n            style_check = False\n            if styles and (line.style.casefold() not in [str(style).casefold() for style in styles]):\n                style_check = True\n                confidence += 2\n\n            if heuristics and confidence &lt; 2:\n                if line.name:\n                    if \"onscreen\" in line.name.lower().replace(\" \", \"\") or line.name.lower() == \"type\" or line.name.lower() == \"sign\":\n                        confidence += 1\n\n                if R\"\\pos\" in line.text:\n                    confidence += 1\n                if R\"\\mov\" in line.text:\n                    confidence += 1\n                if R\"\\fn\" in line.text:\n                    confidence += 1\n                if R\"\\blur\" in line.text or R\"\\be\" in line.text:\n                    confidence += 1\n\n                an_types = [Rf\"\\an{num}\" for num in range(1, 10) if num not in (2, 8)]\n                for an in an_types:\n                    if an in line.text:\n                        confidence += 1\n                        break\n                if print_heuristics and confidence &gt;= 2 and not style_check:  # and styles:\n                    info(f\"Line with dialogue style passed heuristics:\\n{line.text}\", self)\n\n            return confidence &gt;= 2\n\n        def filter_lines(lines: LINES):\n            events = []\n            for line in lines:\n                skip = not inverse\n                if _is_sign(line):\n                    skip = inverse\n\n                if skip:\n                    continue\n                events.append(line)\n            return events\n\n        return self.manipulate_lines(filter_lines).clean_styles()\n\n    def change_layers(self, styles: list[str] = DEFAULT_DIALOGUE_STYLES, layer: int | None = None, additive: bool = True) -&gt; Self:\n        \"\"\"\n        Set layer to the specified number or adds the number to the existing one on every line with a style you selected.\n\n        :param styles:      List of styles to look for.\n        :param layer:       The layer you want. Defaults to 50 for additive and 99 otherwise.\n        :param additive:    Add specified layer number instead of replacing the existing one.\n        \"\"\"\n        if not layer:\n            layer = 50 if additive else 99\n\n        def _func(lines: LINES):\n            for line in lines:\n                for style in styles:\n                    if str(line.style).strip().casefold() == style.strip().casefold():\n                        line.layer = layer if not additive else line.layer + layer\n\n        return self.manipulate_lines(_func)\n\n    def purge_macrons(self, styles: list[str] | None = DEFAULT_DIALOGUE_STYLES) -&gt; Self:\n        \"\"\"\n        Removes romaji macrons from every dialogue line.\n        German subs use this a lot and a lot of fonts don't support it, so I like to purge them.\n\n        :param styles:      List of styles to look for\n        \"\"\"\n        macrons: list[tuple[str, str]] = [(\"\u0101\", \"a\"), (\"\u0113\", \"e\"), (\"\u012b\", \"i\"), (\"\u014d\", \"o\"), (\"\u016b\", \"u\")]\n\n        def _func(lines: LINES):\n            for line in lines:\n                process = not styles\n                for style in styles or []:\n                    if str(line.style).strip().casefold() == style.strip().casefold():\n                        process = True\n                if process:\n                    for macron in macrons + [(m[0].upper(), m[1].upper()) for m in macrons]:\n                        line.text = line.text.replace(macron[0], macron[1])\n\n        return self.manipulate_lines(_func)\n\n    def shift(\n        self,\n        frames: int,\n        timesource: TimeSourceT = None,\n        timescale: TimeScaleT = None,\n        oob_mode: OutOfBoundsMode = OutOfBoundsMode.ERROR,\n    ) -&gt; Self:\n        \"\"\"\n        Shifts all lines by any frame number.\n\n        :param frames:              Number of frames to shift by\n        :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                    For details check the docstring on the type.\n        :param oob_mode:            What to do with lines that are out of bounds after shifting.\n        \"\"\"\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n\n        def shift_lines(lines: LINES):\n            new_list = list[_Line]()\n            for line in lines:\n                line_result = self._shift_line_by_frames(line, frames, resolved_ts, oob_mode)\n\n                if line_result.was_out_of_bounds:\n                    warn(f\"Line is out of bounds: {line.start} - {line.end}:\\n\\t{line.text}\", self)\n                    if oob_mode == OutOfBoundsMode.DROP_LINE:\n                        continue\n\n                new_list.append(line_result.line)\n            return new_list\n\n        return self.manipulate_lines(shift_lines)\n\n    def copy(self, filename: PathLike = None) -&gt; Self:\n        \"\"\"\n        Creates a new copy of the current SubFile object, including its file.\n        So you can run anything on the new one without impacting the other one.\n\n        :param filename:    Use a specific filename for this copy. Don't include an extension.\n                            If this is a dir it will have the same name and be placed in the dir.\n\n        :return:            A new SubFile instance\n        \"\"\"\n        doc = self._read_doc()\n\n        new_path = ensure_path(uniquify_path(self.file), self)\n        if filename:\n            new_path = make_output(self.file, \"ass\", user_passed=filename)\n\n        with open(new_path, \"w\", encoding=self.encoding) as writer:\n            doc.dump_file(writer)\n\n        new = self.__class__(new_path, self.container_delay, self.source)\n        new.encoding = self.encoding\n        return new\n\n    @classmethod\n    def from_srt(\n        cls: type[Self],\n        file: PathLike,\n        an8_all_caps: bool = True,\n        style_all_caps: bool = True,\n        timesource: TimeSourceT = Fraction(24000, 1001),\n        timescale: TimeScaleT = TimeScale.MKV,\n        encoding: str = \"UTF8\",\n    ) -&gt; Self:\n        \"\"\"\n        Convert srt subtitles to an ass SubFile.\n        Automatically applies Gandhi styling. Feel free to restyle.\n        Also worth noting that this creates a file that assumes 1920x1080. Use the resample function if you need something else.\n\n        :param file:            Input srt file\n        :param an8_all_caps:    Automatically an8 every full caps line with over 7 characters because they're usually signs.\n        :param style_all_caps:  Also set the style of these lines to \"Sign\" wether it exists or not.\n        :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n        :param encoding:        Encoding used to read the file. Defaults to UTF8.\n        \"\"\"\n        caller = \"SubFile.from_srt\"\n        file = ensure_path_exists(file, caller)\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, caller=cls)\n\n        compiled = re.compile(SRT_REGEX, re.MULTILINE)\n\n        def srt_timedelta(timestamp: str, time_type: TimeType) -&gt; timedelta:\n            args = timestamp.split(\",\")[0].split(\":\")\n            parsed = timedelta(hours=int(args[0]), minutes=int(args[1]), seconds=int(args[2]), milliseconds=int(timestamp.split(\",\")[1]))\n            cope = resolved_ts.time_to_frame(int(parsed.total_seconds() * 1000), time_type, 3)\n            cope = resolved_ts.frame_to_time(cope, time_type, 3, True)\n            return timedelta(milliseconds=cope)\n\n        def convert_tags(text: str) -&gt; tuple[str, bool]:\n            text = text.strip().replace(\"\\n\", \"\\\\N\")\n            is_sign = False\n            if an8_all_caps and text.upper() == text and len(text) &gt; 7:\n                text = R\"{\\an8}\" + text\n                is_sign = True\n            text = re.sub(r\"[\\&lt;|{]i[\\&gt;|}]\", R\"{\\\\i1}\", text)\n            text = re.sub(r\"[\\&lt;|{]\\/i[\\&gt;|}]\", R\"{\\\\i}\", text)\n            text = re.sub(r\"[\\&lt;|{]b[\\&gt;|}]\", R\"{\\\\b1}\", text)\n            text = re.sub(r\"[\\&lt;|{]\\/b[\\&gt;|}]\", R\"{\\\\b}\", text)\n            text = re.sub(r\"[\\&lt;|{]u[\\&gt;|}]\", R\"{\\\\u1}\", text)\n            text = re.sub(r\"[\\&lt;|{]\\/u[\\&gt;|}]\", R\"{\\\\u}\", text)\n            return text, is_sign\n\n        doc = create_document()\n\n        with open(file, \"r\", encoding=encoding) as reader:\n            content = reader.read() + \"\\n\"\n            for match in compiled.finditer(content):\n                start = srt_timedelta(match[\"start\"], TimeType.START)\n                end = srt_timedelta(match[\"end\"], TimeType.END)\n                text, sign = convert_tags(match[\"text\"])\n                doc.events.append(Dialogue(layer=99, start=start, end=end, text=text, style=\"Sign\" if sign and style_all_caps else \"Default\"))\n\n        out = file.with_suffix(\".ass\")\n        with open(out, \"w\", encoding=\"utf_8_sig\") as writer:\n            doc.dump_file(writer)\n        out = cls(out, 0, file)\n        return out.restyle(GJM_GANDHI_PRESET)\n\n    @classmethod\n    def from_mkv(cls: type[Self], file: PathLike, track: int = 0, preserve_delay: bool = False, quiet: bool = True, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Extract subtitle from mkv.\\n\n        The track must be either an ASS or SRT subtitle. SRT will be converted automatically.\n\n        :param file:            Input mkv file\n        :param track:           Relative track number\n        :param preserve_delay:  Preserve existing container delay\n        :param kwargs:          Other args to pass to `from_srt` if trying to extract srt subtitles\n        \"\"\"\n        caller = \"SubFile.from_mkv\"\n        file = ensure_path_exists(file, caller)\n        parsed = ParsedFile.from_file(file, caller)\n        parsed_track = parsed.find_tracks(relative_id=track, type=TrackType.SUB, error_if_empty=True, caller=caller)[0]\n\n        if parsed_track.codec_name not in [\"ass\", \"subrip\"]:\n            raise error(\"The selected track is not an ASS or SRT subtitle.\", caller)\n\n        mkvextract = get_executable(\"mkvextract\")\n        out = Path(get_workdir(), f\"{file.stem}_{parsed_track.index}.{'ass' if parsed_track.codec_name == 'ass' else 'srt'}\")\n        args = [mkvextract, str(file), \"tracks\", f\"{parsed_track.index}:{str(out)}\"]\n        if run_commandline(args, quiet):\n            raise error(\"Failed to extract subtitle!\", caller)\n\n        delay = 0 if not preserve_delay else parsed_track.container_delay\n\n        if parsed_track.codec_name == \"subrip\":\n            subfile = cls.from_srt(out, **kwargs)\n            subfile.container_delay = delay\n            subfile.source = file\n            out.unlink(True)\n            return subfile\n\n        return cls(out, delay, file)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.encoding","title":"<code>encoding = 'utf_8_sig'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.__init__","title":"<code>__init__(file, container_delay=0, source=None, tags=None)</code>","text":""},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.__post_init__","title":"<code>__post_init__()</code>","text":"Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def __post_init__(self):\n    if isinstance(self.file, GlobSearch):\n        self.file = self.file.paths\n\n    if isinstance(self.file, list) and len(self.file) &gt; 1:\n        debug(\"Merging sub files...\", self)\n        docs: list[Document] = []\n        for i, f in enumerate(self.file):\n            f = ensure_path_exists(f, self)\n            with open(f, \"r\", encoding=self.encoding) as read:\n                doc = parseDoc(read)\n                docs.append(doc)\n                if i != 0:\n                    self._warn_mismatched_properties(docs[0], doc, ensure_path(self.file[0], self).name, f.name)\n\n        main = docs[0]\n        existing_styles = [style.name for style in (main.styles)]\n        docs.remove(main)\n\n        for doc in docs:\n            main.events.extend(doc.events)\n            for style in doc.styles:\n                if style.name.casefold() in [s.casefold() for s in existing_styles]:\n                    warn(f\"Ignoring style '{style.name}' due to preexisting style of the same name.\", self)\n                    continue\n                main.styles.append(style)\n\n        self.source = self.file[0]\n        out = make_output(self.file[0], \"ass\", \"merged\")\n        with open(out, \"w\", encoding=self.encoding) as writer:\n            main.dump_file(writer)\n\n        self.file = out\n        debug(\"Done\")\n    else:\n        self.file = ensure_path_exists(self.file, self)\n        self.source = self.file\n        if not os.path.samefile(self.file.parent, get_workdir()):\n            out = make_output(self.file, \"ass\", \"vof\")\n            with open(out, \"w\", encoding=self.encoding) as writer:\n                self._read_doc().dump_file(writer)\n            self.file = out\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.autoswapper","title":"<code>autoswapper(allowed_styles=DEFAULT_DIALOGUE_STYLES, print_swaps=False, inline_marker='*', line_marker='***', inline_tag_markers=None)</code>","text":"<p>autoswapper allows replacing text in the script with a different text. Useful for creating honorific tracks.</p> <p>Assuming the markers are as default:</p> <ul> <li><code>{*}abc{*def}</code> becomes <code>{*}def{*abc}</code> (AB Swap)</li> <li><code>abc{**def}</code> becomes <code>abc{*}def{*}</code> (Show Word)</li> <li><code>abc{*}def{*}</code> becomes <code>abc{**def}</code> (Hide Word)</li> </ul> <p>Note: AB Swap and Hide Word will remove <code>{}</code> from the swapped text, to ensure the comment isn't broken.</p> <p>You can also comment in or out entire lines by using the line marker in either the <code>effect</code> or <code>name</code> field. - A dialogue line with effect or name set to <code>***</code> will be commented. - A comment line with effect or name set to <code>***</code> will be set to a dialogue.</p> <p><code>inline_tag_markers</code> can be used to swap ASS tags as well. Keep in mind that \"\\\" and \"/\" will be swapped, so override tags aren't applied.</p> <p>Assuming the markers are as default, except inline_tag_markers = <code>[]</code>: - <code>{*}{\\i1}abc{*[/b1]def}</code> becomes <code>{*}{\\b1}def{*[/i1]abc}</code> (AB Swap) - <code>abc{**[/b1]def}</code> becomes <code>abc{*}{\\b1}def{*}</code> (Show Word) - <code>abc{*}{\\b1}def{*}</code> becomes <code>abc{**[/b1]def}</code> (Hide Word)</p> <p>Parameters:</p> Name Type Description Default <code>allowed_styles</code> <code>list[str] | None</code> <p>List of allowed styles to do the swapping on Will run on every line if passed <code>None</code></p> <code>DEFAULT_DIALOGUE_STYLES</code> <code>print_swaps</code> <code>bool</code> <p>Prints the swaps</p> <code>False</code> <code>inline_marker</code> <code>str</code> <p>Marker to use for inline swaps. Should be one character. Default <code>*</code></p> <code>'*'</code> <code>line_marker</code> <code>str</code> <p>Marker to use for full-line swaps. Default <code>***</code></p> <code>'***'</code> <code>inline_tag_markers</code> <code>str | None</code> <p>Two characters that will be replaced with <code>{}</code> respectively in the inline swaps. Defaults to <code>None</code>, which will just remove the <code>{}</code> from the swapped text.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>This SubTrack</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def autoswapper(\n    self,\n    allowed_styles: list[str] | None = DEFAULT_DIALOGUE_STYLES,\n    print_swaps: bool = False,\n    inline_marker: str = \"*\",\n    line_marker: str = \"***\",\n    inline_tag_markers: str | None = None,\n) -&gt; Self:\n    r\"\"\"\n    autoswapper allows replacing text in the script with a different text.\n    Useful for creating honorific tracks.\n\n    Assuming the markers are as default:\n\n    - `{*}abc{*def}` becomes `{*}def{*abc}` (AB Swap)\n    - `abc{**def}` becomes `abc{*}def{*}` (Show Word)\n    - `abc{*}def{*}` becomes `abc{**def}` (Hide Word)\n\n    Note: AB Swap and Hide Word will remove `{}` from the swapped text, to ensure the comment isn't broken.\n\n    You can also comment in or out entire lines by using the line marker in either the `effect` or `name` field.\n    - A dialogue line with effect or name set to `***` will be commented.\n    - A comment line with effect or name set to `***` will be set to a dialogue.\n\n\n    `inline_tag_markers` can be used to swap ASS tags as well. Keep in mind that \"\\\" and \"/\" will be swapped, so override tags aren't applied.\n\n    Assuming the markers are as default, except inline_tag_markers = `[]`:\n    - `{*}{\\i1}abc{*[/b1]def}` becomes `{*}{\\b1}def{*[/i1]abc}` (AB Swap)\n    - `abc{**[/b1]def}` becomes `abc{*}{\\b1}def{*}` (Show Word)\n    - `abc{*}{\\b1}def{*}` becomes `abc{**[/b1]def}` (Hide Word)\n\n\n    :param allowed_styles:          List of allowed styles to do the swapping on\n                                    Will run on every line if passed `None`\n    :param print_swaps:             Prints the swaps\n    :param inline_marker:           Marker to use for inline swaps.\n                                    Should be one character. Default `*`\n    :param line_marker:             Marker to use for full-line swaps. Default `***`\n    :param inline_tag_markers:      Two characters that will be replaced with `{}` respectively in the inline swaps.\n                                    Defaults to `None`, which will just remove the `{}` from the swapped text.\n\n    :return:                        This SubTrack\n    \"\"\"\n    if not isinstance(inline_marker, str) or not inline_marker.strip():\n        warn(\"Given invalid inline marker. Using default '*'.\", self)\n        inline_marker = \"*\"\n\n    if not isinstance(line_marker, str) or not line_marker.strip():\n        warn(\"Given invalid line marker. Using default '***'.\", self)\n        line_marker = \"***\"\n\n    if inline_tag_markers:\n        if len(inline_tag_markers) != 2 or inline_tag_markers[0] == inline_tag_markers[1] or any([m in \"{}\" for m in inline_tag_markers]):\n            warn(\"Given invalid inline comment markers. Using default 'None'.\", self)\n            inline_tag_markers = None\n\n    marker = re.escape(inline_marker)\n\n    ab_swap_regex = re.compile(rf\"{{{marker}}}(.*?){{{marker}([^}}]+)}}\")\n    show_word_regex = re.compile(rf\"{{{marker}{marker}([^}}]+)}}\")\n    hide_word_regex = re.compile(rf\"{{{marker}}}(.*?){{{marker} *}}\")\n\n    backslash = \"\\\\\"  # This is to ensure support for previous python versions that don't allow backslashes in f-strings.\n\n    def _do_autoswap(lines: LINES):\n        for i, line in enumerate(lines):\n            if not allowed_styles or str(line.style).casefold() in {style.casefold() for style in allowed_styles}:\n                to_swap: dict = {}\n                # {*}This will be replaced{*With this}\n                for match in re.finditer(ab_swap_regex, line.text):\n                    if inline_tag_markers:\n                        to_swap.update(\n                            {\n                                f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(2).replace(inline_tag_markers[0], '{').replace(inline_tag_markers[1], '}').replace('/', backslash)}{{{inline_marker}{match.group(1).replace('{', inline_tag_markers[0]).replace('}', inline_tag_markers[1]).replace(backslash, '/')}}}\"\n                            }\n                        )\n                    else:\n                        to_swap.update(\n                            {\n                                f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(2)}{{{inline_marker}{match.group(1).replace('{', '').replace('}', '')}}}\"\n                            }\n                        )\n\n                # This sentence is no longer{** incomplete}\n                for match in re.finditer(show_word_regex, line.text):\n                    if inline_tag_markers:\n                        to_swap.update(\n                            {\n                                f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(1).replace(inline_tag_markers[0], '{').replace(inline_tag_markers[1], '}').replace('/', backslash)}{{{inline_marker}}}\"\n                            }\n                        )\n                    else:\n                        to_swap.update({f\"{match.group(0)}\": f\"{{{inline_marker}}}{match.group(1)}{{{inline_marker}}}\"})\n\n                # This sentence is no longer{*} complete{*}\n                for match in re.finditer(hide_word_regex, line.text):\n                    if inline_tag_markers:\n                        to_swap.update(\n                            {\n                                f\"{match.group(0)}\": f\"{{{inline_marker * 2}{match.group(1).replace('{', inline_tag_markers[0]).replace('}', inline_tag_markers[1]).replace(backslash, '/')}}}\"\n                            }\n                        )\n                    else:\n                        to_swap.update({f\"{match.group(0)}\": f\"{{{inline_marker * 2}{match.group(1).replace('{', '').replace('}', '')}}}\"})\n\n                for key, val in to_swap.items():\n                    if print_swaps:\n                        info(f'autoswapper: Swapped \"{log_escape(key)}\" for \"{log_escape(val)}\" on line {i}', self)\n                    line.text = line.text.replace(key, val)\n\n                if line.effect.strip() == line_marker or line.name.strip() == line_marker:\n                    if isinstance(line, Comment):\n                        line.TYPE = \"Dialogue\"\n                        if print_swaps:\n                            info(f'autoswapper: Uncommented Line {i} - \"{log_escape(line.text)}\"', self)\n                    elif isinstance(line, Dialogue):\n                        line.TYPE = \"Comment\"\n                        if print_swaps:\n                            info(f'autoswapper: Commented Line {i} - \"{log_escape(line.text)}\"', self)\n\n    self.manipulate_lines(_do_autoswap)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.change_layers","title":"<code>change_layers(styles=DEFAULT_DIALOGUE_STYLES, layer=None, additive=True)</code>","text":"<p>Set layer to the specified number or adds the number to the existing one on every line with a style you selected.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>list[str]</code> <p>List of styles to look for.</p> <code>DEFAULT_DIALOGUE_STYLES</code> <code>layer</code> <code>int | None</code> <p>The layer you want. Defaults to 50 for additive and 99 otherwise.</p> <code>None</code> <code>additive</code> <code>bool</code> <p>Add specified layer number instead of replacing the existing one.</p> <code>True</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def change_layers(self, styles: list[str] = DEFAULT_DIALOGUE_STYLES, layer: int | None = None, additive: bool = True) -&gt; Self:\n    \"\"\"\n    Set layer to the specified number or adds the number to the existing one on every line with a style you selected.\n\n    :param styles:      List of styles to look for.\n    :param layer:       The layer you want. Defaults to 50 for additive and 99 otherwise.\n    :param additive:    Add specified layer number instead of replacing the existing one.\n    \"\"\"\n    if not layer:\n        layer = 50 if additive else 99\n\n    def _func(lines: LINES):\n        for line in lines:\n            for style in styles:\n                if str(line.style).strip().casefold() == style.strip().casefold():\n                    line.layer = layer if not additive else line.layer + layer\n\n    return self.manipulate_lines(_func)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.clean_comments","title":"<code>clean_comments()</code>","text":"<p>Removes all comment lines from the file.</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def clean_comments(self) -&gt; Self:\n    \"\"\"\n    Removes all comment lines from the file.\n    \"\"\"\n    return self.manipulate_lines(lambda lines: list(filter(lambda line: str(line.TYPE).lower() != \"comment\", lines)))\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.clean_extradata","title":"<code>clean_extradata()</code>","text":"<p>Removes the \"Aegisub Extradata\" section from the file.</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def clean_extradata(self) -&gt; Self:\n    \"\"\"\n    Removes the \"Aegisub Extradata\" section from the file.\n    \"\"\"\n    doc = self._read_doc()\n    doc.sections.pop(\"Aegisub Extradata\", None)\n    self._update_doc(doc)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.clean_garbage","title":"<code>clean_garbage()</code>","text":"<p>Removes the \"Aegisub Project Garbage\" section from the file.</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def clean_garbage(self) -&gt; Self:\n    \"\"\"\n    Removes the \"Aegisub Project Garbage\" section from the file.\n    \"\"\"\n    doc = self._read_doc()\n    doc.sections.pop(\"Aegisub Project Garbage\", None)\n    self._update_doc(doc)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.clean_styles","title":"<code>clean_styles()</code>","text":"<p>Deletes unused styles from the document.</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def clean_styles(self) -&gt; Self:\n    \"\"\"\n    Deletes unused styles from the document.\n    \"\"\"\n    doc = self._read_doc()\n    used_styles = {line.style for line in doc.events if line.TYPE == \"Dialogue\"}\n    regex = re.compile(r\"\\{[^}]*\\\\r([^\\\\}]+)[^}]*\\}\")\n    for line in [line for line in doc.events if line.TYPE == \"Dialogue\"]:\n        for match in regex.finditer(line.text):\n            used_styles.add(match.group(1))\n    doc.styles = [style for style in doc.styles if style.name in used_styles]\n    self._update_doc(doc)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.collect_fonts","title":"<code>collect_fonts(use_system_fonts=True, search_current_dir=True, additional_fonts=[], collect_draw_fonts=True, error_missing=False, use_ntfs_compliant_names=None)</code>","text":"<p>Collects fonts for current subtitle. Note that this places all fonts into the workdir for the episode/Setup and all fonts in it.</p> <p>Parameters:</p> Name Type Description Default <code>use_system_fonts</code> <code>bool</code> <p>Parses and checks against all installed fonts</p> <code>True</code> <code>search_current_dir</code> <code>bool</code> <p>Recursively checks the current work directory for fonts</p> <code>True</code> <code>additional_fonts</code> <code>list[PathLike]</code> <p>Can be a directory or a path to a file directly (or a list of either)</p> <code>[]</code> <code>collect_draw_fonts</code> <code>bool</code> <p>Whether or not to include fonts used for drawing (usually Arial) See https://github.com/libass/libass/issues/617 for details.</p> <code>True</code> <code>error_missing</code> <code>bool</code> <p>Raise an error instead of just warnings when a font is missing.  This is deprecated and will be removed at some point in the future. Please use <code>error_on_danger</code> in the Setup.</p> <code>False</code> <code>use_ntfs_compliant_names</code> <code>bool | None</code> <p>Ensure that filenames will work on a NTFS (Windows) filesystem. The <code>None</code> default means it'll use them but only if you're running the script on windows.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[FontFile]</code> <p>A list of FontFile objects</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def collect_fonts(\n    self,\n    use_system_fonts: bool = True,\n    search_current_dir: bool = True,\n    additional_fonts: list[PathLike] = [],\n    collect_draw_fonts: bool = True,\n    error_missing: bool = False,\n    use_ntfs_compliant_names: bool | None = None,\n) -&gt; list[FontFile]:\n    \"\"\"\n    Collects fonts for current subtitle.\n    Note that this places all fonts into the workdir for the episode/Setup and all fonts in it.\n\n    :param use_system_fonts:            Parses and checks against all installed fonts\n    :param search_current_dir:          Recursively checks the current work directory for fonts\n    :param additional_fonts:            Can be a directory or a path to a file directly (or a list of either)\n    :param collect_draw_fonts:          Whether or not to include fonts used for drawing (usually Arial)\n                                        See https://github.com/libass/libass/issues/617 for details.\n    :param error_missing:               Raise an error instead of just warnings when a font is missing.\\n\n                                        This is **deprecated** and will be removed at some point in the future.\n                                        Please use `error_on_danger` in the Setup.\n    :param use_ntfs_compliant_names:    Ensure that filenames will work on a NTFS (Windows) filesystem.\n                                        The `None` default means it'll use them but only if you're running the script on windows.\n\n    :return:                        A list of FontFile objects\n    \"\"\"\n\n    if not isinstance(additional_fonts, list):\n        additional_fonts = [additional_fonts]\n\n    if search_current_dir:\n        additional_fonts.append(os.getcwd())\n\n    resolved_paths: list[Path] = []\n\n    for f in additional_fonts:\n        f = ensure_path_exists(f, self, True)\n        if f.is_dir():\n            resolved_paths.extend([file for file in f.rglob(\"*.[tT][tT][fF]\")])\n            resolved_paths.extend([file for file in f.rglob(\"*.[oO][tT][fF]\")])\n            resolved_paths.extend([file for file in f.rglob(\"*.[tT][tT][cC]\")])\n            resolved_paths.extend([file for file in f.rglob(\"*.[oO][tT][cC]\")])\n        else:\n            if f.suffix.lower() not in [\".ttf\", \".otf\", \".ttc\", \".otc\"]:\n                raise error(f\"'{f.name}' is not a font!\", self)\n            resolved_paths.append(f)\n    from .font import collect_fonts as collect\n\n    info(f\"Collecting fonts for '{self.file.stem}'...\", self)\n\n    if error_missing:\n        warn(\"The 'error_missing' parameter is deprecated.\\nPlease use the 'error_on_danger' variable on the Setup.\", self, 1)\n\n    if use_ntfs_compliant_names is None:\n        use_ntfs_compliant_names = os.name == \"nt\"\n\n    return collect(self, use_system_fonts, resolved_paths, collect_draw_fonts, error_missing, use_ntfs_compliant_names)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.copy","title":"<code>copy(filename=None)</code>","text":"<p>Creates a new copy of the current SubFile object, including its file. So you can run anything on the new one without impacting the other one.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>PathLike</code> <p>Use a specific filename for this copy. Don't include an extension. If this is a dir it will have the same name and be placed in the dir.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new SubFile instance</p> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def copy(self, filename: PathLike = None) -&gt; Self:\n    \"\"\"\n    Creates a new copy of the current SubFile object, including its file.\n    So you can run anything on the new one without impacting the other one.\n\n    :param filename:    Use a specific filename for this copy. Don't include an extension.\n                        If this is a dir it will have the same name and be placed in the dir.\n\n    :return:            A new SubFile instance\n    \"\"\"\n    doc = self._read_doc()\n\n    new_path = ensure_path(uniquify_path(self.file), self)\n    if filename:\n        new_path = make_output(self.file, \"ass\", user_passed=filename)\n\n    with open(new_path, \"w\", encoding=self.encoding) as writer:\n        doc.dump_file(writer)\n\n    new = self.__class__(new_path, self.container_delay, self.source)\n    new.encoding = self.encoding\n    return new\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.from_mkv","title":"<code>from_mkv(file, track=0, preserve_delay=False, quiet=True, **kwargs)</code>  <code>classmethod</code>","text":"<p>Extract subtitle from mkv.</p> <p>The track must be either an ASS or SRT subtitle. SRT will be converted automatically.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Input mkv file</p> required <code>track</code> <code>int</code> <p>Relative track number</p> <code>0</code> <code>preserve_delay</code> <code>bool</code> <p>Preserve existing container delay</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>Other args to pass to <code>from_srt</code> if trying to extract srt subtitles</p> <code>{}</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>@classmethod\ndef from_mkv(cls: type[Self], file: PathLike, track: int = 0, preserve_delay: bool = False, quiet: bool = True, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Extract subtitle from mkv.\\n\n    The track must be either an ASS or SRT subtitle. SRT will be converted automatically.\n\n    :param file:            Input mkv file\n    :param track:           Relative track number\n    :param preserve_delay:  Preserve existing container delay\n    :param kwargs:          Other args to pass to `from_srt` if trying to extract srt subtitles\n    \"\"\"\n    caller = \"SubFile.from_mkv\"\n    file = ensure_path_exists(file, caller)\n    parsed = ParsedFile.from_file(file, caller)\n    parsed_track = parsed.find_tracks(relative_id=track, type=TrackType.SUB, error_if_empty=True, caller=caller)[0]\n\n    if parsed_track.codec_name not in [\"ass\", \"subrip\"]:\n        raise error(\"The selected track is not an ASS or SRT subtitle.\", caller)\n\n    mkvextract = get_executable(\"mkvextract\")\n    out = Path(get_workdir(), f\"{file.stem}_{parsed_track.index}.{'ass' if parsed_track.codec_name == 'ass' else 'srt'}\")\n    args = [mkvextract, str(file), \"tracks\", f\"{parsed_track.index}:{str(out)}\"]\n    if run_commandline(args, quiet):\n        raise error(\"Failed to extract subtitle!\", caller)\n\n    delay = 0 if not preserve_delay else parsed_track.container_delay\n\n    if parsed_track.codec_name == \"subrip\":\n        subfile = cls.from_srt(out, **kwargs)\n        subfile.container_delay = delay\n        subfile.source = file\n        out.unlink(True)\n        return subfile\n\n    return cls(out, delay, file)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.from_srt","title":"<code>from_srt(file, an8_all_caps=True, style_all_caps=True, timesource=Fraction(24000, 1001), timescale=TimeScale.MKV, encoding='UTF8')</code>  <code>classmethod</code>","text":"<p>Convert srt subtitles to an ass SubFile. Automatically applies Gandhi styling. Feel free to restyle. Also worth noting that this creates a file that assumes 1920x1080. Use the resample function if you need something else.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Input srt file</p> required <code>an8_all_caps</code> <code>bool</code> <p>Automatically an8 every full caps line with over 7 characters because they're usually signs.</p> <code>True</code> <code>style_all_caps</code> <code>bool</code> <p>Also set the style of these lines to \"Sign\" wether it exists or not.</p> <code>True</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>Fraction(24000, 1001)</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>encoding</code> <code>str</code> <p>Encoding used to read the file. Defaults to UTF8.</p> <code>'UTF8'</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>@classmethod\ndef from_srt(\n    cls: type[Self],\n    file: PathLike,\n    an8_all_caps: bool = True,\n    style_all_caps: bool = True,\n    timesource: TimeSourceT = Fraction(24000, 1001),\n    timescale: TimeScaleT = TimeScale.MKV,\n    encoding: str = \"UTF8\",\n) -&gt; Self:\n    \"\"\"\n    Convert srt subtitles to an ass SubFile.\n    Automatically applies Gandhi styling. Feel free to restyle.\n    Also worth noting that this creates a file that assumes 1920x1080. Use the resample function if you need something else.\n\n    :param file:            Input srt file\n    :param an8_all_caps:    Automatically an8 every full caps line with over 7 characters because they're usually signs.\n    :param style_all_caps:  Also set the style of these lines to \"Sign\" wether it exists or not.\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    :param encoding:        Encoding used to read the file. Defaults to UTF8.\n    \"\"\"\n    caller = \"SubFile.from_srt\"\n    file = ensure_path_exists(file, caller)\n    resolved_ts = resolve_timesource_and_scale(timesource, timescale, caller=cls)\n\n    compiled = re.compile(SRT_REGEX, re.MULTILINE)\n\n    def srt_timedelta(timestamp: str, time_type: TimeType) -&gt; timedelta:\n        args = timestamp.split(\",\")[0].split(\":\")\n        parsed = timedelta(hours=int(args[0]), minutes=int(args[1]), seconds=int(args[2]), milliseconds=int(timestamp.split(\",\")[1]))\n        cope = resolved_ts.time_to_frame(int(parsed.total_seconds() * 1000), time_type, 3)\n        cope = resolved_ts.frame_to_time(cope, time_type, 3, True)\n        return timedelta(milliseconds=cope)\n\n    def convert_tags(text: str) -&gt; tuple[str, bool]:\n        text = text.strip().replace(\"\\n\", \"\\\\N\")\n        is_sign = False\n        if an8_all_caps and text.upper() == text and len(text) &gt; 7:\n            text = R\"{\\an8}\" + text\n            is_sign = True\n        text = re.sub(r\"[\\&lt;|{]i[\\&gt;|}]\", R\"{\\\\i1}\", text)\n        text = re.sub(r\"[\\&lt;|{]\\/i[\\&gt;|}]\", R\"{\\\\i}\", text)\n        text = re.sub(r\"[\\&lt;|{]b[\\&gt;|}]\", R\"{\\\\b1}\", text)\n        text = re.sub(r\"[\\&lt;|{]\\/b[\\&gt;|}]\", R\"{\\\\b}\", text)\n        text = re.sub(r\"[\\&lt;|{]u[\\&gt;|}]\", R\"{\\\\u1}\", text)\n        text = re.sub(r\"[\\&lt;|{]\\/u[\\&gt;|}]\", R\"{\\\\u}\", text)\n        return text, is_sign\n\n    doc = create_document()\n\n    with open(file, \"r\", encoding=encoding) as reader:\n        content = reader.read() + \"\\n\"\n        for match in compiled.finditer(content):\n            start = srt_timedelta(match[\"start\"], TimeType.START)\n            end = srt_timedelta(match[\"end\"], TimeType.END)\n            text, sign = convert_tags(match[\"text\"])\n            doc.events.append(Dialogue(layer=99, start=start, end=end, text=text, style=\"Sign\" if sign and style_all_caps else \"Default\"))\n\n    out = file.with_suffix(\".ass\")\n    with open(out, \"w\", encoding=\"utf_8_sig\") as writer:\n        doc.dump_file(writer)\n    out = cls(out, 0, file)\n    return out.restyle(GJM_GANDHI_PRESET)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.manipulate_lines","title":"<code>manipulate_lines(func)</code>","text":"<p>Function to manipulate any lines.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[LINES], LINES | None]</code> <p>Your own function you want to run on the list of lines. This can return a new list or just edit the one passed into it.</p> required Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def manipulate_lines(self, func: Callable[[LINES], LINES | None]) -&gt; Self:\n    \"\"\"\n    Function to manipulate any lines.\n\n    :param func:        Your own function you want to run on the list of lines.\n                        This can return a new list or just edit the one passed into it.\n    \"\"\"\n    super().manipulate_lines(func)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.merge","title":"<code>merge(file, sync=None, sync2=None, timesource=None, timescale=None, use_actor_field=False, no_error=False, sort_lines=False, shift_mode=ShiftMode.FRAME, oob_mode=OutOfBoundsMode.ERROR)</code>","text":"<p>Merge another subtitle file with syncing if needed.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | GlobSearch</code> <p>The file to be merged.</p> required <code>sync</code> <code>None | int | str</code> <p>Can be None to not adjust timing at all, an int for a frame number or a string for a syncpoint name.</p> <code>None</code> <code>sync2</code> <code>None | str</code> <p>The syncpoint you want to use for the second file. This is needed if you specified a frame for sync and still want to use a specific syncpoint.</p> <code>None</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> <code>use_actor_field</code> <code>bool</code> <p>Checks the actor field instead of effect for the names if True.</p> <code>False</code> <code>no_error</code> <code>bool</code> <p>Don't error and warn instead if syncpoint not found.</p> <code>False</code> <code>sort_lines</code> <code>bool</code> <p>Sort the lines by the starting timestamp. This was done by default before but may cause issues with subtitles relying on implicit layering.</p> <code>False</code> <code>shift_mode</code> <code>ShiftMode</code> <p>Choose what to shift by. Defaults to shifting by frames.</p> <code>FRAME</code> <code>oob_mode</code> <code>OutOfBoundsMode</code> <p>What to do with lines that are out of bounds after shifting.</p> <code>ERROR</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def merge(\n    self,\n    file: PathLike | GlobSearch,\n    sync: None | int | str = None,\n    sync2: None | str = None,\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = None,\n    use_actor_field: bool = False,\n    no_error: bool = False,\n    sort_lines: bool = False,\n    shift_mode: ShiftMode = ShiftMode.FRAME,\n    oob_mode: OutOfBoundsMode = OutOfBoundsMode.ERROR,\n) -&gt; Self:\n    \"\"\"\n    Merge another subtitle file with syncing if needed.\n\n    :param file:            The file to be merged.\n    :param sync:            Can be None to not adjust timing at all, an int for a frame number or a string for a syncpoint name.\n    :param sync2:           The syncpoint you want to use for the second file.\n                            This is needed if you specified a frame for sync and still want to use a specific syncpoint.\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    :param use_actor_field: Checks the actor field instead of effect for the names if True.\n    :param no_error:        Don't error and warn instead if syncpoint not found.\n    :param sort_lines:      Sort the lines by the starting timestamp.\n                            This was done by default before but may cause issues with subtitles relying on implicit layering.\n    :param shift_mode:      Choose what to shift by. Defaults to shifting by frames.\n    :param oob_mode:        What to do with lines that are out of bounds after shifting.\n    \"\"\"\n    if sync is not None or sync2 is not None and shift_mode == ShiftMode.FRAME:\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n\n    file = ensure_path_exists(file, self)\n    mergedoc = self._read_doc(file)\n    doc = self._read_doc()\n    doc_name = ensure_path_exists(self.file, self).name if str(self.source).lower().endswith(\".mkv\") else ensure_path(self.source, self).name\n    self._warn_mismatched_properties(doc, mergedoc, doc_name, file.name)\n\n    events = []\n    tomerge = []\n    existing_styles = [style.name for style in doc.styles]\n    target = None if not isinstance(sync, int) else sync\n\n    # Find syncpoint in current document if sync is a string\n    for line in doc.events:\n        events.append(line)\n        line = cast(_Line, line)\n        if target is None and isinstance(sync, str):\n            field = line.name if use_actor_field else line.effect\n            if field.lower().strip() == sync.lower().strip() or line.text.lower().strip() == sync.lower().strip():\n                if shift_mode == ShiftMode.FRAME:\n                    target = resolved_ts.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n                else:\n                    target = line.start\n\n    if target is None and isinstance(sync, str):\n        msg = f\"Syncpoint '{sync}' was not found.\"\n        if no_error:\n            warn(msg, self)\n            return self\n        raise error(msg, self)\n\n    mergedoc.events = cast(list[_Line], mergedoc.events)\n\n    # Find second syncpoint if any\n    second_sync: int | timedelta | None = None\n    for line in mergedoc.events:\n        if not isinstance(sync, str) and not sync2:\n            break\n        else:\n            sync2 = sync2 or sync\n        field = line.name if use_actor_field else line.effect\n        if field.lower().strip() == sync2.lower().strip() or line.text.lower().strip() == sync2.lower().strip():\n            if shift_mode == ShiftMode.FRAME:\n                second_sync = resolved_ts.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n            else:\n                second_sync = line.start\n            mergedoc.events.remove(line)\n            break\n\n    sorted_lines = sorted(mergedoc.events, key=lambda event: event.start)\n\n    # Assume the first line to be the second syncpoint if none was found\n    if second_sync is None and target is not None:\n        for line in filter(lambda event: event.TYPE != \"Comment\", sorted_lines):\n            if shift_mode == ShiftMode.FRAME:\n                second_sync = resolved_ts.time_to_frame(int(line.start.total_seconds() * 1000), TimeType.START, 3)\n            else:\n                second_sync = line.start\n            break\n\n    # Merge lines from file\n    for line in sorted_lines if sort_lines else mergedoc.events:\n        # Don't apply any offset if sync=None for plain merging or if target == source\n        if target is None or target == second_sync:\n            tomerge.append(line)\n            continue\n\n        if shift_mode == ShiftMode.FRAME:\n            assert isinstance(target, int)\n            assert isinstance(second_sync, int)\n            offset = target - second_sync\n            line_result = self._shift_line_by_frames(line, offset, resolved_ts, oob_mode)\n        else:\n            assert isinstance(target, timedelta)\n            assert isinstance(second_sync, timedelta)\n            offset = target - second_sync\n            line_result = self._shift_line_by_time(line, offset, oob_mode)\n\n        if line_result.was_out_of_bounds:\n            warn(f\"Line is out of bounds: {line.start} - {line.end}:\\n\\t{line.text}\", self)\n            if oob_mode == OutOfBoundsMode.DROP_LINE:\n                continue\n\n        tomerge.append(line_result.line)\n\n    if tomerge:\n        events.extend(tomerge)\n        doc.events = events\n        for style in mergedoc.styles:\n            if style.name in existing_styles:\n                continue\n            doc.styles.append(style)\n\n    self._update_doc(doc)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.purge_macrons","title":"<code>purge_macrons(styles=DEFAULT_DIALOGUE_STYLES)</code>","text":"<p>Removes romaji macrons from every dialogue line. German subs use this a lot and a lot of fonts don't support it, so I like to purge them.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>list[str] | None</code> <p>List of styles to look for</p> <code>DEFAULT_DIALOGUE_STYLES</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def purge_macrons(self, styles: list[str] | None = DEFAULT_DIALOGUE_STYLES) -&gt; Self:\n    \"\"\"\n    Removes romaji macrons from every dialogue line.\n    German subs use this a lot and a lot of fonts don't support it, so I like to purge them.\n\n    :param styles:      List of styles to look for\n    \"\"\"\n    macrons: list[tuple[str, str]] = [(\"\u0101\", \"a\"), (\"\u0113\", \"e\"), (\"\u012b\", \"i\"), (\"\u014d\", \"o\"), (\"\u016b\", \"u\")]\n\n    def _func(lines: LINES):\n        for line in lines:\n            process = not styles\n            for style in styles or []:\n                if str(line.style).strip().casefold() == style.strip().casefold():\n                    process = True\n            if process:\n                for macron in macrons + [(m[0].upper(), m[1].upper()) for m in macrons]:\n                    line.text = line.text.replace(macron[0], macron[1])\n\n    return self.manipulate_lines(_func)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.resample","title":"<code>resample(video=None, src_width=None, src_height=None, use_arch=None, quiet=True)</code>","text":"<p>Resample subtitles to match the resolution of the specified video.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>PathLike | None</code> <p>Path to a video. Will resort to a 1080p dummy video if None.</p> <code>None</code> <code>src_width</code> <code>int | None</code> <p>The width of the resolution the subs are currently at</p> <code>None</code> <code>src_height</code> <code>int | None</code> <p>The height of the resolution the subs are currently at Both of the above params will be taken from the sub file if not given. (Assuming 640 x 360 if nothing is given in the document)</p> <code>None</code> <code>use_arch</code> <code>bool | None</code> <p>Uses arch1t3cht's perspective resampler script to fix any perspective stuff after resampling. This requires arch.Resample.moon in either of your autoload folders. None means it will use it if it can find the script. True will try to force it.</p> <code>None</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def resample(\n    self,\n    video: PathLike | None = None,\n    src_width: int | None = None,\n    src_height: int | None = None,\n    use_arch: bool | None = None,\n    quiet: bool = True,\n) -&gt; Self:\n    \"\"\"\n    Resample subtitles to match the resolution of the specified video.\n\n    :param video:           Path to a video. Will resort to a 1080p dummy video if None.\n    :param src_width:       The width of the resolution the subs are currently at\n    :param src_height:      The height of the resolution the subs are currently at\n                            Both of the above params will be taken from the sub file if not given.\n                            (Assuming 640 x 360 if nothing is given in the document)\n\n    :param use_arch:        Uses arch1t3cht's perspective resampler script to fix any perspective stuff after resampling.\n                            This requires arch.Resample.moon in either of your autoload folders.\n                            None means it will use it if it can find the script. True will try to force it.\n    \"\"\"\n    aegicli = get_executable(\"aegisub-cli\", False)\n    video = dummy_video(1920, 1080) if not video else ensure_path_exists(video, self)\n    doc = self._read_doc()\n\n    if not src_width:\n        src_width = doc.info.get(\"PlayResX\", 640)\n\n    if not src_height:\n        src_height = doc.info.get(\"PlayResY\", 360)\n\n    if use_arch is None:\n        use_arch = has_arch_resampler()\n\n    output = Path(get_temp_workdir(), f\"{self.file.stem}_resampled.ass\")\n    args = [aegicli, \"--video\", str(video.resolve()), str(self.file.resolve()), str(output), \"tool/resampleres\"]\n    if run_commandline(args, quiet):\n        raise error(\"Failed to resample subtitles!\", self)\n\n    if use_arch:\n        prevout = output\n        output = Path(get_temp_workdir(), f\"{self.file.stem}_resampled_arch.ass\")\n\n        # fmt: off\n        dialog_json = json.dumps({\"button\": 0, \"values\": {\"srcresx\": src_width, \"srcresy\": src_height, \"centerorg\": \"false\"}})\n        args = [aegicli, \"--video\", str(video.resolve()), \"--dialog\", dialog_json, \"--automation\", \"arch.Resample.moon\", str(prevout), str(output), \"Resample Perspective\"]\n        # fmt: on\n        if run_commandline(args, quiet):\n            raise error(\"Failed to resample perspective of subtitles!\", self)\n\n    self.file.unlink(True)\n    self.file = shutil.copy(output, self.file)\n    clean_temp_files()\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.restyle","title":"<code>restyle(styles, clean_after=True, delete_existing=False, adjust_styles=True)</code>","text":"<p>Add (and replace existing) styles to the subtitle file.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>Style | list[Style]</code> <p>Either a single or a list of ass Styles</p> required <code>clean_after</code> <code>bool</code> <p>Clean unused styles after</p> <code>True</code> <code>delete_existing</code> <code>bool</code> <p>Delete all existing styles before adding new ones</p> <code>False</code> <code>adjust_styles</code> <code>bool</code> <p>Resize the styles to match the script resolution. This assumes 1080p for the actual style res as all the presets are that.</p> <code>True</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def restyle(self, styles: Style | list[Style], clean_after: bool = True, delete_existing: bool = False, adjust_styles: bool = True) -&gt; Self:\n    \"\"\"\n    Add (and replace existing) styles to the subtitle file.\n\n    :param styles:          Either a single or a list of ass Styles\n    :param clean_after:     Clean unused styles after\n    :param delete_existing: Delete all existing styles before adding new ones\n    :param adjust_styles:   Resize the styles to match the script resolution.\n                            This assumes 1080p for the actual style res as all the presets are that.\n    \"\"\"\n    if not isinstance(styles, list):\n        styles = [styles]\n\n    styles = styles.copy()\n\n    doc = self._read_doc()\n    script_res = int(doc.info.get(\"PlayResY\", 360))\n    if script_res != 1080 and adjust_styles:\n        styles = resize_preset(styles, script_res)\n\n    if delete_existing:\n        doc.styles = []\n\n    names = [style.name.casefold() for style in styles]\n    existing = [style for style in doc.styles if style.name.casefold() not in names]\n    styles.extend(existing)\n    doc.styles = styles\n\n    self._update_doc(doc)\n    if clean_after:\n        return self.clean_styles()\n    else:\n        return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.separate_signs","title":"<code>separate_signs(styles=DEFAULT_DIALOGUE_STYLES, inverse=False, heuristics=False, print_heuristics=True)</code>","text":"<p>Basically deletes lines that have any of the passed styles.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>list[str]</code> <p>List of style names to get rid of</p> <code>DEFAULT_DIALOGUE_STYLES</code> <code>inverse</code> <code>bool</code> <p>Treat the list as the opposite. Will remove lines that don't have any of those styles.</p> <code>False</code> <code>heuristics</code> <code>bool</code> <p>Also use heuristics for detecting signs.</p> <code>False</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def separate_signs(\n    self, styles: list[str] = DEFAULT_DIALOGUE_STYLES, inverse: bool = False, heuristics: bool = False, print_heuristics: bool = True\n) -&gt; Self:\n    \"\"\"\n    Basically deletes lines that have any of the passed styles.\n\n    :param styles:      List of style names to get rid of\n    :param inverse:     Treat the list as the opposite. Will remove lines that *don't* have any of those styles.\n    :param heuristics:  Also use heuristics for detecting signs.\n    \"\"\"\n\n    def _is_sign(line: _Line) -&gt; bool:\n        confidence = 0\n        style_check = False\n        if styles and (line.style.casefold() not in [str(style).casefold() for style in styles]):\n            style_check = True\n            confidence += 2\n\n        if heuristics and confidence &lt; 2:\n            if line.name:\n                if \"onscreen\" in line.name.lower().replace(\" \", \"\") or line.name.lower() == \"type\" or line.name.lower() == \"sign\":\n                    confidence += 1\n\n            if R\"\\pos\" in line.text:\n                confidence += 1\n            if R\"\\mov\" in line.text:\n                confidence += 1\n            if R\"\\fn\" in line.text:\n                confidence += 1\n            if R\"\\blur\" in line.text or R\"\\be\" in line.text:\n                confidence += 1\n\n            an_types = [Rf\"\\an{num}\" for num in range(1, 10) if num not in (2, 8)]\n            for an in an_types:\n                if an in line.text:\n                    confidence += 1\n                    break\n            if print_heuristics and confidence &gt;= 2 and not style_check:  # and styles:\n                info(f\"Line with dialogue style passed heuristics:\\n{line.text}\", self)\n\n        return confidence &gt;= 2\n\n    def filter_lines(lines: LINES):\n        events = []\n        for line in lines:\n            skip = not inverse\n            if _is_sign(line):\n                skip = inverse\n\n            if skip:\n                continue\n            events.append(line)\n        return events\n\n    return self.manipulate_lines(filter_lines).clean_styles()\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.set_header","title":"<code>set_header(header, value)</code>","text":"<p>A function to add headers to the \"Script Info\" section of the subtitle file. This will validate the input for known functional headers but also allows arbitrary ones. If you're planning on setting multiple at the same time, use the <code>set_headers</code> function instead to avoid a lot of I/O.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>str | ASSHeader</code> <p>The name of the header or a header chosen from the enum.</p> required <code>value</code> <code>str | int | bool | None</code> <p>The value of the header. None will remove the header unless it's the Matrix header because None has a meaning there.</p> required Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def set_header(self, header: str | ASSHeader, value: str | int | bool | None) -&gt; Self:\n    \"\"\"\n    A function to add headers to the \"Script Info\" section of the subtitle file.\n    This will validate the input for known functional headers but also allows arbitrary ones.\n    If you're planning on setting multiple at the same time, use the `set_headers` function instead to avoid a lot of I/O.\n\n    :param header:      The name of the header or a header chosen from the enum.\n    :param value:       The value of the header. None will remove the header unless it's the Matrix header because None has a meaning there.\n    \"\"\"\n    super().set_header(header, value)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.set_headers","title":"<code>set_headers(*headers)</code>","text":"<p>A function to add headers to the \"Script Info\" section of the subtitle file. This will validate the input for known functional headers but also allows arbitrary ones.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>tuple[str | ASSHeader, str | int | bool | None]</code> <p>Any amount of tuples with the same typing as the single header function.</p> <code>()</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def set_headers(self, *headers: tuple[str | ASSHeader, str | int | bool | None]) -&gt; Self:\n    \"\"\"\n    A function to add headers to the \"Script Info\" section of the subtitle file.\n    This will validate the input for known functional headers but also allows arbitrary ones.\n\n    :param headers:     Any amount of tuples with the same typing as the single header function.\n    \"\"\"\n    doc = self._read_doc()\n    for header, value in headers:\n        super().set_header(header, value, doc)\n    self._update_doc(doc)\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.shift","title":"<code>shift(frames, timesource=None, timescale=None, oob_mode=OutOfBoundsMode.ERROR)</code>","text":"<p>Shifts all lines by any frame number.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>int</code> <p>Number of frames to shift by</p> required <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> <code>oob_mode</code> <code>OutOfBoundsMode</code> <p>What to do with lines that are out of bounds after shifting.</p> <code>ERROR</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def shift(\n    self,\n    frames: int,\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = None,\n    oob_mode: OutOfBoundsMode = OutOfBoundsMode.ERROR,\n) -&gt; Self:\n    \"\"\"\n    Shifts all lines by any frame number.\n\n    :param frames:              Number of frames to shift by\n    :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n    :param oob_mode:            What to do with lines that are out of bounds after shifting.\n    \"\"\"\n    resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n\n    def shift_lines(lines: LINES):\n        new_list = list[_Line]()\n        for line in lines:\n            line_result = self._shift_line_by_frames(line, frames, resolved_ts, oob_mode)\n\n            if line_result.was_out_of_bounds:\n                warn(f\"Line is out of bounds: {line.start} - {line.end}:\\n\\t{line.text}\", self)\n                if oob_mode == OutOfBoundsMode.DROP_LINE:\n                    continue\n\n            new_list.append(line_result.line)\n        return new_list\n\n    return self.manipulate_lines(shift_lines)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.shift_0","title":"<code>shift_0(timesource=None, timescale=None, allowed_styles=DEFAULT_DIALOGUE_STYLES)</code>","text":"<p>Does the famous shift by 0 frames to fix frame timing issues. (It's basically just converting time to frame and back)</p> <p>This does not currently exactly reproduce the aegisub behaviour but it should have the same effect.</p> <p>Parameters:</p> Name Type Description Default <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> <code>allowed_styles</code> <code>list[str] | None</code> <p>A list of style names this will run on. Will run on every line if None.</p> <code>DEFAULT_DIALOGUE_STYLES</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def shift_0(\n    self,\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = None,\n    allowed_styles: list[str] | None = DEFAULT_DIALOGUE_STYLES,\n) -&gt; Self:\n    \"\"\"\n    Does the famous shift by 0 frames to fix frame timing issues.\n    (It's basically just converting time to frame and back)\n\n    This does not currently exactly reproduce the aegisub behaviour but it should have the same effect.\n\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    :param allowed_styles:  A list of style names this will run on. Will run on every line if None.\n    \"\"\"\n    resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n\n    def _func(lines: LINES):\n        for line in lines:\n            if not allowed_styles or line.style.lower() in allowed_styles:\n                result = self._shift_line_by_frames(line, 0, resolved_ts, OutOfBoundsMode.ERROR)\n                line = result.line\n\n    return self.manipulate_lines(_func)\n</code></pre>"},{"location":"muxtools/subtitle/sub/#muxtools.subtitle.sub.SubFile.unfuck_cr","title":"<code>unfuck_cr(default_style='Default', keep_flashback=True, dialogue_styles=['main', 'default', 'narrator', 'narration'], top_styles=['top'], italics_styles=['italics', 'internal'], alt_style='Alt', alt_styles=None)</code>","text":"<p>Removes any top and italics styles and replaces them with tags.</p> <p>Parameters:</p> Name Type Description Default <code>default_style</code> <code>str</code> <p>The default style that everything will be set to</p> <code>'Default'</code> <code>keep_flashback</code> <code>bool</code> <p>If not it will set the flashback styles to default_style</p> <code>True</code> <code>dialogue_styles</code> <code>list[str] | None</code> <p>Styles that will be set to default_style</p> <code>['main', 'default', 'narrator', 'narration']</code> <code>top_styles</code> <code>list[str] | None</code> <p>Styles that will be set to default_style and an8 added to tags</p> <code>['top']</code> <code>italics_styles</code> <code>list[str] | None</code> <p>Styles that will be set to default_style and i1 added to tags</p> <code>['italics', 'internal']</code> <code>alt_style</code> <code>str</code> <p>The default alt/overlap style that lines will be set to</p> <code>'Alt'</code> <code>alt_styles</code> <code>list[str] | None</code> <p>Possible identifiers for styles that should be set to the alt_style</p> <code>None</code> Source code in <code>         muxtools/subtitle/sub.py       </code> <pre><code>def unfuck_cr(\n    self,\n    default_style: str = \"Default\",\n    keep_flashback: bool = True,\n    dialogue_styles: list[str] | None = [\"main\", \"default\", \"narrator\", \"narration\"],\n    top_styles: list[str] | None = [\"top\"],\n    italics_styles: list[str] | None = [\"italics\", \"internal\"],\n    alt_style: str = \"Alt\",\n    alt_styles: list[str] | None = None,\n) -&gt; Self:\n    \"\"\"\n    Removes any top and italics styles and replaces them with tags.\n\n    :param default_style:       The default style that everything will be set to\n    :param keep_flashback:      If not it will set the flashback styles to default_style\n    :param dialogue_styles:     Styles that will be set to default_style\n    :param top_styles:          Styles that will be set to default_style and an8 added to tags\n    :param italics_styles:      Styles that will be set to default_style and i1 added to tags\n    :param alt_style:           The default alt/overlap style that lines will be set to\n    :param alt_styles:          Possible identifiers for styles that should be set to the alt_style\n    \"\"\"\n\n    def get_default(line: _Line, allow_default: bool = True) -&gt; str:\n        placeholder = default_style\n        is_default = True\n        if alt_styles:\n            for s in alt_styles:\n                if s.casefold() in line.style.casefold():\n                    placeholder = alt_style\n                    is_default = False\n        if \"flashback\" in line.style.lower():\n            return placeholder if not keep_flashback else \"Flashback\"\n\n        if is_default:\n            return placeholder if allow_default else line.style\n\n        return placeholder\n\n    def _func(lines: LINES):\n        for line in lines:\n            add_italics_tag = italics_styles and bool([s for s in italics_styles if s.casefold() in line.style.casefold()])\n            add_top_tag = top_styles and bool([s for s in top_styles if s.casefold() in line.style.casefold()])\n\n            if any([add_italics_tag, add_top_tag]):\n                line.style = get_default(line)\n                tags = \"\" if not add_italics_tag else R\"\\i1\"\n                tags = tags if not add_top_tag else tags + R\"\\an8\"\n                line.text = f\"{{{tags}}}{line.text}\"\n\n            line.style = get_default(line, False)\n\n            if dialogue_styles:\n                for s in dialogue_styles:\n                    if s.casefold() in line.style.casefold():\n                        line.style = default_style\n\n    return self.manipulate_lines(_func).clean_styles()\n</code></pre>"},{"location":"muxtools/subtitle/sub_pgs/","title":"sub-pgs","text":""},{"location":"muxtools/subtitle/sub_pgs/#muxtools.subtitle.sub_pgs.SubFilePGS","title":"<code>SubFilePGS</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MuxingFile</code></p> <p>Utility class representing a PGS/SUP subtitle file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | list[PathLike] | GlobSearch</code> <p>Can be a string, Path object or GlobSearch.</p> required <code>container_delay</code> <code>int</code> <p>Set a container delay used in the muxing process later.</p> <code>0</code> <code>source</code> <code>PathLike | None</code> <p>The file this sub originates from, will be set by the constructor.</p> <code>None</code> Source code in <code>           muxtools/subtitle/sub_pgs.py         </code> <pre><code>@dataclass\nclass SubFilePGS(MuxingFile):\n    \"\"\"\n    Utility class representing a PGS/SUP subtitle file.\n\n    :param file:            Can be a string, Path object or GlobSearch.\n    :param container_delay: Set a container delay used in the muxing process later.\n    :param source:          The file this sub originates from, will be set by the constructor.\n    \"\"\"\n\n    def __post_init__(self):\n        super().__post_init__()\n        parsed = ParsedFile.from_file(self.file, self)\n        parsed_track = parsed.find_tracks(type=TrackType.SUB, relative_id=0, error_if_empty=True, caller=self)[0]\n        if parsed_track.codec_name.lower() != \"hdmv_pgs_subtitle\":\n            raise error(f\"The passed file is not a PGS subtitle file. ({parsed_track.codec_name})\", caller=self)\n\n    def shift(self, shift: int, shift_is_ms: bool = False, timesource: TimeSourceT = None, timescale: TimeScaleT = None, quiet: bool = True) -&gt; Self:\n        \"\"\"\n        Shifts all lines by any frame number with supmover.\n\n        :param shift:               Number of frames to shift by\n        :param shift_is_ms:         If True, the shift is in milliseconds.\n        :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                    For details check the docstring on the type.\n        :param quiet:               If True, suppresses supmover output.\n        \"\"\"\n        supmover = get_executable(\"SupMover\")\n        out = make_output(self.file, \"sup\", temp=True)\n        fileIn = ensure_path(self.file, self)\n        args = [supmover, str(fileIn), str(out), \"--delay\"]\n        if shift_is_ms:\n            args.append(str(shift))\n        else:\n            resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n            ms = resolved_ts.frame_to_time(abs(shift), TimeType.START, 3)\n            args.append(str(ms) if shift &gt;= 0 else f\"-{ms}\")\n\n        if run_commandline(args, quiet):\n            clean_temp_files()\n            raise error(\"Failed to shift subtitle file.\", caller=self)\n\n        fileIn.unlink(missing_ok=True)\n        move(out, fileIn)\n        clean_temp_files()\n        return self\n\n    @classmethod\n    def extract_from(cls: type[Self], fileIn: PathLike, track: int = 0, preserve_delay: bool = False, quiet: bool = True) -&gt; Self:\n        \"\"\"\n        Extract a PGS subtitle track from a file using ffmpeg.\\n\n\n        :param fileIn:          The input file to extract from.\n        :param track:           The track number to extract.\n        :param preserve_delay:  If True, the container delay will be preserved.\n        :param quiet:           If True, suppresses ffmpeg output.\n        :return:                An instance of SubFilePGS containing the extracted subtitle.\n        \"\"\"\n        caller = \"SubFilePGS.extract_from\"\n        parsed = ParsedFile.from_file(fileIn, caller)\n        parsed_track = parsed.find_tracks(type=TrackType.SUB, relative_id=track, error_if_empty=True, caller=caller)[0]\n\n        if parsed_track.codec_name.lower() != \"hdmv_pgs_subtitle\":\n            raise error(f\"The specified track is not a PGS subtitle. ({parsed_track.codec_name})\", caller=caller)\n\n        info(f\"Extracting PGS subtitle track {track} from '{parsed.source.name}'\", caller=caller)\n        ffmpeg = get_executable(\"ffmpeg\")\n\n        out = make_output(fileIn, \"sup\", str(parsed_track.index))\n        args = [ffmpeg, \"-hide_banner\", \"-i\", str(parsed.source), \"-map\", f\"0:s:{str(track)}\", \"-c\", \"copy\", str(out)]\n        if run_commandline(args, quiet):\n            raise error(\"Failed to extract subtitle track from file.\", caller=caller)\n\n        delay = 0 if not preserve_delay else parsed_track.container_delay\n\n        return cls(out, delay, fileIn)\n</code></pre>"},{"location":"muxtools/subtitle/sub_pgs/#muxtools.subtitle.sub_pgs.SubFilePGS.extract_from","title":"<code>extract_from(fileIn, track=0, preserve_delay=False, quiet=True)</code>  <code>classmethod</code>","text":"<p>Extract a PGS subtitle track from a file using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike</code> <p>The input file to extract from.</p> required <code>track</code> <code>int</code> <p>The track number to extract.</p> <code>0</code> <code>preserve_delay</code> <code>bool</code> <p>If True, the container delay will be preserved.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, suppresses ffmpeg output.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of SubFilePGS containing the extracted subtitle.</p> Source code in <code>         muxtools/subtitle/sub_pgs.py       </code> <pre><code>@classmethod\ndef extract_from(cls: type[Self], fileIn: PathLike, track: int = 0, preserve_delay: bool = False, quiet: bool = True) -&gt; Self:\n    \"\"\"\n    Extract a PGS subtitle track from a file using ffmpeg.\\n\n\n    :param fileIn:          The input file to extract from.\n    :param track:           The track number to extract.\n    :param preserve_delay:  If True, the container delay will be preserved.\n    :param quiet:           If True, suppresses ffmpeg output.\n    :return:                An instance of SubFilePGS containing the extracted subtitle.\n    \"\"\"\n    caller = \"SubFilePGS.extract_from\"\n    parsed = ParsedFile.from_file(fileIn, caller)\n    parsed_track = parsed.find_tracks(type=TrackType.SUB, relative_id=track, error_if_empty=True, caller=caller)[0]\n\n    if parsed_track.codec_name.lower() != \"hdmv_pgs_subtitle\":\n        raise error(f\"The specified track is not a PGS subtitle. ({parsed_track.codec_name})\", caller=caller)\n\n    info(f\"Extracting PGS subtitle track {track} from '{parsed.source.name}'\", caller=caller)\n    ffmpeg = get_executable(\"ffmpeg\")\n\n    out = make_output(fileIn, \"sup\", str(parsed_track.index))\n    args = [ffmpeg, \"-hide_banner\", \"-i\", str(parsed.source), \"-map\", f\"0:s:{str(track)}\", \"-c\", \"copy\", str(out)]\n    if run_commandline(args, quiet):\n        raise error(\"Failed to extract subtitle track from file.\", caller=caller)\n\n    delay = 0 if not preserve_delay else parsed_track.container_delay\n\n    return cls(out, delay, fileIn)\n</code></pre>"},{"location":"muxtools/subtitle/sub_pgs/#muxtools.subtitle.sub_pgs.SubFilePGS.shift","title":"<code>shift(shift, shift_is_ms=False, timesource=None, timescale=None, quiet=True)</code>","text":"<p>Shifts all lines by any frame number with supmover.</p> <p>Parameters:</p> Name Type Description Default <code>shift</code> <code>int</code> <p>Number of frames to shift by</p> required <code>shift_is_ms</code> <code>bool</code> <p>If True, the shift is in milliseconds.</p> <code>False</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>If True, suppresses supmover output.</p> <code>True</code> Source code in <code>         muxtools/subtitle/sub_pgs.py       </code> <pre><code>def shift(self, shift: int, shift_is_ms: bool = False, timesource: TimeSourceT = None, timescale: TimeScaleT = None, quiet: bool = True) -&gt; Self:\n    \"\"\"\n    Shifts all lines by any frame number with supmover.\n\n    :param shift:               Number of frames to shift by\n    :param shift_is_ms:         If True, the shift is in milliseconds.\n    :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n    :param quiet:               If True, suppresses supmover output.\n    \"\"\"\n    supmover = get_executable(\"SupMover\")\n    out = make_output(self.file, \"sup\", temp=True)\n    fileIn = ensure_path(self.file, self)\n    args = [supmover, str(fileIn), str(out), \"--delay\"]\n    if shift_is_ms:\n        args.append(str(shift))\n    else:\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, fetch_from_setup=True, caller=self)\n        ms = resolved_ts.frame_to_time(abs(shift), TimeType.START, 3)\n        args.append(str(ms) if shift &gt;= 0 else f\"-{ms}\")\n\n    if run_commandline(args, quiet):\n        clean_temp_files()\n        raise error(\"Failed to shift subtitle file.\", caller=self)\n\n    fileIn.unlink(missing_ok=True)\n    move(out, fileIn)\n    clean_temp_files()\n    return self\n</code></pre>"},{"location":"muxtools/subtitle/subutils/","title":"subutils","text":""},{"location":"muxtools/subtitle/subutils/#muxtools.subtitle.subutils.create_document","title":"<code>create_document()</code>","text":"<p>Convenience function to create a new ASS Document. With relevant fields already filled in.</p> Source code in <code>         muxtools/subtitle/subutils.py       </code> <pre><code>def create_document() -&gt; Document:\n    \"\"\"\n    Convenience function to create a new ASS Document.\n    With relevant fields already filled in.\n    \"\"\"\n    doc = Document()\n    doc.play_res_x = 1920\n    doc.play_res_y = 1080\n    doc.wrap_style = 0\n    doc.scaled_border_and_shadow = \"yes\"\n    doc.script_type = \"v4.00+\"\n    return doc\n</code></pre>"},{"location":"muxtools/subtitle/subutils/#muxtools.subtitle.subutils.dummy_video","title":"<code>dummy_video(width=1920, height=1080, format='yuv420p', quiet=True)</code>","text":"<p>Creates a black dummy video using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the video</p> <code>1920</code> <code>height</code> <code>int</code> <p>Height of the video</p> <code>1080</code> <code>format</code> <code>str</code> <p>Format of the video Do <code>ffmpeg -pix_fmts</code> to see what's available</p> <code>'yuv420p'</code> <code>quiet</code> <code>bool</code> <p>Enable or disable commandline output</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path object of the resulting video</p> Source code in <code>         muxtools/subtitle/subutils.py       </code> <pre><code>def dummy_video(width: int = 1920, height: int = 1080, format: str = \"yuv420p\", quiet: bool = True) -&gt; Path:\n    \"\"\"\n    Creates a black dummy video using ffmpeg.\n\n    :param width:           Width of the video\n    :param height:          Height of the video\n    :param format:          Format of the video\n                            Do `ffmpeg -pix_fmts` to see what's available\n    :param quiet:           Enable or disable commandline output\n\n    :return:                Path object of the resulting video\n    \"\"\"\n    from ..utils.files import make_output\n\n    ffmpeg = get_executable(\"ffmpeg\")\n    out = make_output(\"dummy_video.mp4\", \"mp4\", temp=True)\n    args = [ffmpeg, \"-t\", \"1\", \"-f\", \"lavfi\", \"-i\", f\"color=c=black:s={width}x{height}\", \"-c:v\", \"libx264\", \"-pix_fmt\", format, str(out)]\n    if run_commandline(args, quiet):\n        raise error(\"Failed to create dummy video with ffmpeg!\", dummy_video)\n    return out\n</code></pre>"},{"location":"muxtools/utils/convert/","title":"convert","text":""},{"location":"muxtools/utils/convert/#muxtools.utils.convert.format_timedelta","title":"<code>format_timedelta(time, precision=3)</code>","text":"<p>Formats a timedelta to hh:mm:ss.s[*precision] and pads with 0 if there aren't more numbers to work with. Mostly to be used for ogm/xml files.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>timedelta</code> <p>The timedelta</p> required <code>precision</code> <code>int</code> <p>3 = milliseconds, 6 = microseconds, 9 = nanoseconds</p> <code>3</code> <p>Returns:</p> Type Description <code>str</code> <p>The formatted string</p> Source code in <code>         muxtools/utils/convert.py       </code> <pre><code>def format_timedelta(time: timedelta, precision: int = 3) -&gt; str:\n    \"\"\"\n    Formats a timedelta to hh:mm:ss.s[*precision] and pads with 0 if there aren't more numbers to work with.\n    Mostly to be used for ogm/xml files.\n\n    :param time:        The timedelta\n    :param precision:   3 = milliseconds, 6 = microseconds, 9 = nanoseconds\n\n    :return:            The formatted string\n    \"\"\"\n    dec = Decimal(time.total_seconds())\n    pattern = \".\" + \"\".join([\"0\"] * (precision - 1)) + \"1\"\n    rounded = float(dec.quantize(Decimal(pattern), rounding=ROUND_HALF_DOWN))\n    s = trunc(rounded)\n    m = s // 60\n    s %= 60\n    h = m // 60\n    m %= 60\n    return f\"{h:02d}:{m:02d}:{s:02d}.{str(rounded).split('.')[1].ljust(precision, '0')}\"\n</code></pre>"},{"location":"muxtools/utils/convert/#muxtools.utils.convert.get_timemeta_from_video","title":"<code>get_timemeta_from_video(video_file, out_file=None, caller=None)</code>","text":"<p>Parse timestamps from an existing video file using ffprobe.</p> <p>They're saved as a custom meta file in the current workdir and named based on the input.</p> <p>Also automatically reused (with a debug log) if already exists.</p> <p>Parameters:</p> Name Type Description Default <code>video_file</code> <code>PathLike</code> <p>Input video. Path or String.</p> required <code>out_file</code> <code>PathLike | None</code> <p>Output file. If None given, the above behavior applies.</p> <code>None</code> <code>caller</code> <code>Any | None</code> <p>Caller used for the logging</p> <code>None</code> <p>Returns:</p> Type Description <code>VideoMeta</code> <p>Videometa object</p> Source code in <code>         muxtools/utils/convert.py       </code> <pre><code>def get_timemeta_from_video(video_file: PathLike, out_file: PathLike | None = None, caller: Any | None = None) -&gt; VideoMeta:\n    \"\"\"\n    Parse timestamps from an existing video file using ffprobe.\\n\n    They're saved as a custom meta file in the current workdir and named based on the input.\n\n    Also automatically reused (with a debug log) if already exists.\n\n    :param video_file:      Input video. Path or String.\n    :param out_file:        Output file. If None given, the above behavior applies.\n    :param caller:          Caller used for the logging\n\n    :return:                Videometa object\n    \"\"\"\n    video_file = ensure_path_exists(video_file, get_timemeta_from_video)\n    assert get_executable(\"ffprobe\")\n    if not out_file:\n        out_file = get_workdir() / f\"{video_file.stem}_meta.json\"\n\n    out_file = ensure_path(out_file, get_timemeta_from_video)\n    if not out_file.exists() or out_file.stat().st_size &lt; 1:\n        info(f\"Generating timestamps for '{video_file.name}'...\", caller)\n        timestamps = VideoTimestamps.from_video_file(video_file)\n        meta = VideoMeta(timestamps.pts_list, timestamps.fps, timestamps.time_scale, str(video_file.resolve()))\n        with open(out_file, \"w\", encoding=\"utf-8\") as f:\n            f.write(meta.to_json())\n    else:\n        meta = VideoMeta.from_json(out_file)\n        debug(f\"Reusing existing timestamps for '{video_file.name}'\", caller)\n    return meta\n</code></pre>"},{"location":"muxtools/utils/convert/#muxtools.utils.convert.resolve_timesource_and_scale","title":"<code>resolve_timesource_and_scale(timesource=None, timescale=None, rounding_method=RoundingMethod.ROUND, allow_warn=True, fetch_from_setup=False, caller=None)</code>","text":"<p>Instantiates a timestamps class from various inputs.</p> <p>Parameters:</p> Name Type Description Default <code>timesource</code> <code>PathLike | Fraction | float | list[int] | VideoMeta | ABCTimestamps | None</code> <p>The source of timestamps/timecodes.  For actual timestamps, this can be a timestamps (v1/v2/v4) file, a muxtools VideoMeta json file, a video file or a list of integers.  For FPS based timestamps, this can be a Fraction object, a float or even a string representing a fraction.  Like <code>'24000/1001'</code>. (<code>None</code> will also fallback to this and print a warning)</p> <code>None</code> <code>timescale</code> <code>TimeScale | Fraction | int | None</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  While you can pass an int, the needed type is always a Fraction and will be converted via <code>Fraction(your_int)</code>.  If <code>None</code> falls back to a generic Matroska timescale.</p> <code>None</code> <code>rounding_method</code> <code>RoundingMethod</code> <p>The rounding method used to round/floor the PTS (Presentation Time Stamp).</p> <code>ROUND</code> <code>allow_warn</code> <code>bool</code> <p>Allow this function to print warnings. If you know what you're doing feel free to disable this for your own use.</p> <code>True</code> <code>fetch_from_setup</code> <code>bool</code> <p>Whether or not this function should fallback to the sub defaults from the current Setup.</p> <code>False</code> <code>caller</code> <code>Any | None</code> <p>Caller used for the logging</p> <code>None</code> <p>Returns:</p> Type Description <code>ABCTimestamps</code> <p>Instantiated timestamps object from the videotimestamps library</p> Source code in <code>         muxtools/utils/convert.py       </code> <pre><code>def resolve_timesource_and_scale(\n    timesource: PathLike | Fraction | float | list[int] | VideoMeta | ABCTimestamps | None = None,\n    timescale: TimeScale | Fraction | int | None = None,\n    rounding_method: RoundingMethod = RoundingMethod.ROUND,\n    allow_warn: bool = True,\n    fetch_from_setup: bool = False,\n    caller: Any | None = None,\n) -&gt; ABCTimestamps:\n    \"\"\"\n    Instantiates a timestamps class from various inputs.\n\n    :param timesource:          The source of timestamps/timecodes.\\n\n                                For actual timestamps, this can be a timestamps (v1/v2/v4) file, a muxtools VideoMeta json file, a video file or a list of integers.\\n\n                                For FPS based timestamps, this can be a Fraction object, a float or even a string representing a fraction.\\n\n                                Like `'24000/1001'`. (`None` will also fallback to this and print a warning)\n\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                While you can pass an int, the needed type is always a Fraction and will be converted via `Fraction(your_int)`.\\n\n                                If `None` falls back to a generic Matroska timescale.\n\n    :param rounding_method:     The rounding method used to round/floor the PTS (Presentation Time Stamp).\n    :param allow_warn:          Allow this function to print warnings. If you know what you're doing feel free to disable this for your own use.\n    :param fetch_from_setup:    Whether or not this function should fallback to the sub defaults from the current Setup.\n    :param caller:              Caller used for the logging\n\n    :return:                    Instantiated timestamps object from the videotimestamps library\n    \"\"\"\n    if fetch_from_setup:\n        if timesource is None and (setup_timesource := get_setup_attr(\"sub_timesource\", None)) is not None:\n            if not isinstance(setup_timesource, TimeSourceT):\n                raise error(\"Invalid timesource type in Setup!\", caller)\n            debug(\"Using default timesource from setup.\", caller)\n            timesource = setup_timesource\n        if timescale is None and (setup_timescale := get_setup_attr(\"sub_timescale\", None)) is not None:\n            if not isinstance(setup_timescale, TimeScaleT):\n                raise error(\"Invalid timescale type in Setup!\", caller)\n            debug(\"Using default timescale from setup.\", caller)\n            timescale = setup_timescale\n\n    def check_timescale(timescale) -&gt; Fraction:\n        if not timescale:\n            if allow_warn:\n                warn(\"No timescale was given, defaulting to Matroska scaling.\", caller)\n            timescale = Fraction(1000)\n        return Fraction(timescale)\n\n    if timesource is None:\n        if allow_warn:\n            warn(\"No timesource was given, generating timestamps for FPS (24000/1001).\", caller)\n        timescale = check_timescale(timescale)\n        return FPSTimestamps(rounding_method, timescale, Fraction(24000, 1001))\n\n    if isinstance(timesource, VideoMeta):\n        return VideoTimestamps(timesource.pts, timesource.timescale, fps=timesource.fps, rounding_method=rounding_method)\n\n    if isinstance(timesource, ABCTimestamps):\n        return timesource\n\n    if isinstance(timesource, PathLike):\n        if isinstance(timesource, Path) or os.path.isfile(timesource):\n            timesource = ensure_path(timesource, caller)\n            parsed = ParsedFile.from_file(timesource, caller, False)\n\n            if parsed and parsed.is_video_file:\n                meta = get_timemeta_from_video(timesource, caller=caller)\n                return VideoTimestamps(meta.pts, meta.timescale, fps=meta.fps, rounding_method=rounding_method)\n            else:\n                try:\n                    return VideoMeta.from_json(timesource)\n                except:\n                    timescale = check_timescale(timescale)\n                    return TextFileTimestamps(timesource, timescale, rounding_method=rounding_method)\n\n    elif isinstance(timesource, list) and isinstance(timesource[0], int):\n        timescale = check_timescale(timescale)\n        return VideoTimestamps(timesource, timescale, rounding_method=rounding_method)\n\n    if isinstance(timesource, float) or isinstance(timesource, str) or isinstance(timesource, Fraction):\n        fps = Fraction(timesource)\n        timescale = check_timescale(timescale)\n        return FPSTimestamps(rounding_method, timescale, fps)\n\n    raise crit(\"Invalid timesource passed!\", caller)\n</code></pre>"},{"location":"muxtools/utils/convert/#muxtools.utils.convert.timedelta_from_formatted","title":"<code>timedelta_from_formatted(formatted)</code>","text":"<p>Parses a string with the format of hh:mm:ss.sss Mostly to be used for ogm/xml files.</p> <p>Parameters:</p> Name Type Description Default <code>formatted</code> <code>str</code> <p>The timestamp string</p> required <p>Returns:</p> Type Description <code>timedelta</code> <p>The parsed timedelta</p> Source code in <code>         muxtools/utils/convert.py       </code> <pre><code>def timedelta_from_formatted(formatted: str) -&gt; timedelta:\n    \"\"\"\n    Parses a string with the format of hh:mm:ss.sss\n    Mostly to be used for ogm/xml files.\n\n    :param formatted:       The timestamp string\n\n    :return:                The parsed timedelta\n    \"\"\"\n    # 00:05:25.534...\n    split = formatted.split(\":\")\n    seconds = Decimal(split[0]) * Decimal(3600)\n    seconds = seconds + (Decimal(split[1]) * Decimal(60))\n    seconds = seconds + (Decimal(split[2]))\n    return timedelta(seconds=seconds.__float__())\n</code></pre>"},{"location":"muxtools/utils/dataclass/","title":"dataclass","text":""},{"location":"muxtools/utils/dataclass/#muxtools.utils.dataclass.CLIKwargs","title":"<code>CLIKwargs</code>","text":"<p>               Bases: <code>ABC</code></p> <p>This is an abstract class to enable the use of (pydantic) dataclass kwargs for custom cli args.</p> <p>Examples: <pre><code>@dataclass(config=allow_extra)\nclass Encoder(CLIKwargs):\n    clip: vs.VideoNode\n\ntest = Encoder(clip, colorspace=\"BT709\")\nprint(test.get_custom_args())\n# returns ['--colorspace', 'BT709']\n\n# if it starts with an _ it will be a single - argument\n# empty values will be stripped\ntest = Encoder(clip, _vbr=\"\")\nprint(test.get_custom_args())\n# returns ['-vbr']\n\n# if it ends with an _ it will preserve underscores\ntest = Encoder(clip, _color_range_=\"limited\")\nprint(test.get_custom_args())\n# returns ['-color_range', 'limited']\n</code></pre></p> <p>Alternatively you can pass an <code>append</code> argument that's either a dict[str, Any], a string or a list of strings: <pre><code>test = Encoder(clip, append=\"-vbr --bitrate 192\")\ntest = Encoder(clip, append=[\"-vbr\", \"--bitrate\", \"192\"])\ntest = Encoder(clip, append={\"-vbr\": \"\", \"--bitrate\": \"192\"})\n# all of them return ['-vbr', '--bitrate', '192']\n</code></pre></p> Source code in <code>           muxtools/utils/dataclass.py         </code> <pre><code>class CLIKwargs(ABC):\n    \"\"\"\n    This is an abstract class to enable the use of (pydantic) dataclass kwargs for custom cli args.\n\n    Examples:\n    ```py\n    @dataclass(config=allow_extra)\n    class Encoder(CLIKwargs):\n        clip: vs.VideoNode\n\n    test = Encoder(clip, colorspace=\"BT709\")\n    print(test.get_custom_args())\n    # returns ['--colorspace', 'BT709']\n\n    # if it starts with an _ it will be a single - argument\n    # empty values will be stripped\n    test = Encoder(clip, _vbr=\"\")\n    print(test.get_custom_args())\n    # returns ['-vbr']\n\n    # if it ends with an _ it will preserve underscores\n    test = Encoder(clip, _color_range_=\"limited\")\n    print(test.get_custom_args())\n    # returns ['-color_range', 'limited']\n    ```\n\n    Alternatively you can pass an `append` argument that's either a dict[str, Any], a string or a list of strings:\n    ```py\n    test = Encoder(clip, append=\"-vbr --bitrate 192\")\n    test = Encoder(clip, append=[\"-vbr\", \"--bitrate\", \"192\"])\n    test = Encoder(clip, append={\"-vbr\": \"\", \"--bitrate\": \"192\"})\n    # all of them return ['-vbr', '--bitrate', '192']\n    ```\n    \"\"\"\n\n    def get_process_affinity(self) -&gt; bool | list[int] | None:\n        if not hasattr(self, \"affinity\"):\n            return False\n\n        threads = self.affinity\n\n        if not threads:\n            return []\n\n        if isinstance(threads, float):\n            if 0.0 &lt;= threads or threads &gt;= 1.0:\n                threads = 1.0\n\n            threads = ceil(cpu_count() * threads)\n\n        if isinstance(threads, int):\n            threads = range(0, threads)\n        elif isinstance(threads, tuple):\n            threads = range(*threads)\n\n        threads = list(set(threads))\n        return threads\n\n    def update_process_affinity(self, pid: int):\n        if not isinstance((affinity := self.get_process_affinity()), bool):\n            Process(pid).cpu_affinity(affinity)\n\n    def get_mediainfo_settings(self, args: list[str], skip_first: bool = True) -&gt; str:\n        to_delete = [it.casefold() for it in [\"-hide_banner\", \"-\"]]\n        to_delete_with_next = [it.casefold() for it in [\"-map\", \"-i\", \"-o\", \"-c:a\", \"-c:v\", \"--csv\", \"--output\"]]\n\n        new_args = list[str]()\n        skip_next = False\n        for param in args:\n            if skip_first:\n                skip_first = False\n                continue\n\n            if skip_next:\n                skip_next = False\n                continue\n\n            if param.casefold() in to_delete:\n                continue\n\n            if param.casefold() in to_delete_with_next:\n                skip_next = True\n                continue\n\n            if os.path.isfile(param):\n                if \"_keyframes\" not in param.lower() and \"qpfile\" not in param.lower():\n                    continue\n\n                keyframes_file = Path(param)\n                param = keyframes_file.name\n\n            new_args.append(param)\n\n        return join(new_args)\n\n    def get_custom_args(self) -&gt; list[str]:\n        init_args: dict[str, Any]\n        if not (init_args := getattr(self, \"__pydantic_fields__\", None)):\n            return []\n\n        args = list[str]()\n        attributes = vars(self)\n        init_keys = list(init_args.keys())\n\n        for k, v in attributes.items():\n            if k == \"append\":\n                if isinstance(v, list):\n                    args.extend([str(x) for x in v])\n                elif isinstance(v, str):\n                    args.extend(split(v))\n                elif isinstance(v, dict):\n                    for append_k, append_v in v.items():\n                        args.append(str(append_k))\n                        if stripped := str(append_v).strip():\n                            args.append(stripped)\n                else:\n                    raise error(\"Append is not a string, list of strings or dict!\", self)\n                continue\n\n            if not any([isinstance(v, str), isinstance(v, int), isinstance(v, float)]):\n                continue\n            if k in init_keys or k in attribute_blacklist:\n                continue\n\n            prefix = \"--\"\n            keep_underscores = False\n\n            if k.endswith(\"_\"):\n                keep_underscores = True\n                k = k[:-1]\n            if k.startswith(\"_\"):\n                prefix = \"-\"\n                k = k[1:]\n            args.append(f\"{prefix}{k.replace('_', '-') if not keep_underscores else k}\")\n            if not isinstance(v, str):\n                args.append(str(v))\n            else:\n                if stripped := v.strip():\n                    args.append(stripped)\n        return args\n</code></pre>"},{"location":"muxtools/utils/files/","title":"files","text":""},{"location":"muxtools/utils/files/#muxtools.utils.files.ensure_path","title":"<code>ensure_path(pathIn, caller)</code>","text":"<p>Utility function for other functions to make sure a path was passed to them.</p> <p>Parameters:</p> Name Type Description Default <code>pathIn</code> <code>PathLike</code> <p>Supposed passed Path</p> required <code>caller</code> <code>Any</code> <p>Caller name used for the exception and error message</p> required Source code in <code>         muxtools/utils/files.py       </code> <pre><code>def ensure_path(pathIn: PathLike, caller: Any) -&gt; Path:\n    \"\"\"\n    Utility function for other functions to make sure a path was passed to them.\n\n    :param pathIn:      Supposed passed Path\n    :param caller:      Caller name used for the exception and error message\n    \"\"\"\n    if pathIn is None:\n        raise crit(\"Path cannot be None.\", caller)\n    else:\n        return Path(pathIn).resolve()\n</code></pre>"},{"location":"muxtools/utils/files/#muxtools.utils.files.ensure_path_exists","title":"<code>ensure_path_exists(pathIn, caller, allow_dir=False)</code>","text":"<p>Utility function for other functions to make sure a path was passed to them and that it exists.</p> <p>Parameters:</p> Name Type Description Default <code>pathIn</code> <code>PathLike | list[PathLike] | GlobSearch</code> <p>Supposed passed Path</p> required <code>caller</code> <code>Any</code> <p>Caller name used for the exception and error message</p> required Source code in <code>         muxtools/utils/files.py       </code> <pre><code>def ensure_path_exists(pathIn: PathLike | list[PathLike] | GlobSearch, caller: Any, allow_dir: bool = False) -&gt; Path:\n    \"\"\"\n    Utility function for other functions to make sure a path was passed to them and that it exists.\n\n    :param pathIn:      Supposed passed Path\n    :param caller:      Caller name used for the exception and error message\n    \"\"\"\n    from ..muxing.muxfiles import MuxingFile\n\n    if isinstance(pathIn, MuxingFile):\n        return ensure_path_exists(pathIn.file, caller)\n    if isinstance(pathIn, GlobSearch):\n        pathIn = pathIn.paths\n    if isinstance(pathIn, list):\n        pathIn = pathIn[0]\n    path = ensure_path(pathIn, caller)\n    if not path.exists():\n        raise crit(f\"Path target '{path}' does not exist.\", caller)\n    if not allow_dir and path.is_dir():\n        raise crit(\"Path cannot be a directory.\", caller)\n    return path\n</code></pre>"},{"location":"muxtools/utils/files/#muxtools.utils.files.get_crc32","title":"<code>get_crc32(file)</code>","text":"<p>Generates crc32 checksum for file</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Input file</p> required <p>Returns:</p> Type Description <code>str</code> <p>Checksum for file</p> Source code in <code>         muxtools/utils/files.py       </code> <pre><code>def get_crc32(file: PathLike) -&gt; str:\n    \"\"\"\n    Generates crc32 checksum for file\n\n    :param file:        Input file\n\n    :return:            Checksum for file\n    \"\"\"\n    try:\n        from zlib import crc32\n    except:\n        from binascii import crc32\n\n    buffer_size = 1024 * 1024 * 32\n    val = 0\n    with open(file, \"rb\") as f:\n        buffer = f.read(buffer_size)\n        while len(buffer) &gt; 0:\n            val = crc32(buffer, val)\n            buffer = f.read(buffer_size)\n\n    val = val &amp; 0xFFFFFFFF\n    return \"%08X\" % val\n</code></pre>"},{"location":"muxtools/utils/files/#muxtools.utils.files.uniquify_path","title":"<code>uniquify_path(path)</code>","text":"<p>Extends path to not conflict with existing files</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <p>Input file</p> required <p>Returns:</p> Type Description <code>str</code> <p>Unique path</p> Source code in <code>         muxtools/utils/files.py       </code> <pre><code>def uniquify_path(path: PathLike) -&gt; str:\n    \"\"\"\n    Extends path to not conflict with existing files\n\n    :param file:        Input file\n\n    :return:            Unique path\n    \"\"\"\n\n    if isinstance(path, Path):\n        path = str(path.resolve())\n\n    filename, extension = os.path.splitext(path)\n    counter = 1\n\n    while os.path.exists(path):\n        path = filename + \" (\" + str(counter) + \")\" + extension\n        counter += 1\n\n    return path\n</code></pre>"},{"location":"muxtools/utils/formats/","title":"formats","text":""},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat","title":"<code>AudioFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A collection of somewhat common known audio formats.</p> Source code in <code>           muxtools/utils/formats.py         </code> <pre><code>class AudioFormat(Enum):\n    \"\"\"\n    A collection of somewhat common known audio formats.\n    \"\"\"\n\n    display_name: str\n    codec_name: str\n    codec_long_name: str\n    is_lossy: bool\n    ext: str | None\n    profile: str | None\n\n    def __init__(self, display_name: str, codec_name: str, codec_long_name: str, is_lossy: bool, ext: str | None = None, profile: str | None = None):\n        self._value_ = display_name\n        self.display_name = display_name\n        self.codec_name = codec_name\n        self.codec_long_name = codec_long_name\n        self.is_lossy = is_lossy\n        self.ext = ext\n        self.profile = profile\n\n    @staticmethod\n    def from_track(track: streamType) -&gt; Optional[\"AudioFormat\"]:\n        matched_by_profile: AudioFormat | None = None\n        for form in AudioFormat:\n            if not form.profile:\n                continue\n            if form == track:\n                matched_by_profile = form\n                break\n\n        if matched_by_profile:\n            return matched_by_profile\n\n        matches = [form for form in AudioFormat if not form.profile and form == track]\n        return matches[0] if matches else None\n\n    @property\n    def extension(self) -&gt; str:\n        if not self.ext:\n            return self.codec_name.lower()\n\n        return self.ext\n\n    def should_not_transcode(self) -&gt; bool:\n        if self.is_lossy:\n            return True\n        if self in (AudioFormat.DTS_HD_X, AudioFormat.TRUEHD_ATMOS):\n            return True\n        return False\n\n    def __eq__(self, value: Any) -&gt; bool:\n        if isinstance(value, streamType):\n            profile_matches = value.profile and self.profile and self.profile.casefold() == value.profile.casefold()\n            if self.profile and not profile_matches:\n                return False\n\n            # Special case\n            if self.display_name == \"PCM\" and value.codec_name and self.codec_name and \"pcm\" in value.codec_name:\n                return bool(re.match(self.codec_name.replace(\"*\", \".*\"), value.codec_name, re.I))\n            else:\n                codec_matches = value.codec_name and self.codec_name.casefold() == value.codec_name.casefold()\n                codec_long_matches = value.codec_long_name and self.codec_long_name.casefold() == value.codec_long_name.casefold()\n\n                if self.profile:\n                    return profile_matches and (codec_matches or codec_long_matches)\n                else:\n                    return codec_matches and codec_long_matches\n        else:\n            return super.__eq__(self, value)\n\n    # Common lossy codecs\n    AC3 = \"AC-3\", \"ac3\", \"ATSC A/52A (AC-3)\", True\n    \"\"\"[Dolby Digital](https://en.wikipedia.org/wiki/Dolby_Digital)\"\"\"\n    EAC3 = \"EAC-3\", \"eac3\", \"ATSC A/52B (AC-3, E-AC-3)\", True\n    \"\"\"[Dolby Digital Plus](https://en.wikipedia.org/wiki/Dolby_Digital_Plus)\"\"\"\n    EAC3_ATMOS = \"EAC-3 Atmos\", \"eac3\", \"ATSC A/52B (AC-3, E-AC-3)\", True, None, \"Dolby Digital Plus + Dolby Atmos\"\n    \"\"\"[Dolby Digital Plus](https://en.wikipedia.org/wiki/Dolby_Digital_Plus) with [Atmos](https://en.wikipedia.org/wiki/Dolby_Atmos) metadata.\"\"\"\n    AAC = \"AAC\", \"aac\", \"AAC (Advanced Audio Coding)\", True\n    \"\"\"[Advanced Audio Coding](https://en.wikipedia.org/wiki/Advanced_Audio_Coding)\"\"\"\n    AAC_XHE = \"xHE-AAC\", \"aac\", \"AAC (Advanced Audio Coding)\", True, None, \"xHE-AAC\"\n    \"\"\"\n    A profile of AAC also sometimes known as [USAC](https://en.wikipedia.org/wiki/Unified_Speech_and_Audio_Coding).\\n\n    Compat for this is still not a given outside of mobile devices so transcoding may be recommended.\n    \"\"\"\n    OPUS = \"Opus\", \"opus\", \"Opus (Opus Interactive Audio Codec)\", True\n    \"\"\"[Opus](https://en.wikipedia.org/wiki/Opus_(audio_format))\"\"\"\n    VORBIS = \"Vorbis\", \"vorbis\", \"Vorbis\", True, \"ogg\"\n    \"\"\"[Vorbis](https://en.wikipedia.org/wiki/Vorbis)\"\"\"\n    MP3 = \"MP3\", \"mp3\", \"MP3 (MPEG audio layer 3)\", True\n    \"\"\"[MPEG-1 Audio Layer III](https://en.wikipedia.org/wiki/MP3)\"\"\"\n\n    # Common lossless codecs\n    FLAC = \"FLAC\", \"flac\", \"FLAC (Free Lossless Audio Codec)\", False\n    \"\"\"[Free Lossless Audio Codec](https://en.wikipedia.org/wiki/FLAC)\"\"\"\n    TRUEHD = \"TrueHD\", \"truehd\", \"TrueHD\", False, \"thd\"\n    \"\"\"[TrueHD](https://en.wikipedia.org/wiki/Dolby_TrueHD)\"\"\"\n    TRUEHD_ATMOS = \"TrueHD Atmos\", \"truehd\", \"TrueHD\", False, None, \"Dolby TrueHD + Dolby Atmos\"\n    \"\"\"[TrueHD](https://en.wikipedia.org/wiki/Dolby_TrueHD) with [Atmos](https://en.wikipedia.org/wiki/Dolby_Atmos) metadata.\"\"\"\n    PCM = \"PCM\", \"pcm_*\", \"PCM *\", False, \"wav\"\n    \"\"\"[Pulse-code modulation](https://en.wikipedia.org/wiki/Pulse-code_modulation)\"\"\"\n\n    # DTS Codecs\n    DTS = \"DTS\", \"dts\", \"DCA (DTS Coherent Acoustics)\", True\n    \"\"\"[DTS](https://en.wikipedia.org/wiki/DTS,_Inc.#DTS_Digital_Surround)\"\"\"\n    DTS_HD = \"DTS-HD MA\", \"dts\", \"DCA (DTS Coherent Acoustics)\", False, None, \"DTS-HD MA\"\n    \"\"\"\n    [DTS-HD Master Audio](https://en.wikipedia.org/wiki/DTS-HD_Master_Audio)\\n\n    is the lossless extension for DTS.\n    \"\"\"\n    DTS_HD_X = \"DTS-X\", \"dts\", \"DCA (DTS Coherent Acoustics)\", False, None, \"DTS-HD MA + DTS:X\"\n    \"\"\"[DTS-HD MA](https://en.wikipedia.org/wiki/DTS-HD_Master_Audio) with metadata for object-based surround sound similar to Atmos.\"\"\"\n    DTS_HRA = \"DTS-HR\", \"dts\", \"DCA (DTS Coherent Acoustics)\", True, None, \"DTS-HD HRA\"\n    \"\"\"Another lossy DTS variant with the supposed purpose of being higher bitrate and quality than DTS but still being substantially lower in size than lossless MA.\"\"\"\n    DTS_ES = \"DTS-ES\", \"dts\", \"DCA (DTS Coherent Acoustics)\", True, None, \"DTS-ES\"\n    \"\"\"Another lossy DTS variant that I honestly have no idea about in terms of what it's supposed to be used for.\"\"\"\n</code></pre>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.AC3","title":"<code>AC3 = ('AC-3', 'ac3', 'ATSC A/52A (AC-3)', True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dolby Digital</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.EAC3","title":"<code>EAC3 = ('EAC-3', 'eac3', 'ATSC A/52B (AC-3, E-AC-3)', True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dolby Digital Plus</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.EAC3_ATMOS","title":"<code>EAC3_ATMOS = ('EAC-3 Atmos', 'eac3', 'ATSC A/52B (AC-3, E-AC-3)', True, None, 'Dolby Digital Plus + Dolby Atmos')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dolby Digital Plus with Atmos metadata.</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.AAC","title":"<code>AAC = ('AAC', 'aac', 'AAC (Advanced Audio Coding)', True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Advanced Audio Coding</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.AAC_XHE","title":"<code>AAC_XHE = ('xHE-AAC', 'aac', 'AAC (Advanced Audio Coding)', True, None, 'xHE-AAC')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A profile of AAC also sometimes known as USAC.</p> <p>Compat for this is still not a given outside of mobile devices so transcoding may be recommended.</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.OPUS","title":"<code>OPUS = ('Opus', 'opus', 'Opus (Opus Interactive Audio Codec)', True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Opus</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.VORBIS","title":"<code>VORBIS = ('Vorbis', 'vorbis', 'Vorbis', True, 'ogg')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Vorbis</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.MP3","title":"<code>MP3 = ('MP3', 'mp3', 'MP3 (MPEG audio layer 3)', True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>MPEG-1 Audio Layer III</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.FLAC","title":"<code>FLAC = ('FLAC', 'flac', 'FLAC (Free Lossless Audio Codec)', False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Free Lossless Audio Codec</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.TRUEHD","title":"<code>TRUEHD = ('TrueHD', 'truehd', 'TrueHD', False, 'thd')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TrueHD</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.TRUEHD_ATMOS","title":"<code>TRUEHD_ATMOS = ('TrueHD Atmos', 'truehd', 'TrueHD', False, None, 'Dolby TrueHD + Dolby Atmos')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>TrueHD with Atmos metadata.</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.PCM","title":"<code>PCM = ('PCM', 'pcm_*', 'PCM *', False, 'wav')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Pulse-code modulation</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.DTS","title":"<code>DTS = ('DTS', 'dts', 'DCA (DTS Coherent Acoustics)', True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>DTS</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.DTS_HD","title":"<code>DTS_HD = ('DTS-HD MA', 'dts', 'DCA (DTS Coherent Acoustics)', False, None, 'DTS-HD MA')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>DTS-HD Master Audio</p> <p>is the lossless extension for DTS.</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.DTS_HD_X","title":"<code>DTS_HD_X = ('DTS-X', 'dts', 'DCA (DTS Coherent Acoustics)', False, None, 'DTS-HD MA + DTS:X')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>DTS-HD MA with metadata for object-based surround sound similar to Atmos.</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.DTS_HRA","title":"<code>DTS_HRA = ('DTS-HR', 'dts', 'DCA (DTS Coherent Acoustics)', True, None, 'DTS-HD HRA')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Another lossy DTS variant with the supposed purpose of being higher bitrate and quality than DTS but still being substantially lower in size than lossless MA.</p>"},{"location":"muxtools/utils/formats/#muxtools.utils.formats.AudioFormat.DTS_ES","title":"<code>DTS_ES = ('DTS-ES', 'dts', 'DCA (DTS Coherent Acoustics)', True, None, 'DTS-ES')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Another lossy DTS variant that I honestly have no idea about in terms of what it's supposed to be used for.</p>"},{"location":"muxtools/utils/glob/","title":"glob","text":""},{"location":"muxtools/utils/glob/#muxtools.utils.glob.GlobSearch","title":"<code>GlobSearch</code>","text":"Source code in <code>           muxtools/utils/glob.py         </code> <pre><code>class GlobSearch:\n    paths: list[Path]\n\n    def __init__(\n        self,\n        pattern: str,\n        allow_multiple: bool = False,\n        dir: PathLike = None,\n        recursive: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Glob Pattern based search for files\n\n        :param pattern:         Glob pattern\n        :param allow_multiple:  Will return all file matches if True and only the first if False\n        :param dir:             Directory to run the search in. Defaults to current working dir.\n        :param recursive:       Search recursively\n        \"\"\"\n        self.paths = []\n        dir = Path(dir) if isinstance(dir, str) else dir\n\n        if dir is None:\n            dir = Path(os.getcwd()).resolve()\n\n        search = dir.rglob(pattern) if recursive else dir.glob(pattern)\n\n        for f in search:\n            self.paths.append(f)\n\n            if not allow_multiple:\n                break\n</code></pre>"},{"location":"muxtools/utils/glob/#muxtools.utils.glob.GlobSearch.__init__","title":"<code>__init__(pattern, allow_multiple=False, dir=None, recursive=True)</code>","text":"<p>Glob Pattern based search for files</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Glob pattern</p> required <code>allow_multiple</code> <code>bool</code> <p>Will return all file matches if True and only the first if False</p> <code>False</code> <code>dir</code> <code>PathLike</code> <p>Directory to run the search in. Defaults to current working dir.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Search recursively</p> <code>True</code> Source code in <code>         muxtools/utils/glob.py       </code> <pre><code>def __init__(\n    self,\n    pattern: str,\n    allow_multiple: bool = False,\n    dir: PathLike = None,\n    recursive: bool = True,\n) -&gt; None:\n    \"\"\"\n    Glob Pattern based search for files\n\n    :param pattern:         Glob pattern\n    :param allow_multiple:  Will return all file matches if True and only the first if False\n    :param dir:             Directory to run the search in. Defaults to current working dir.\n    :param recursive:       Search recursively\n    \"\"\"\n    self.paths = []\n    dir = Path(dir) if isinstance(dir, str) else dir\n\n    if dir is None:\n        dir = Path(os.getcwd()).resolve()\n\n    search = dir.rglob(pattern) if recursive else dir.glob(pattern)\n\n    for f in search:\n        self.paths.append(f)\n\n        if not allow_multiple:\n            break\n</code></pre>"},{"location":"muxtools/utils/probe/","title":"probe","text":""},{"location":"muxtools/utils/probe/#muxtools.utils.probe.ParsedFile","title":"<code>ParsedFile</code>  <code>dataclass</code>","text":"Source code in <code>           muxtools/utils/probe.py         </code> <pre><code>@dataclass\nclass ParsedFile:\n    container_info: ContainerInfo\n    tracks: list[TrackInfo]\n    is_video_file: bool\n    source: Path\n\n    raw_ffprobe: ffprobeType\n    raw_mkvmerge: MKVInfo | None\n\n    @staticmethod\n    def from_file(path: PathLike, caller: Any | None = None, allow_mkvmerge_warning: bool = True) -&gt; \"ParsedFile\":\n        \"\"\"\n        Parses a file with ffprobe and, if given and a video track is found, mkvmerge.\n\n        :param path:                    Any file.\n        :param caller:                  Caller used for logging. Mostly intended for internal use.\n        :param allow_mkvmerge_warning:  If the warning for a missing mkvmerge install should actually be printed.\\n\n                                        Again, for internal use.\n        \"\"\"\n        path = ensure_path_exists(path, caller)\n        ffprobe_exe = get_executable(\"ffprobe\")\n        try:\n            out = probe_obj(path, cmd=ffprobe_exe, show_chapters=True)\n            assert out and out.format\n        except:\n            raise error(f\"Failed to parse file '{path.stem}' with ffprobe!\", caller)\n\n        if not out.streams or not out.streams.stream or \"tty\" in out.format.format_name:\n            return ParsedFile(ContainerInfo(0, \"Unknown\", None, {}, out.format, None), [], False, path, out)\n\n        is_video_file = bool([stream for stream in out.streams.stream if (stream.codec_type or \"\").lower() == \"video\"])\n        container_info = ContainerInfo(\n            out.format.nb_streams or 0, out.format.format_name or \"\", out.format.format_long_name, tags_to_dict(out.format.tags), out.format, None\n        )\n        mkvmerge_exe = get_executable(\"mkvmerge\", can_error=False)\n        mkvmerge_out = None\n        if not mkvmerge_exe and is_video_file:\n            if allow_mkvmerge_warning:\n                warn(\"Could not find mkvmerge. This is required to parse any container-delay, so beware!\", caller)\n        elif is_video_file:\n            try:\n                mkvmerge_out = MKVInfo.from_file(path, mkvmerge=mkvmerge_exe)\n                container_info.raw_mkvmerge = mkvmerge_out.container\n            except:\n                warn(\"Could not parse file with mkvmerge!\", caller)\n\n        sorted_streams = sorted(out.streams.stream, key=lambda s: -1 if not s.index else s.index)\n        tracks = list[TrackInfo]()\n        for type, values in groupby(sorted_streams, lambda v: v.codec_type):\n            if not type:\n                raise error(f\"Could not get codec_type for some tracks in '{path.stem}'!\", caller)\n            for i, track in enumerate(values):\n                mkvmerge_meta = None\n                if mkvmerge_out and type in [\"video\", \"audio\", \"subtitle\"]:\n                    found = [tr for tr in mkvmerge_out.tracks if tr.id == track.index and type in tr.type.name.lower()]\n                    mkvmerge_meta = found[0] if found else None\n                codec_name = track.codec_name\n                if track.codec_type == \"attachment\" and not codec_name:\n                    codec_name = \"attachment\"\n                if not codec_name:\n                    raise error(f\"Track {track.index} in '{path.stem}' does not have a codec_name!\", caller)\n                is_default = bool(track.disposition.default) if track.disposition and track.disposition.default else False\n                is_forced = bool(track.disposition.forced) if track.disposition and track.disposition.forced else False\n                container_delay = 0\n                if mkvmerge_out and mkvmerge_meta and mkvmerge_meta.properties.minimum_timestamp:\n                    timescale = mkvmerge_out.container.properties.timestamp_scale\n                    if timescale is None:\n                        warn(f\"Mkvmerge could not get a timestamp_scale from '{path.stem}'! Ignoring any possible container delays.\", caller)\n                    else:\n                        min_timestamp = mkvmerge_meta.properties.minimum_timestamp / timescale\n                        if mkvmerge_meta.properties.codec_delay:\n                            min_timestamp = max(min_timestamp - (mkvmerge_meta.properties.codec_delay / timescale), 0)\n                        container_delay = int(min_timestamp)\n\n                tags = tags_to_dict(track.tags)\n                language = tags.pop(\"language\", None)\n                title = tags.pop(\"title\", None)\n\n                track_type = [ttype for ttype in TrackType if ttype.name.lower() in type.lower()]\n                if not track_type:\n                    raise error(f\"Unknown track type for '{type}' in '{path.stem}'!\", caller)\n\n                trackinfo = TrackInfo(\n                    index=track.index,\n                    relative_index=i,\n                    codec_name=codec_name,\n                    codec_long_name=track.codec_long_name,\n                    type=track_type[0],\n                    profile=track.profile,\n                    language=language,\n                    title=title,\n                    is_default=is_default,\n                    is_forced=is_forced,\n                    container_delay=container_delay,\n                    other_tags=tags,\n                    raw_ffprobe=track,\n                    raw_mkvmerge=mkvmerge_meta,\n                )\n                tracks.append(trackinfo)\n\n        return ParsedFile(container_info, tracks, is_video_file, path, out, mkvmerge_out)\n\n    def find_tracks(\n        self,\n        name: str | None = None,\n        lang: str | None = None,\n        type: TrackType | None = None,\n        relative_id: int | list[int] | None = None,\n        use_regex: bool = True,\n        reverse_lang: bool = False,\n        custom_condition: Callable[[TrackInfo], bool] | None = None,\n        error_if_empty: bool = False,\n        caller: Any | None = None,\n    ) -&gt; list[TrackInfo]:\n        \"\"\"\n        Convenience function to find tracks with some conditions.\n\n        :param name:                Name to match, case insensitively and preceeding/leading whitespace removed.\n        :param lang:                Language to match. This can be any of the possible formats like English/eng/en and is case insensitive.\n        :param type:                Track Type to search for.\n        :param relative_id:         What relative (to the type) indices the tracks should have.\n        :param use_regex:           Use regex for the name search instead of checking for equality.\n        :param reverse_lang:        If you want the `lang` param to actually exclude that language.\n        :param custom_condition:    Here you can pass any function to create your own conditions. (They have to return a bool)\\n\n                                    For example: `custom_condition=lambda track: track.codec_name == \"eac3\"`\n        :param error_if_empty:      Throw an error instead of returning an empty list if nothing was found for the given conditions.\n        :param caller:              Caller to use for logging. Mostly intended for internal use.\n        \"\"\"\n\n        if not name and not lang and not type and relative_id is None and custom_condition is None:\n            return []\n        if relative_id is not None and type is None:\n            raise error(\"You can only search for a relative id with a specific track type!\", caller or self.find_tracks)\n\n        tracks = self.tracks\n\n        def name_matches(title: str) -&gt; bool:\n            if title.casefold().strip() == name.casefold().strip():\n                return True\n            if use_regex:\n                return re.match(name, title, re.I)\n            return False\n\n        def get_languages(track: TrackInfo) -&gt; list[str]:\n            languages = list[str | None]()\n            languages.append(track.language)\n            if track.raw_mkvmerge:\n                languages.append(track.raw_mkvmerge.properties.language)\n                languages.append(track.raw_mkvmerge.properties.language_ietf)\n            return [lang.casefold() for lang in languages if lang]\n\n        if name:\n            tracks = [track for track in tracks if name_matches(track.title or \"\")]\n\n        if lang:\n            if reverse_lang:\n                tracks = [track for track in tracks if lang.casefold() not in get_languages(track)]\n            else:\n                tracks = [track for track in tracks if lang.casefold() in get_languages(track)]\n\n        if type:\n            if type not in (TrackType.VIDEO, TrackType.AUDIO, TrackType.SUB):\n                raise error(\"You can only search for video, audio and subtitle tracks!\", caller or self.find_tracks)\n            tracks = [track for track in tracks if track.type == type]\n\n        if relative_id is not None:\n            if not isinstance(relative_id, list):\n                relative_id = [relative_id]\n            tracks = [track for track in tracks if track.relative_index in relative_id]\n\n        if custom_condition:\n            tracks = [track for track in tracks if custom_condition(track)]\n\n        if not tracks and error_if_empty:\n            raise error(f\"Could not find requested track in '{self.source.name}'!\", caller or self.find_tracks)\n\n        return tracks\n</code></pre>"},{"location":"muxtools/utils/probe/#muxtools.utils.probe.ParsedFile.find_tracks","title":"<code>find_tracks(name=None, lang=None, type=None, relative_id=None, use_regex=True, reverse_lang=False, custom_condition=None, error_if_empty=False, caller=None)</code>","text":"<p>Convenience function to find tracks with some conditions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to match, case insensitively and preceeding/leading whitespace removed.</p> <code>None</code> <code>lang</code> <code>str | None</code> <p>Language to match. This can be any of the possible formats like English/eng/en and is case insensitive.</p> <code>None</code> <code>type</code> <code>TrackType | None</code> <p>Track Type to search for.</p> <code>None</code> <code>relative_id</code> <code>int | list[int] | None</code> <p>What relative (to the type) indices the tracks should have.</p> <code>None</code> <code>use_regex</code> <code>bool</code> <p>Use regex for the name search instead of checking for equality.</p> <code>True</code> <code>reverse_lang</code> <code>bool</code> <p>If you want the <code>lang</code> param to actually exclude that language.</p> <code>False</code> <code>custom_condition</code> <code>Callable[[TrackInfo], bool] | None</code> <p>Here you can pass any function to create your own conditions. (They have to return a bool)  For example: <code>custom_condition=lambda track: track.codec_name == \"eac3\"</code></p> <code>None</code> <code>error_if_empty</code> <code>bool</code> <p>Throw an error instead of returning an empty list if nothing was found for the given conditions.</p> <code>False</code> <code>caller</code> <code>Any | None</code> <p>Caller to use for logging. Mostly intended for internal use.</p> <code>None</code> Source code in <code>         muxtools/utils/probe.py       </code> <pre><code>def find_tracks(\n    self,\n    name: str | None = None,\n    lang: str | None = None,\n    type: TrackType | None = None,\n    relative_id: int | list[int] | None = None,\n    use_regex: bool = True,\n    reverse_lang: bool = False,\n    custom_condition: Callable[[TrackInfo], bool] | None = None,\n    error_if_empty: bool = False,\n    caller: Any | None = None,\n) -&gt; list[TrackInfo]:\n    \"\"\"\n    Convenience function to find tracks with some conditions.\n\n    :param name:                Name to match, case insensitively and preceeding/leading whitespace removed.\n    :param lang:                Language to match. This can be any of the possible formats like English/eng/en and is case insensitive.\n    :param type:                Track Type to search for.\n    :param relative_id:         What relative (to the type) indices the tracks should have.\n    :param use_regex:           Use regex for the name search instead of checking for equality.\n    :param reverse_lang:        If you want the `lang` param to actually exclude that language.\n    :param custom_condition:    Here you can pass any function to create your own conditions. (They have to return a bool)\\n\n                                For example: `custom_condition=lambda track: track.codec_name == \"eac3\"`\n    :param error_if_empty:      Throw an error instead of returning an empty list if nothing was found for the given conditions.\n    :param caller:              Caller to use for logging. Mostly intended for internal use.\n    \"\"\"\n\n    if not name and not lang and not type and relative_id is None and custom_condition is None:\n        return []\n    if relative_id is not None and type is None:\n        raise error(\"You can only search for a relative id with a specific track type!\", caller or self.find_tracks)\n\n    tracks = self.tracks\n\n    def name_matches(title: str) -&gt; bool:\n        if title.casefold().strip() == name.casefold().strip():\n            return True\n        if use_regex:\n            return re.match(name, title, re.I)\n        return False\n\n    def get_languages(track: TrackInfo) -&gt; list[str]:\n        languages = list[str | None]()\n        languages.append(track.language)\n        if track.raw_mkvmerge:\n            languages.append(track.raw_mkvmerge.properties.language)\n            languages.append(track.raw_mkvmerge.properties.language_ietf)\n        return [lang.casefold() for lang in languages if lang]\n\n    if name:\n        tracks = [track for track in tracks if name_matches(track.title or \"\")]\n\n    if lang:\n        if reverse_lang:\n            tracks = [track for track in tracks if lang.casefold() not in get_languages(track)]\n        else:\n            tracks = [track for track in tracks if lang.casefold() in get_languages(track)]\n\n    if type:\n        if type not in (TrackType.VIDEO, TrackType.AUDIO, TrackType.SUB):\n            raise error(\"You can only search for video, audio and subtitle tracks!\", caller or self.find_tracks)\n        tracks = [track for track in tracks if track.type == type]\n\n    if relative_id is not None:\n        if not isinstance(relative_id, list):\n            relative_id = [relative_id]\n        tracks = [track for track in tracks if track.relative_index in relative_id]\n\n    if custom_condition:\n        tracks = [track for track in tracks if custom_condition(track)]\n\n    if not tracks and error_if_empty:\n        raise error(f\"Could not find requested track in '{self.source.name}'!\", caller or self.find_tracks)\n\n    return tracks\n</code></pre>"},{"location":"muxtools/utils/probe/#muxtools.utils.probe.ParsedFile.from_file","title":"<code>from_file(path, caller=None, allow_mkvmerge_warning=True)</code>  <code>staticmethod</code>","text":"<p>Parses a file with ffprobe and, if given and a video track is found, mkvmerge.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>Any file.</p> required <code>caller</code> <code>Any | None</code> <p>Caller used for logging. Mostly intended for internal use.</p> <code>None</code> <code>allow_mkvmerge_warning</code> <code>bool</code> <p>If the warning for a missing mkvmerge install should actually be printed.  Again, for internal use.</p> <code>True</code> Source code in <code>         muxtools/utils/probe.py       </code> <pre><code>@staticmethod\ndef from_file(path: PathLike, caller: Any | None = None, allow_mkvmerge_warning: bool = True) -&gt; \"ParsedFile\":\n    \"\"\"\n    Parses a file with ffprobe and, if given and a video track is found, mkvmerge.\n\n    :param path:                    Any file.\n    :param caller:                  Caller used for logging. Mostly intended for internal use.\n    :param allow_mkvmerge_warning:  If the warning for a missing mkvmerge install should actually be printed.\\n\n                                    Again, for internal use.\n    \"\"\"\n    path = ensure_path_exists(path, caller)\n    ffprobe_exe = get_executable(\"ffprobe\")\n    try:\n        out = probe_obj(path, cmd=ffprobe_exe, show_chapters=True)\n        assert out and out.format\n    except:\n        raise error(f\"Failed to parse file '{path.stem}' with ffprobe!\", caller)\n\n    if not out.streams or not out.streams.stream or \"tty\" in out.format.format_name:\n        return ParsedFile(ContainerInfo(0, \"Unknown\", None, {}, out.format, None), [], False, path, out)\n\n    is_video_file = bool([stream for stream in out.streams.stream if (stream.codec_type or \"\").lower() == \"video\"])\n    container_info = ContainerInfo(\n        out.format.nb_streams or 0, out.format.format_name or \"\", out.format.format_long_name, tags_to_dict(out.format.tags), out.format, None\n    )\n    mkvmerge_exe = get_executable(\"mkvmerge\", can_error=False)\n    mkvmerge_out = None\n    if not mkvmerge_exe and is_video_file:\n        if allow_mkvmerge_warning:\n            warn(\"Could not find mkvmerge. This is required to parse any container-delay, so beware!\", caller)\n    elif is_video_file:\n        try:\n            mkvmerge_out = MKVInfo.from_file(path, mkvmerge=mkvmerge_exe)\n            container_info.raw_mkvmerge = mkvmerge_out.container\n        except:\n            warn(\"Could not parse file with mkvmerge!\", caller)\n\n    sorted_streams = sorted(out.streams.stream, key=lambda s: -1 if not s.index else s.index)\n    tracks = list[TrackInfo]()\n    for type, values in groupby(sorted_streams, lambda v: v.codec_type):\n        if not type:\n            raise error(f\"Could not get codec_type for some tracks in '{path.stem}'!\", caller)\n        for i, track in enumerate(values):\n            mkvmerge_meta = None\n            if mkvmerge_out and type in [\"video\", \"audio\", \"subtitle\"]:\n                found = [tr for tr in mkvmerge_out.tracks if tr.id == track.index and type in tr.type.name.lower()]\n                mkvmerge_meta = found[0] if found else None\n            codec_name = track.codec_name\n            if track.codec_type == \"attachment\" and not codec_name:\n                codec_name = \"attachment\"\n            if not codec_name:\n                raise error(f\"Track {track.index} in '{path.stem}' does not have a codec_name!\", caller)\n            is_default = bool(track.disposition.default) if track.disposition and track.disposition.default else False\n            is_forced = bool(track.disposition.forced) if track.disposition and track.disposition.forced else False\n            container_delay = 0\n            if mkvmerge_out and mkvmerge_meta and mkvmerge_meta.properties.minimum_timestamp:\n                timescale = mkvmerge_out.container.properties.timestamp_scale\n                if timescale is None:\n                    warn(f\"Mkvmerge could not get a timestamp_scale from '{path.stem}'! Ignoring any possible container delays.\", caller)\n                else:\n                    min_timestamp = mkvmerge_meta.properties.minimum_timestamp / timescale\n                    if mkvmerge_meta.properties.codec_delay:\n                        min_timestamp = max(min_timestamp - (mkvmerge_meta.properties.codec_delay / timescale), 0)\n                    container_delay = int(min_timestamp)\n\n            tags = tags_to_dict(track.tags)\n            language = tags.pop(\"language\", None)\n            title = tags.pop(\"title\", None)\n\n            track_type = [ttype for ttype in TrackType if ttype.name.lower() in type.lower()]\n            if not track_type:\n                raise error(f\"Unknown track type for '{type}' in '{path.stem}'!\", caller)\n\n            trackinfo = TrackInfo(\n                index=track.index,\n                relative_index=i,\n                codec_name=codec_name,\n                codec_long_name=track.codec_long_name,\n                type=track_type[0],\n                profile=track.profile,\n                language=language,\n                title=title,\n                is_default=is_default,\n                is_forced=is_forced,\n                container_delay=container_delay,\n                other_tags=tags,\n                raw_ffprobe=track,\n                raw_mkvmerge=mkvmerge_meta,\n            )\n            tracks.append(trackinfo)\n\n    return ParsedFile(container_info, tracks, is_video_file, path, out, mkvmerge_out)\n</code></pre>"},{"location":"muxtools/utils/types/","title":"types","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.Chapter","title":"<code>Chapter = tuple[timedelta | int, Optional[str]]</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.PathLike","title":"<code>PathLike = Union[Path, str, None]</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.Paths","title":"<code>Paths = Union[PathLike, list[PathLike]]</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TimeScaleT","title":"<code>TimeScaleT = Union[TimeScale, Fraction, int, None]</code>  <code>module-attribute</code>","text":"<p>Unit of time (in seconds) in terms of which frame timestamps are represented.</p> <p>While you can pass an int, the needed type is always a Fraction and will be converted via <code>Fraction(your_int)</code>.</p> <p><code>None</code> will usually fallback to a generic mkv timescale but exact behavior might differ based on the target function.</p>"},{"location":"muxtools/utils/types/#muxtools.utils.types.TimeSourceT","title":"<code>TimeSourceT = Union[PathLike, Fraction, float, list, VideoMeta, ABCTimestamps, None]</code>  <code>module-attribute</code>","text":"<p>The source of timestamps/timecodes.</p> <p>For actual timestamps, this can be a timestamps (v1/v2/v4) file, a video file or a list of integers.</p> <p>For FPS based timestamps, this can be a Fraction object, a float or even a string representing a fraction.</p> <p>Like <code>'24000/1001'</code>.</p> <p>Can also be an already instantiated Timestamps class from the videotimestamps library.</p> <p><code>None</code> will usually fallback to 24000/1001 but exact behavior might differ based on the target function.</p>"},{"location":"muxtools/utils/types/#muxtools.utils.types.Trim","title":"<code>Trim = tuple[int | None, int | None]</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.__all__","title":"<code>__all__ = ['PathLike', 'Paths', 'Trim', 'TrackType', 'AudioFrame', 'AudioStats', 'AudioInfo', 'Chapter', 'DitherType', 'LossyWavQuality', 'VideoMeta', 'TimeScale']</code>  <code>module-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioFrame","title":"<code>AudioFrame</code>  <code>dataclass</code>","text":"<p>A dataclass representing ffmpeg's <code>ashowdata</code> filter output.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The (sequential) number of the input frame, starting from 0</p> required <code>pts</code> <code>int</code> <p>The presentation timestamp of the input frame, in time base units the time base depends on the filter input pad, and is usually 1/sample_rate</p> required <code>pts_time</code> <code>float</code> <p>The presentation timestamp of the input frame in seconds</p> required <code>num_samples</code> <code>int</code> <p>Number of samples in a frame (can also be refered to as frame length or size)</p> required Source code in <code>           muxtools/utils/types.py         </code> <pre><code>@dataclass\nclass AudioFrame:\n    \"\"\"\n    A dataclass representing ffmpeg's `ashowdata` filter output.\n\n    :param n:           The (sequential) number of the input frame, starting from 0\n    :param pts:         The presentation timestamp of the input frame, in time base units\n                        the time base depends on the filter input pad, and is usually 1/sample_rate\n\n    :param pts_time:    The presentation timestamp of the input frame in seconds\n    :param num_samples: Number of samples in a frame (can also be refered to as frame length or size)\n    \"\"\"\n\n    n: int\n    pts: int\n    pts_time: float\n    num_samples: int\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioFrame.n","title":"<code>n</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioFrame.num_samples","title":"<code>num_samples</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioFrame.pts","title":"<code>pts</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioFrame.pts_time","title":"<code>pts_time</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioFrame.__init__","title":"<code>__init__</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioInfo","title":"<code>AudioInfo</code>  <code>dataclass</code>","text":"Source code in <code>           muxtools/utils/types.py         </code> <pre><code>@dataclass\nclass AudioInfo:\n    stats: AudioStats = None\n    frames: list[AudioFrame] | None = None\n\n    def num_samples(self) -&gt; int:\n        for frame in self.frames:\n            if frame.num_samples:\n                return frame.num_samples\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioInfo.frames","title":"<code>frames = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioInfo.stats","title":"<code>stats = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioInfo.__init__","title":"<code>__init__</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioInfo.num_samples","title":"<code>num_samples</code>","text":"Source code in <code>         muxtools/utils/types.py       </code> <pre><code>def num_samples(self) -&gt; int:\n    for frame in self.frames:\n        if frame.num_samples:\n            return frame.num_samples\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats","title":"<code>AudioStats</code>  <code>dataclass</code>","text":"<p>A dataclass representing ffmpeg's <code>astats</code> filter output.</p> <p>Too many attributes to document to be honest.</p> <p>See https://ffmpeg.org/ffmpeg-filters.html#astats-1</p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>@dataclass\nclass AudioStats:\n    \"\"\"\n    A dataclass representing ffmpeg's `astats` filter output.\n\n    Too many attributes to document to be honest.\n\n    See https://ffmpeg.org/ffmpeg-filters.html#astats-1\n    \"\"\"\n\n    dc_offset: float = 0.0\n    min_level: float = 0.0\n    max_level: float = 0.0\n    min_difference: float = 0.0\n    max_difference: float = 0.0\n    mean_difference: float = 0.0\n    rms_difference: float = 0.0\n    peak_level_db: float = 0.0\n    rms_level_db: float = 0.0\n    rms_peak_db: float = 0.0\n    rms_trough_db: float = 0.0\n    flat_factor: float = 0.0\n    peak_count: float = 0.0\n    noise_floor_db: float = 0.0\n    noise_floor_count: float = 0.0\n    entropy: float = 0.0\n    bit_depth: str = \"\"\n    number_of_samples: int = 0\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.bit_depth","title":"<code>bit_depth = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.dc_offset","title":"<code>dc_offset = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.entropy","title":"<code>entropy = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.flat_factor","title":"<code>flat_factor = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.max_difference","title":"<code>max_difference = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.max_level","title":"<code>max_level = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.mean_difference","title":"<code>mean_difference = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.min_difference","title":"<code>min_difference = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.min_level","title":"<code>min_level = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.noise_floor_count","title":"<code>noise_floor_count = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.noise_floor_db","title":"<code>noise_floor_db = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.number_of_samples","title":"<code>number_of_samples = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.peak_count","title":"<code>peak_count = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.peak_level_db","title":"<code>peak_level_db = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.rms_difference","title":"<code>rms_difference = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.rms_level_db","title":"<code>rms_level_db = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.rms_peak_db","title":"<code>rms_peak_db = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.rms_trough_db","title":"<code>rms_trough_db = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.AudioStats.__init__","title":"<code>__init__</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType","title":"<code>DitherType</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>FFMPEG Dither Methods, see https://ffmpeg.org/ffmpeg-resampler.html#Resampler-Options</p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>class DitherType(IntEnum):\n    \"\"\"\n    FFMPEG Dither Methods, see https://ffmpeg.org/ffmpeg-resampler.html#Resampler-Options\n    \"\"\"\n\n    RECTANGULAR = 1\n    TRIANGULAR = 2  # Allegedly SoX's default\n    TRIANGULAR_HP = 3\n    LIPSHITZ = 4\n    SHIBATA = 5  # Foobar uses this for example\n    LOW_SHIBATA = 6\n    HIGH_SHIBATA = 7\n    F_WEIGHTED = 8\n    MODIFIED_E_WEIGHTED = 9\n    IMPROVED_E_WEIGHTED = 10\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.F_WEIGHTED","title":"<code>F_WEIGHTED = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.HIGH_SHIBATA","title":"<code>HIGH_SHIBATA = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.IMPROVED_E_WEIGHTED","title":"<code>IMPROVED_E_WEIGHTED = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.LIPSHITZ","title":"<code>LIPSHITZ = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.LOW_SHIBATA","title":"<code>LOW_SHIBATA = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.MODIFIED_E_WEIGHTED","title":"<code>MODIFIED_E_WEIGHTED = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.RECTANGULAR","title":"<code>RECTANGULAR = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.SHIBATA","title":"<code>SHIBATA = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.TRIANGULAR","title":"<code>TRIANGULAR = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.DitherType.TRIANGULAR_HP","title":"<code>TRIANGULAR_HP = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality","title":"<code>LossyWavQuality</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>LossyWAV Quality presets, see https://wiki.hydrogenaud.io/index.php?title=LossyWAV#Quality_presets</p> <p>TL;DR: Insane the least lossy, ExtraPortable the most lossy.</p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>class LossyWavQuality(IntEnum):\n    \"\"\"\n    LossyWAV Quality presets, see https://wiki.hydrogenaud.io/index.php?title=LossyWAV#Quality_presets\n\n    TL;DR: Insane the least lossy, ExtraPortable the most lossy.\n    \"\"\"\n\n    INSANE = 1\n    EXTREME = 2\n    HIGH = 3\n    STANDARD = 4\n    ECONOMIC = 5\n    PORTABLE = 6\n    EXTRAPORTABLE = 7\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.ECONOMIC","title":"<code>ECONOMIC = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.EXTRAPORTABLE","title":"<code>EXTRAPORTABLE = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.EXTREME","title":"<code>EXTREME = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.HIGH","title":"<code>HIGH = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.INSANE","title":"<code>INSANE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.PORTABLE","title":"<code>PORTABLE = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.LossyWavQuality.STANDARD","title":"<code>STANDARD = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TimeScale","title":"<code>TimeScale</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Convenience enum for some common timescales.</p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>class TimeScale(IntEnum):\n    \"\"\"Convenience enum for some common timescales.\"\"\"\n\n    MKV = 1000\n    \"\"\"Typical matroska timescale\"\"\"\n    MATROSKA = MKV\n    \"\"\"Alias for MKV\"\"\"\n    M2TS = 90000\n    \"\"\"Typical m2ts timescale\"\"\"\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.TimeScale.M2TS","title":"<code>M2TS = 90000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Typical m2ts timescale</p>"},{"location":"muxtools/utils/types/#muxtools.utils.types.TimeScale.MATROSKA","title":"<code>MATROSKA = MKV</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Alias for MKV</p>"},{"location":"muxtools/utils/types/#muxtools.utils.types.TimeScale.MKV","title":"<code>MKV = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Typical matroska timescale</p>"},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType","title":"<code>TrackType</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>class TrackType(IntEnum):\n    VIDEO = 1\n    AUDIO = 2\n    SUB = 3\n    ATTACHMENT = 4\n    CHAPTERS = 5\n    MKV = 6\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType.ATTACHMENT","title":"<code>ATTACHMENT = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType.AUDIO","title":"<code>AUDIO = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType.CHAPTERS","title":"<code>CHAPTERS = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType.MKV","title":"<code>MKV = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType.SUB","title":"<code>SUB = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.TrackType.VIDEO","title":"<code>VIDEO = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType","title":"<code>ValidInputType</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>class ValidInputType(IntEnum):\n    FLAC = 1\n    W64 = 3\n    RF64 = 4\n    W64_OR_FLAC = 6\n    RF64_OR_FLAC = 7\n\n    def allows_flac(self) -&gt; bool:\n        return \"_OR_FLAC\" in str(self.name)\n\n    def remove_flac(self):\n        match self:\n            case ValidInputType.RF64_OR_FLAC:\n                return ValidInputType.RF64\n            case ValidInputType.W64_OR_FLAC:\n                return ValidInputType.W64\n\n        return ValidInputType.RF64\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.FLAC","title":"<code>FLAC = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.RF64","title":"<code>RF64 = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.RF64_OR_FLAC","title":"<code>RF64_OR_FLAC = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.W64","title":"<code>W64 = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.W64_OR_FLAC","title":"<code>W64_OR_FLAC = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.allows_flac","title":"<code>allows_flac</code>","text":"Source code in <code>         muxtools/utils/types.py       </code> <pre><code>def allows_flac(self) -&gt; bool:\n    return \"_OR_FLAC\" in str(self.name)\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.ValidInputType.remove_flac","title":"<code>remove_flac</code>","text":"Source code in <code>         muxtools/utils/types.py       </code> <pre><code>def remove_flac(self):\n    match self:\n        case ValidInputType.RF64_OR_FLAC:\n            return ValidInputType.RF64\n        case ValidInputType.W64_OR_FLAC:\n            return ValidInputType.W64\n\n    return ValidInputType.RF64\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta","title":"<code>VideoMeta</code>  <code>dataclass</code>","text":"Source code in <code>           muxtools/utils/types.py         </code> <pre><code>@dataclass\nclass VideoMeta:\n    pts: list[int]\n    fps: Fraction\n    timescale: Fraction\n    source: str\n\n    def to_json(self) -&gt; str:\n        return json.dumps(asdict(self), cls=FractionEncoder, indent=4)\n\n    @staticmethod\n    def from_json(file: PathLike) -&gt; \"VideoMeta\":\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            meta_json = json.loads(f.read(), object_hook=fraction_hook)\n            return VideoMeta(**meta_json)\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.fps","title":"<code>fps</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.pts","title":"<code>pts</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.source","title":"<code>source</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.timescale","title":"<code>timescale</code>  <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.__init__","title":"<code>__init__</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.from_json","title":"<code>from_json</code>  <code>staticmethod</code>","text":"Source code in <code>         muxtools/utils/types.py       </code> <pre><code>@staticmethod\ndef from_json(file: PathLike) -&gt; \"VideoMeta\":\n    with open(file, \"r\", encoding=\"utf-8\") as f:\n        meta_json = json.loads(f.read(), object_hook=fraction_hook)\n        return VideoMeta(**meta_json)\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.VideoMeta.to_json","title":"<code>to_json</code>","text":"Source code in <code>         muxtools/utils/types.py       </code> <pre><code>def to_json(self) -&gt; str:\n    return json.dumps(asdict(self), cls=FractionEncoder, indent=4)\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.qAAC_MODE","title":"<code>qAAC_MODE</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>           muxtools/utils/types.py         </code> <pre><code>class qAAC_MODE(IntEnum):\n    TVBR = 1\n    CVBR = 2\n    ABR = 3\n    CBR = 4\n</code></pre>"},{"location":"muxtools/utils/types/#muxtools.utils.types.qAAC_MODE.ABR","title":"<code>ABR = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.qAAC_MODE.CBR","title":"<code>CBR = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.qAAC_MODE.CVBR","title":"<code>CVBR = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"muxtools/utils/types/#muxtools.utils.types.qAAC_MODE.TVBR","title":"<code>TVBR = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vodesfunc/denoise/","title":"denoise","text":""},{"location":"vodesfunc/denoise/#vodesfunc.denoise.MVPresets","title":"<code>MVPresets</code>","text":"Source code in <code>           vodesfunc/denoise.py         </code> <pre><code>class MVPresets:\n    @classproperty\n    def MaybeNotTerrible(self) -&gt; MVToolsPreset:\n        \"\"\"\n        This is just me throwing stuff at the wall to have some improvements without major slowdowns.\n        \"\"\"\n        from vsdenoise import AnalyzeArgs, RecalculateArgs, SuperArgs, RFilterMode\n\n        return MVToolsPreset(\n            pel=1,\n            search_clip=prefilter_to_full_range,\n            super_args=SuperArgs(rfilter=RFilterMode.TRIANGLE),\n            analyze_args=AnalyzeArgs(truemotion=MotionMode.SAD, search=SearchMode.HEXAGON, pelsearch=2),\n            recalculate_args=RecalculateArgs(truemotion=MotionMode.SAD, search=SearchMode.HEXAGON, searchparam=1),\n        )\n\n    @classproperty\n    def ActualOldWrapperMatch(self) -&gt; MVToolsPreset:\n        \"\"\"\n        Preset to match the old wrapper as well as possible.\n        It is arguable if this is desirable.\n        \"\"\"\n        from vsdenoise import AnalyzeArgs, RecalculateArgs, SuperArgs, RFilterMode\n\n        return MVToolsPreset(\n            pel=1,\n            pad=16,\n            search_clip=prefilter_to_full_range,\n            super_args=SuperArgs(rfilter=RFilterMode.TRIANGLE),\n            analyze_args=AnalyzeArgs(truemotion=MotionMode.SAD, search=SearchMode.DIAMOND, pelsearch=2),\n            recalculate_args=RecalculateArgs(truemotion=MotionMode.SAD, search=SearchMode.ONETIME, searchparam=0),\n        )\n\n    @classproperty\n    def Default(self) -&gt; MVToolsPreset | None:\n        \"\"\"\n        Returns `MVPresets.MaybeNotTerrible` if used on a version where mc_degrain is available.\n        Otherwise `None`.\n        \"\"\"\n        if check_jetpack_version():\n            return MVPresets.MaybeNotTerrible\n        return None\n</code></pre>"},{"location":"vodesfunc/denoise/#vodesfunc.denoise.MVPresets.ActualOldWrapperMatch","title":"<code>ActualOldWrapperMatch()</code>","text":"<p>Preset to match the old wrapper as well as possible. It is arguable if this is desirable.</p> Source code in <code>         vodesfunc/denoise.py       </code> <pre><code>@classproperty\ndef ActualOldWrapperMatch(self) -&gt; MVToolsPreset:\n    \"\"\"\n    Preset to match the old wrapper as well as possible.\n    It is arguable if this is desirable.\n    \"\"\"\n    from vsdenoise import AnalyzeArgs, RecalculateArgs, SuperArgs, RFilterMode\n\n    return MVToolsPreset(\n        pel=1,\n        pad=16,\n        search_clip=prefilter_to_full_range,\n        super_args=SuperArgs(rfilter=RFilterMode.TRIANGLE),\n        analyze_args=AnalyzeArgs(truemotion=MotionMode.SAD, search=SearchMode.DIAMOND, pelsearch=2),\n        recalculate_args=RecalculateArgs(truemotion=MotionMode.SAD, search=SearchMode.ONETIME, searchparam=0),\n    )\n</code></pre>"},{"location":"vodesfunc/denoise/#vodesfunc.denoise.MVPresets.Default","title":"<code>Default()</code>","text":"<p>Returns <code>MVPresets.MaybeNotTerrible</code> if used on a version where mc_degrain is available. Otherwise <code>None</code>.</p> Source code in <code>         vodesfunc/denoise.py       </code> <pre><code>@classproperty\ndef Default(self) -&gt; MVToolsPreset | None:\n    \"\"\"\n    Returns `MVPresets.MaybeNotTerrible` if used on a version where mc_degrain is available.\n    Otherwise `None`.\n    \"\"\"\n    if check_jetpack_version():\n        return MVPresets.MaybeNotTerrible\n    return None\n</code></pre>"},{"location":"vodesfunc/denoise/#vodesfunc.denoise.MVPresets.MaybeNotTerrible","title":"<code>MaybeNotTerrible()</code>","text":"<p>This is just me throwing stuff at the wall to have some improvements without major slowdowns.</p> Source code in <code>         vodesfunc/denoise.py       </code> <pre><code>@classproperty\ndef MaybeNotTerrible(self) -&gt; MVToolsPreset:\n    \"\"\"\n    This is just me throwing stuff at the wall to have some improvements without major slowdowns.\n    \"\"\"\n    from vsdenoise import AnalyzeArgs, RecalculateArgs, SuperArgs, RFilterMode\n\n    return MVToolsPreset(\n        pel=1,\n        search_clip=prefilter_to_full_range,\n        super_args=SuperArgs(rfilter=RFilterMode.TRIANGLE),\n        analyze_args=AnalyzeArgs(truemotion=MotionMode.SAD, search=SearchMode.HEXAGON, pelsearch=2),\n        recalculate_args=RecalculateArgs(truemotion=MotionMode.SAD, search=SearchMode.HEXAGON, searchparam=1),\n    )\n</code></pre>"},{"location":"vodesfunc/denoise/#vodesfunc.denoise.VMDegrain","title":"<code>VMDegrain(src, thSAD=60, prefilter=2, smooth=True, block_size=None, overlap=None, refine=2, tr=2, preset=MVPresets.Default, **kwargs)</code>","text":"<p>Just some convenience function for mvtools with a useable preset and temporal smoothing.</p> <p>Check the MVTools Docs for the params that aren't listed below.</p> <p><code>block_size</code>, <code>overlap</code> and <code>refine</code> are using somewhat optimized defaults depending on the resolution if <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>VideoNode</code> <p>Input to denoise</p> required <code>smooth</code> <code>bool</code> <p>Run TTempsmooth on the denoised clip if True</p> <code>True</code> <p>Returns:</p> Type Description <code>VideoNode</code> <p>Denoised clip</p> Source code in <code>         vodesfunc/denoise.py       </code> <pre><code>def VMDegrain(\n    src: vs.VideoNode,\n    thSAD: int = 60,\n    prefilter: vs.VideoNode | int = 2,\n    smooth: bool = True,\n    block_size: int | None = None,\n    overlap: int | None = None,\n    refine: int = 2,\n    tr: int = 2,\n    preset: MVToolsPreset | None = MVPresets.Default,\n    **kwargs: KwargsT,\n) -&gt; vs.VideoNode:\n    \"\"\"\n    Just some convenience function for mvtools with a useable preset and temporal smoothing.\\n\n    Check the MVTools Docs for the params that aren't listed below.\\n\n    `block_size`, `overlap` and `refine` are using somewhat optimized defaults depending on the resolution if `None`.\n\n\n    :param src:             Input to denoise\n    :param smooth:          Run TTempsmooth on the denoised clip if True\n    :return:                Denoised clip\n    \"\"\"\n    if isinstance(prefilter, int):\n        prefilter = Prefilter(prefilter)\n\n    futil = FunctionUtil(src, VMDegrain, 0, vs.YUV, 16)\n\n    if any([block_size, overlap]) and not all([block_size, overlap]):\n        raise ValueError(\"VMDegrain: If you want to play around with blocksize, overlap or refine, you have to set all of them.\")\n\n    if not block_size or not overlap:\n        _, width, height = get_var_infos(src)\n        if width &lt;= 1024 and height &lt;= 576:\n            block_size = 32\n            overlap = 16\n        elif width &lt;= 2048 and height &lt;= 1536:\n            block_size = 64\n            overlap = 32\n        else:\n            block_size = 128\n            overlap = 64\n\n    from vsdenoise import mc_degrain\n\n    if preset is None:\n        raise ValueError(\"VMDegrain: preset cannot be None when on vsjetpack&gt;=0.3.0!\")\n\n    # Dirty clean up for random args getting removed from on git.\n    # (You should not be using git jetpack with vodesfunc but it is what it is)\n    mc_degrain_sig = signature(mc_degrain)\n    args = KwargsT(\n        prefilter=prefilter,\n        thsad=thSAD,\n        thsad_recalc=thSAD,\n        blksize=block_size,\n        refine=refine,\n        preset=preset,\n        tr=tr,\n    )\n    clean_args = {k: v for k, v in args.items() if k in mc_degrain_sig.parameters}\n\n    if len(args) != len(clean_args):\n        args_string = \", \".join(list(k for k, _ in args.items() if k not in clean_args))\n        print(f\"VMDegrain: A couple of arguments are not passed to mc_degrain anymore! ({args_string})\\nPlease do report this to the maintainer.\")\n\n    out = mc_degrain(futil.work_clip, **clean_args)\n\n    if smooth:\n        out = out.ttmpsm.TTempSmooth(maxr=1, thresh=1, mdiff=0, strength=1)\n\n    return futil.return_clip(out)\n</code></pre>"},{"location":"vodesfunc/denoise/#vodesfunc.denoise.schizo_denoise","title":"<code>schizo_denoise(src, sigma=[0.8, 0.3], thSAD=60, radius=2, nlm_a=2, prefilter=2, cuda=True, csharp=False, **kwargs)</code>","text":"<p>Convenience function for (k)nlm on chroma and mvtools + bm3d(cuda) on luma. Mostly for personal scripts so please don't complain too much unless it's an actual issue.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>VideoNode</code> <p>Input to denoise</p> required <code>sigma</code> <code>float | list[float]</code> <p>Essentially strength for NLMeans and BM3D. Float or list of floats in this order [bm3d, nlm_uv] or [bm3d, nlm_u, nlm_v]</p> <code>[0.8, 0.3]</code> <code>thSAD</code> <code>int</code> <p>Not exactly strength but something like that, for mvtools.</p> <code>60</code> <code>radius</code> <code>int | list[int]</code> <p>Temporal Radius used for NLMeans and BM3D. Int or list of ints in this order [bm3d, nlm]</p> <code>2</code> <code>prefilter</code> <code>VideoNode | int</code> <p>vsdenoise Prefilter or prefiltered clip to use for mvtools. Defaults to MINBLUR3</p> <code>2</code> <code>cuda</code> <code>bool | list[bool]</code> <p>Uses NlmCuda and BM3DCuda respectively if available. The latter prefers RTC if available. Will fallback to BM3DHip if installed and no cuda available.</p> <code>True</code> <code>csharp</code> <code>int | bool</code> <p>Apply contrasharpening after denoising. True defaults to 3 while False obviously disables it.</p> <code>False</code> <code>kwargs</code> <p>Any parameters you might wanna pass to bm3d or mvtools.  Note that this also takes <code>tr</code> or <code>preset</code> for mvtools which might be very useful.</p> <code>{}</code> <p>Returns:</p> Type Description <code>VideoNode</code> <p>Denoised clip</p> Source code in <code>         vodesfunc/denoise.py       </code> <pre><code>def schizo_denoise(\n    src: vs.VideoNode,\n    sigma: float | list[float] = [0.8, 0.3],\n    thSAD: int = 60,\n    radius: int | list[int] = 2,\n    nlm_a: int = 2,\n    prefilter: vs.VideoNode | int = 2,\n    cuda: bool | list[bool] = True,\n    csharp: int | bool = False,\n    **kwargs,\n) -&gt; vs.VideoNode:\n    \"\"\"\n    Convenience function for (k)nlm on chroma and mvtools + bm3d(cuda) on luma.\n    Mostly for personal scripts so please don't complain too much unless it's an actual issue.\n\n    :param src:         Input to denoise\n    :param sigma:       Essentially strength for NLMeans and BM3D.\n                        Float or list of floats in this order [bm3d, nlm_uv] or [bm3d, nlm_u, nlm_v]\n    :param thSAD:       Not exactly strength but something like that, for mvtools.\n    :param radius:      Temporal Radius used for NLMeans and BM3D.\n                        Int or list of ints in this order [bm3d, nlm]\n    :param prefilter:   vsdenoise Prefilter or prefiltered clip to use for mvtools.\n                        Defaults to MINBLUR3\n    :param cuda:        Uses NlmCuda and BM3DCuda respectively if available. The latter prefers RTC if available.\n                        Will fallback to BM3DHip if installed and no cuda available.\n    :param csharp:      Apply contrasharpening after denoising. True defaults to 3 while False obviously disables it.\n    :param kwargs:      Any parameters you might wanna pass to bm3d or mvtools.\\n\n                        Note that this also takes `tr` or `preset` for mvtools which might be very useful.\n\n    :return:            Denoised clip\n    \"\"\"\n    if get_video_format(src).color_family != vs.YUV:\n        raise ValueError(\"schizo_denoise: This function expects a full YUV clip.\")\n\n    if not isinstance(radius, list):\n        radius = [radius, radius]\n\n    if not isinstance(sigma, list):\n        sigma = [sigma, sigma]\n\n    if not isinstance(cuda, list):\n        cuda = [cuda, cuda]\n\n    if isinstance(prefilter, int):\n        from vsdenoise import Prefilter\n\n        prefilter = Prefilter(prefilter)\n\n    clip = depth(src, 16)\n\n    nlmfunc = core.knlm.KNLMeansCL if not hasattr(core, \"nlm_cuda\") or not cuda[0] else core.nlm_cuda.NLMeans\n\n    if len(sigma) == 3:\n        clip_u = nlmfunc(clip, a=nlm_a, d=radius[1], h=sigma[1], channels=\"UV\")\n        clip_v = nlmfunc(clip, a=nlm_a, d=radius[1], h=sigma[2], channels=\"UV\")\n        nlm = join(get_y(clip), get_u(clip_u), get_v(clip_v))  # type: ignore\n    else:\n        clip_uv = nlmfunc(clip, a=nlm_a, d=radius[1], h=sigma[1], channels=\"UV\")\n        nlm = join(clip, clip_uv)  # type: ignore\n\n    # 'Extract' possible bm3d args before passing kwargs to mvtools :)\n    bm3dargs = dict(\n        block_step=kwargs.pop(\"block_step\", 8),\n        bm_range=kwargs.pop(\"bm_range\", 9),\n        ps_num=kwargs.pop(\"ps_num\", 2),\n        ps_range=kwargs.pop(\"ps_range\", 4),\n        fast=kwargs.pop(\"fast\", True),\n    )\n\n    y = get_y(clip)\n    mv = VMDegrain(y, thSAD, prefilter, **kwargs)\n\n    has_cuda = hasattr(core, \"bm3dcuda\") or hasattr(core, \"bm3dcuda_rtc\")\n    has_hip = hasattr(core, \"bm3dhip\")\n\n    if cuda[1] and (has_cuda or has_hip):\n        if has_cuda:\n            bm3dfunc = core.bm3dcuda if not hasattr(core, \"bm3dcuda_rtc\") else core.bm3dcuda_rtc\n        else:\n            bm3dfunc = core.bm3dhip\n    else:\n        bm3dargs.pop(\"fast\")\n        bm3dfunc = core.bm3dcpu\n\n    bm3d = bm3dfunc.BM3Dv2(depth(y, 32), depth(mv, 32), sigma[0], radius=radius[0], **bm3dargs)\n\n    out = join(depth(bm3d, 16), nlm)  # type: ignore\n    out = depth(out, get_depth(src))\n    if csharp != False:  # noqa: E712\n        out = contrasharpening(out, src, mode=3 if csharp == True else csharp)  # noqa: E712\n    return out.std.CopyFrameProps(src)\n</code></pre>"},{"location":"vodesfunc/misc/","title":"misc","text":""},{"location":"vodesfunc/misc/#vodesfunc.misc.dirty_prop_set","title":"<code>dirty_prop_set(clip, threshold=1100, luma_scaling=24, prop_name=None, src_prop_val=None, bbm_prop_val=None, debug_output=False)</code>","text":"<p>Dirty-edge-based frameprop setting function using bbm, a brightness difference check and a brightness scaling (might be a very specific usecase)</p> <p>Returns both filtered clip and mask in a VideoNode List (0 = clip, 1 = mask)</p> <p>An example for this would be my tanya script:     Only 720p frames have dirty edges so write a 720 prop if dirty edges are detected.</p> <pre><code>dirty_prop_set(.., prop_name = 'Rescale', src_prop_val = 812, bbm_prop_val = 720)\n</code></pre> Source code in <code>         vodesfunc/misc.py       </code> <pre><code>def dirty_prop_set(\n    clip: vs.VideoNode,\n    threshold: int = 1100,\n    luma_scaling: int = 24,\n    prop_name: str | None = None,\n    src_prop_val: Any | None = None,\n    bbm_prop_val: Any | None = None,\n    debug_output: bool = False,\n) -&gt; list[vs.VideoNode]:\n    \"\"\"\n    Dirty-edge-based frameprop setting function using bbm, a brightness difference check and a brightness scaling\n    (might be a very specific usecase)\n\n    Returns both filtered clip and mask in a VideoNode List (0 = clip, 1 = mask)\n\n    An example for this would be my tanya script:\n        Only 720p frames have dirty edges so write a 720 prop if dirty edges are detected.\n\n        dirty_prop_set(.., prop_name = 'Rescale', src_prop_val = 812, bbm_prop_val = 720)\n    \"\"\"\n\n    def _select_frame(n: int, f: vs.VideoFrame, clip_a: vs.VideoNode, clip_b: vs.VideoNode) -&gt; vs.VideoNode:\n        plane_stats_average = f.props[\"PlaneStatsAverage\"]\n        # print(f\"Frame {n}: {plane_stats_average:.20f}\")\n        return clip_b if plane_stats_average &gt; 0.00010 else clip_a  # type: ignore\n\n    def _get_mask(n: int, f: vs.VideoFrame, clip_a: vs.VideoNode, clip_b: vs.VideoNode) -&gt; vs.VideoNode:\n        brightness = f.props[\"PlaneStatsAverage\"]\n        weighted_thr = threshold * (1 - (1 - brightness) ** (brightness**2 * luma_scaling))  # type: ignore\n        if debug_output:\n            print(f\"Frame {n}: Average Brightness - {brightness:.20f}, Weighted - {weighted_thr:.20f}\")\n        return core.std.Expr([clip_a, clip_b], [f\"y x - {weighted_thr} &gt; 65536 0 ?\", \"\"])\n\n    try:\n        import awsmfunc as awf\n    except:\n        raise ModuleNotFoundError(\"awsmfunc not found!\")\n\n    clip = depth(clip, 16).std.PlaneStats()  # Wouldn't this be set way earlier?\n    bbm = awf.bbmod(clip, 1, 1, 1, 1, thresh=50, blur=666)\n    mask = get_y(core.std.FrameEval(clip, partial(_get_mask, clip_a=clip, clip_b=bbm), clip)).std.PlaneStats()\n\n    if isinstance(src_prop_val, int) and isinstance(bbm_prop_val, int):\n        bbm_prop, src_prop = [c.std.SetFrameProp(prop=prop_name, intval=i) for c, i in zip([bbm, clip], [bbm_prop_val, src_prop_val])]\n    else:\n        bbm_prop, src_prop = [c.std.SetFrameProp(prop=prop_name, data=i) for c, i in zip([bbm, clip], [str(bbm_prop_val), str(src_prop_val)])]\n\n    return [core.std.FrameEval(clip, partial(_select_frame, clip_a=src_prop, clip_b=bbm_prop), prop_src=mask), mask]\n</code></pre>"},{"location":"vodesfunc/misc/#vodesfunc.misc.get_border_crop","title":"<code>get_border_crop(input_clip, base, override_window=None)</code>","text":"<p>Get the crops for the border handling masking.</p> Source code in <code>         vodesfunc/misc.py       </code> <pre><code>def get_border_crop(input_clip: vs.VideoNode, base: RescaleBase, override_window: int | None = None) -&gt; tuple[int]:\n    \"\"\"Get the crops for the border handling masking.\"\"\"\n\n    kernel_window = override_window or base.kernel.kernel_radius\n\n    if base.height == input_clip.height:\n        vertical_crop = (0, 0)\n    else:\n        base_height = base.base_height or get_h(base.base_width, base.descaled) if base.base_width else base.height\n        src_top = base.descale_func_args.get(\"src_top\", 0)\n\n        top = max(ceil(\n            (-(base.height - 1) / 2 + kernel_window - src_top - 1)\n            * input_clip.height / base.height + (input_clip.height - 1) / 2\n        ), 0)\n\n        bottom = max(ceil(\n            (-(base.height - 1) / 2 + kernel_window - (base_height - base.height - src_top) - 1)\n            * input_clip.height / base.height + (input_clip.height - 1) / 2\n        ), 0)\n\n        vertical_crop = (top, bottom)\n\n    if base.width == input_clip.width:\n        horizontal_crop = (0, 0)\n    else:\n        base_width = base.base_width or get_w(base.base_height, base.descaled) if base.base_height else base.width\n        src_left = base.descale_func_args.get(\"src_left\", 0)\n\n        left = max(ceil(\n            (-(base.width - 1) / 2 + kernel_window - src_left - 1)\n            * input_clip.width / base.width + (input_clip.width - 1) / 2\n        ), 0)\n\n        right = max(ceil(\n            (-(base.width - 1) / 2 + kernel_window - (base_width - base.width - src_left) - 1)\n            * input_clip.width / base.width + (input_clip.width - 1) / 2\n        ), 0)\n\n        horizontal_crop = (left, right)\n\n    return horizontal_crop + vertical_crop\n</code></pre>"},{"location":"vodesfunc/mixed_rescale/","title":"mixed_rescale","text":""},{"location":"vodesfunc/mixed_rescale/#vodesfunc.rescale_ext.mixed_rescale.DiffMode","title":"<code>DiffMode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Mode used to calculate the difference between rescale and input clip.</p> Source code in <code>           vodesfunc/rescale_ext/mixed_rescale.py         </code> <pre><code>class DiffMode(IntEnum):\n    \"\"\"Mode used to calculate the difference between rescale and input clip.\"\"\"\n\n    MAE = 1\n    \"\"\"Mean Absolute Error\"\"\"\n\n    MSE = 2\n    \"\"\"Mean Squared Error\"\"\"\n\n    GET_NATIVE = 3\n    \"\"\"Weird headcraft from getnative\"\"\"\n</code></pre>"},{"location":"vodesfunc/mixed_rescale/#vodesfunc.rescale_ext.mixed_rescale.DiffMode.GET_NATIVE","title":"<code>GET_NATIVE = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Weird headcraft from getnative</p>"},{"location":"vodesfunc/mixed_rescale/#vodesfunc.rescale_ext.mixed_rescale.DiffMode.MAE","title":"<code>MAE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mean Absolute Error</p>"},{"location":"vodesfunc/mixed_rescale/#vodesfunc.rescale_ext.mixed_rescale.DiffMode.MSE","title":"<code>MSE = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mean Squared Error</p>"},{"location":"vodesfunc/mixed_rescale/#vodesfunc.rescale_ext.mixed_rescale.MixedRB","title":"<code>MixedRB</code>","text":"<p>               Bases: <code>vs_object</code></p> <p>Implementation of MixedRescale for RescaleBuilder(s)</p> <p>This is just a stop-gap solution until we (mostly Setsu) can cook up something better.</p> <p>Example Usage:</p> <pre><code>upscaler = Waifu2x(\"trt\", 1, fp16=True)\n\nbuilders = [\n    RescaleBuilder(src).descale(Bilinear(border_handling=1), 1280, 720),\n    RescaleBuilder(src).descale(BicubicSharp, 1280, 720),\n]\n\n# This will be run on all of the above\nbuilders = [\n    b.double(upscaler)\n    .linemask(KirschTCanny, Bilinear, lthr=50 / 255, hthr=150 / 255, inflate_iter=2)\n    .errormask(expand=2)\n    .downscale(Hermite(linear=True))\n    for b in builders\n]\n\nmixed = MixedRB(*builders)\nrescaled = mixed.get_upscaled()\n</code></pre> Source code in <code>           vodesfunc/rescale_ext/mixed_rescale.py         </code> <pre><code>class MixedRB(vs_object):\n    \"\"\"\n    Implementation of MixedRescale for RescaleBuilder(s)\n\n    This is just a stop-gap solution until we (mostly Setsu) can cook up something better.\n\n    Example Usage:\n\n    ```py\n    upscaler = Waifu2x(\"trt\", 1, fp16=True)\n\n    builders = [\n        RescaleBuilder(src).descale(Bilinear(border_handling=1), 1280, 720),\n        RescaleBuilder(src).descale(BicubicSharp, 1280, 720),\n    ]\n\n    # This will be run on all of the above\n    builders = [\n        b.double(upscaler)\n        .linemask(KirschTCanny, Bilinear, lthr=50 / 255, hthr=150 / 255, inflate_iter=2)\n        .errormask(expand=2)\n        .downscale(Hermite(linear=True))\n        for b in builders\n    ]\n\n    mixed = MixedRB(*builders)\n    rescaled = mixed.get_upscaled()\n    ```\n    \"\"\"\n\n    def __init__(self, *targets: RescBuildMixed, diffmode: DiffMode = DiffMode.GET_NATIVE, crop_diff: bool = True) -&gt; None:\n        \"\"\"\n        A naive per-frame diff approach of trying to get the best descale.\n        Credits to Setsu for most of this class.\n        \"\"\"\n        y = targets[0].funcutil.work_clip\n\n        for i, d in enumerate(targets):\n            d.index = i + 1\n            d.diffmode = diffmode\n            d.crop_diff = crop_diff\n            d._add_index_to_clips()\n\n        prop_srcs = [d.get_diff() for d in targets]\n        targets_idx = tuple(range(len(targets)))\n\n        blank = core.std.BlankClip(None, 1, 1, vs.GRAY8, y.num_frames, keep=True)\n\n        map_prop_srcs = [blank.std.CopyFrameProps(prop_src).akarin.Expr(\"x.PlaneStatsAverage\", vs.GRAYS) for prop_src in prop_srcs]\n\n        base_frame, idx_frames = blank.get_frame(0), []\n\n        for i in targets_idx:\n            fcurr = base_frame.copy()\n\n            fcurr[0][0, 0] = i\n\n            idx_frames.append((i, fcurr))\n\n        def _select(n: int, f: vs.VideoFrame) -&gt; vs.VideoFrame:\n            return min(idx_frames, key=lambda i: f[i[0]][0][0, 0])[1]\n\n        _select_clip = blank.std.ModifyFrame(map_prop_srcs, _select)\n\n        def _selector(clips: list[vs.VideoNode | None]) -&gt; vs.VideoNode:\n            base = next(filter(None, clips), None)\n\n            if base is None:\n                raise ValueError(\"Requested clip was None\")\n\n            base = base.std.BlankClip(keep=True)\n            clips = [c or base for c in clips]\n\n            return core.std.FrameEval(base, lambda n, f: clips[f[0][0, 0]], _select_clip)\n\n        self.upscaled = _selector([t.final()[1] for t in targets])\n        self.final = self.upscaled\n\n        self.rescaled = _selector([t.rescaled for t in targets])\n        self.credit_mask = _selector([t._return_creditmask() for t in targets])\n        self.line_mask = _selector([t._return_linemask() for t in targets])\n\n    def get_upscaled(self, *_) -&gt; vs.VideoNode:\n        return self.upscaled\n\n    def __vs_del__(self, core_id: int) -&gt; None:\n        if not TYPE_CHECKING:\n            setattr(self, \"upscaled\", None)\n            setattr(self, \"final\", None)\n            setattr(self, \"rescaled\", None)\n            setattr(self, \"credit_mask\", None)\n            setattr(self, \"line_mask\", None)\n            for v in self.__dict__.values():\n                if not isinstance(v, MutableMapping):\n                    continue\n\n                for k2, v2 in v.items():\n                    if isinstance(v2, vs.VideoNode):\n                        v[k2] = None\n</code></pre>"},{"location":"vodesfunc/mixed_rescale/#vodesfunc.rescale_ext.mixed_rescale.MixedRB.__init__","title":"<code>__init__(*targets, diffmode=DiffMode.GET_NATIVE, crop_diff=True)</code>","text":"<p>A naive per-frame diff approach of trying to get the best descale. Credits to Setsu for most of this class.</p> Source code in <code>         vodesfunc/rescale_ext/mixed_rescale.py       </code> <pre><code>def __init__(self, *targets: RescBuildMixed, diffmode: DiffMode = DiffMode.GET_NATIVE, crop_diff: bool = True) -&gt; None:\n    \"\"\"\n    A naive per-frame diff approach of trying to get the best descale.\n    Credits to Setsu for most of this class.\n    \"\"\"\n    y = targets[0].funcutil.work_clip\n\n    for i, d in enumerate(targets):\n        d.index = i + 1\n        d.diffmode = diffmode\n        d.crop_diff = crop_diff\n        d._add_index_to_clips()\n\n    prop_srcs = [d.get_diff() for d in targets]\n    targets_idx = tuple(range(len(targets)))\n\n    blank = core.std.BlankClip(None, 1, 1, vs.GRAY8, y.num_frames, keep=True)\n\n    map_prop_srcs = [blank.std.CopyFrameProps(prop_src).akarin.Expr(\"x.PlaneStatsAverage\", vs.GRAYS) for prop_src in prop_srcs]\n\n    base_frame, idx_frames = blank.get_frame(0), []\n\n    for i in targets_idx:\n        fcurr = base_frame.copy()\n\n        fcurr[0][0, 0] = i\n\n        idx_frames.append((i, fcurr))\n\n    def _select(n: int, f: vs.VideoFrame) -&gt; vs.VideoFrame:\n        return min(idx_frames, key=lambda i: f[i[0]][0][0, 0])[1]\n\n    _select_clip = blank.std.ModifyFrame(map_prop_srcs, _select)\n\n    def _selector(clips: list[vs.VideoNode | None]) -&gt; vs.VideoNode:\n        base = next(filter(None, clips), None)\n\n        if base is None:\n            raise ValueError(\"Requested clip was None\")\n\n        base = base.std.BlankClip(keep=True)\n        clips = [c or base for c in clips]\n\n        return core.std.FrameEval(base, lambda n, f: clips[f[0][0, 0]], _select_clip)\n\n    self.upscaled = _selector([t.final()[1] for t in targets])\n    self.final = self.upscaled\n\n    self.rescaled = _selector([t.rescaled for t in targets])\n    self.credit_mask = _selector([t._return_creditmask() for t in targets])\n    self.line_mask = _selector([t._return_linemask() for t in targets])\n</code></pre>"},{"location":"vodesfunc/rescale/","title":"rescale","text":""},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder","title":"<code>RescaleBuilder</code>","text":"<p>               Bases: <code>RescBuildFB</code>, <code>RescBuildNonFB</code>, <code>RescBuildMixed</code></p> <p>The fancy new rescale wrapper to make life easier. Now 99% less buggy and should handle everything.</p> <p>Example usage: <pre><code>builder, rescaled = (\n    RescaleBuilder(clip)\n    .descale(Bilinear, 1500, 843.75, base_height=846)\n    .double()\n    .errormask(0.0975)\n    .linemask()\n    .post_double(lambda x: aa_dehalo(x)) # Or a function like post_double(aa_dehalo)\n    .downscale(Hermite(linear=True))\n    .final()\n)\n</code></pre></p> Source code in <code>           vodesfunc/rescale.py         </code> <pre><code>class RescaleBuilder(RescBuildFB, RescBuildNonFB, RescBuildMixed):\n    \"\"\"\n    The fancy new rescale wrapper to make life easier.\n    Now 99% less buggy and should handle everything.\n\n    Example usage:\n    ```py\n    builder, rescaled = (\n        RescaleBuilder(clip)\n        .descale(Bilinear, 1500, 843.75, base_height=846)\n        .double()\n        .errormask(0.0975)\n        .linemask()\n        .post_double(lambda x: aa_dehalo(x)) # Or a function like post_double(aa_dehalo)\n        .downscale(Hermite(linear=True))\n        .final()\n    )\n    ```\n    \"\"\"\n\n    def __init__(self, clip: vs.VideoNode):\n        self.funcutil = FunctionUtil(clip, self.__class__.__name__, planes=0, color_family=(vs.YUV, vs.GRAY), bitdepth=32)\n\n    def descale(\n        self,\n        kernel: KernelLike,\n        width: int | float,\n        height: int | float,\n        base_height: int | None = None,\n        base_width: int | None = None,\n        shift: tuple[float, float] = (0, 0),\n        field_based: FieldBasedT | None = None,\n        mode: str = \"hw\",\n    ) -&gt; Self:\n        \"\"\"\n        Performs descale and rescale (with the same kernel).\n\n        :param kernel:              Kernel to descale with\n        :param height:              Height to descale to\n        :param width:               Width to descale to. Please be absolutely certain of what you're doing if you're using get_w for this.\n        :param base_height:         Padded height used in a \"fractional\" descale\n        :param base_width:          Padded width used in a \"fractional\" descale\n                                    Both of these are technically optional but highly recommended to have set for float width/height.\n\n        :param shift:               A custom shift to be applied\n        :param mode:                Whether to descale only height, only width, or both.\n                                    \"h\" or \"w\" respectively for the former two.\n        :param field_based:         To descale a cross-converted/interlaced clip.\n                                    Will try to take the prop from the clip if `None` was passed.\n        \"\"\"\n        clip = self.funcutil.work_clip\n\n        if isinstance(height, float) and len(stack := inspect.stack()) &gt; 1:\n            has_getw = [ctx for ctx in stack[1].code_context if \"get_w\" in ctx.lower()]\n            if has_getw:\n                print(\"RescaleBuilder: Please make sure get_w returns the width you really want!\")\n\n        self.kernel = Kernel.ensure_obj(kernel)\n        self.border_handling = self.kernel.kwargs.pop(\"border_handling\", 0)\n        self.field_based = FieldBased.from_param(field_based) or FieldBased.from_video(clip)\n\n        self.height = height if \"h\" in mode else clip.height\n        self.width = width if \"w\" in mode else clip.width\n        self.base_height = base_height\n        self.base_width = base_width\n\n        if (isinstance(width, float) or isinstance(height, float)) and self.field_based.is_inter:\n            raise CustomValueError(\"Float is not supported for fieldbased descales!\", self.descale)\n\n        if self.field_based.is_inter:\n            self._fieldbased_descale(clip, width=self.width, height=self.height, shift=shift, border_handling=self.border_handling)\n        else:\n            self._non_fieldbased_descale(clip, width, height, base_height, base_width, shift, mode)\n\n        self.descaled = self.descaled.std.CopyFrameProps(clip)\n        self.rescaled = self.rescaled.std.CopyFrameProps(clip)\n\n        return self\n\n    def post_descale(self, func: GenericVSFunction | list[GenericVSFunction]) -&gt; Self:\n        \"\"\"\n        A function to apply any arbitrary function on the descaled clip.\\n\n        I can't think of a good usecase/example for this but I was asked to add this before.\n\n        :param func:    This can be any function or list of functions that take a videonode input\n                        and returns a videonode. You are responsible for keeping the format the same.\n        \"\"\"\n        if not isinstance(func, list):\n            func = [func]\n\n        for f in func:\n            if not callable(f):\n                raise CustomValueError(f\"post_descale: Function {f.__name__} is not callable!\", self.post_descale)\n\n            self.descaled = f(self.descaled)\n\n        return self\n\n    def linemask(\n        self,\n        mask: vs.VideoNode | EdgeDetectT | None = None,\n        downscaler: ScalerLike | None = None,\n        maximum_iter: int = 0,\n        inflate_iter: int = 0,\n        expand: int | tuple[int, int | None] = 0,\n        kernel_window: int | None = None,\n        **kwargs,\n    ) -&gt; Self:\n        \"\"\"\n        A function to apply a linemask to the final output.\n\n        :param mask:            This can be a masking function like `KirschTCanny` (also the default if `None`) or a clip.\n        :param downscaler:      Downscaler to use if creating a linemask on the doubled clip. Defaults to `Bilinear` if `None`.\n        :param maximum_iter:    Apply std.Maximum x amount of times\n        :param inflate_iter:    Apply std.inflate x amount of times\n        :param expand:          Apply an ellipse morpho expand with the passed amount.\n                                Can be a tuple of (horizontal, vertical) or a single value for both.\n        :param kernel_window:   To override kernel radius used in case of border_handling being used.\n        :param **kwargs:        Any other params to pass to the edgemask creation. For example `lthr` or `hthr`.\n        \"\"\"\n        if self.upscaled:\n            raise SyntaxError(\"RescaleBuilder: Downscaled clip already created. Create linemasks before calling downscale.\")\n        if isinstance(mask, vs.VideoNode):\n            self.linemask_clip = mask\n            return self\n        edgemaskFunc = KirschTCanny.ensure_obj(mask)\n\n        # Perform on doubled clip if exists and downscale\n        if self.doubled:\n            scaler = Bilinear.ensure_obj(downscaler)\n            self.linemask_clip = edgemaskFunc.edgemask(self.doubled, **kwargs)\n            self.linemask_clip = scaler.scale(self.linemask_clip, self.funcutil.work_clip.width, self.funcutil.work_clip.height, **self.post_crop)\n        else:\n            self.linemask_clip = edgemaskFunc.edgemask(self.funcutil.work_clip, **kwargs)\n\n        self.linemask_clip = self._process_mask(self.linemask_clip, maximum_iter, inflate_iter, expand)\n\n        if self.border_handling:\n            from .misc import get_border_crop\n\n            borders = get_border_crop(self.funcutil.work_clip, self, kernel_window)\n            self.linemask_clip = self.linemask_clip.std.Crop(*borders).std.AddBorders(*borders, [get_peak_value(self.linemask_clip)])\n\n        self.linemask_clip = self.linemask_clip.std.Limiter()\n\n        return self\n\n    def _errormask(\n        self, mask: vs.VideoNode | float = 0.05, maximum_iter: int = 2, inflate_iter: int = 3, expand: int | tuple[int, int | None] = 0\n    ) -&gt; vs.VideoNode:\n        if self.upscaled:\n            raise SyntaxError(\"RescaleBuilder: Downscaled clip already created. Create errormasks before calling downscale.\")\n        if isinstance(mask, vs.VideoNode):\n            return mask\n\n        err_mask = core.std.Expr([self.funcutil.work_clip, self.rescaled], f\"x y - abs {mask} &lt; 0 1 ?\")\n        err_mask = removegrain(err_mask, 6)\n        err_mask = self._process_mask(err_mask, maximum_iter, inflate_iter, expand)\n\n        return err_mask\n\n    def errormask(\n        self, mask: vs.VideoNode | float = 0.05, maximum_iter: int = 2, inflate_iter: int = 3, expand: int | tuple[int, int | None] = 0\n    ) -&gt; Self:\n        \"\"\"\n        A function to apply a basic error mask to the final output.\n\n        :param mask:            With a float, and by default, will be created internally. Could also pass a clip.\n        :param maximum_iter:    Apply std.Maximum x amount of times\n        :param inflate_iter:    Apply std.inflate x amount of times\n        :param expand:          Apply an ellipse morpho expand with the passed amount.\n                                Can be a tuple of (horizontal, vertical) or a single value for both.\n        \"\"\"\n        self.errormask_clip = self._errormask(mask, maximum_iter, inflate_iter, expand).std.Limiter()\n        return self\n\n    def errormask_zoned(\n        self,\n        ranges: FrameRangesN,\n        mask: vs.VideoNode | float = 0.05,\n        maximum_iter: int = 2,\n        inflate_iter: int = 3,\n        expand: int | tuple[int, int | None] = 0,\n    ) -&gt; Self:\n        \"\"\"\n        A function to apply a basic error mask to the final output.\\n\n        But with this rfs'd to certain ranges.\n        \"\"\"\n        if not ranges:\n            return self\n        err_mask = self._errormask(mask, maximum_iter, inflate_iter, expand)\n        if not self.errormask_clip:\n            self.errormask_clip = core.std.BlankClip(self.funcutil.work_clip, format=get_video_format(err_mask))\n\n        self.errormask_clip = replace_ranges(self.errormask_clip, err_mask, ranges)\n        return self\n\n    def double(self, upscaler: ScalerLike = ArtCNN.R8F64) -&gt; Self:\n        \"\"\"\n        Upscales the descaled clip by 2x\n\n        :param upscaler:        Any kind of vsscale scaler. Defaults to ArtCNN.R8F64.\n        \"\"\"\n\n        scaler = Scaler.ensure_obj(upscaler)\n        self.doubled = scaler.supersample(self.descaled)\n        return self\n\n    def post_double(self, func: GenericVSFunction | list[GenericVSFunction]) -&gt; Self:\n        \"\"\"\n        A function to apply any arbitrary function on the doubled clip.\n\n        :param func:    This can be any function or list of functions that take a videonode input\n                        and returns a videonode. You are responsible for keeping the format the same.\n        \"\"\"\n        if not self.doubled:\n            raise SyntaxError(\"post_double: Doubled clip has not been generated yet. Please call this after double().\")\n\n        if not isinstance(func, list):\n            func = [func]\n\n        for f in func:\n            if not callable(f):\n                raise CustomValueError(f\"post_double: Function {f.__name__} is not callable!\", self.post_double)\n\n            self.doubled = f(self.doubled)\n\n        return self\n\n    def downscale(self, downscaler: ScalerLike | None = None) -&gt; Self:\n        \"\"\"\n        Downscales the clip back the size of the original input clip and applies the masks, if any.\n\n        :param downscaler:      Any vsscale scaler to use. Defaults to Linear Hermite.\n        \"\"\"\n        if downscaler is None:\n            scaler = Hermite(linear=True)\n        else:\n            scaler = Scaler.ensure_obj(downscaler)\n        if not self.doubled:\n            raise SyntaxError(\"Downscale/Final is the last one that should be called in a chain!\")\n        wclip = self.funcutil.work_clip\n        self.upscaled = scaler.scale(self.doubled, wclip.width, wclip.height, **self.post_crop)\n        self._apply_masks()\n        self.upscaled = self.upscaled.std.CopyFrameProps(wclip)\n        return self\n\n    def _apply_masks(self):\n        wclip = self.funcutil.work_clip\n        if isinstance(self.errormask_clip, vs.VideoNode) and isinstance(self.linemask_clip, vs.VideoNode):\n            self.final_mask = core.std.Expr([self.linemask_clip, self.errormask_clip], \"x y - 0 max 1 min\")\n            self.upscaled = wclip.std.MaskedMerge(self.upscaled, self.final_mask)\n        elif isinstance(self.errormask_clip, vs.VideoNode):\n            self.upscaled = self.upscaled.std.MaskedMerge(wclip, self.errormask_clip)\n        elif isinstance(self.linemask_clip, vs.VideoNode):\n            self.upscaled = wclip.std.MaskedMerge(self.upscaled, self.linemask_clip)\n\n    def final(self) -&gt; tuple[Self, vs.VideoNode]:\n        \"\"\"\n        This is the last function in the chain that also returns the final clip.\n        It internally calls `downscale` if you haven't done so before and then merges the resulting clip with the input chroma, if any.\n\n        :return: A tuple of this class and the resulting final rescale.\n        \"\"\"\n        if not self.upscaled:\n            self.downscale()\n        if not self.upscaled:\n            raise TypeError(\"No downscaled clip has been generated yet!\")\n\n        return (self, self.funcutil.return_clip(self.upscaled))\n\n    def _process_mask(\n        self, mask: vs.VideoNode, maximum_iter: int = 0, inflate_iter: int = 0, expand: int | tuple[int, int | None] = 0\n    ) -&gt; vs.VideoNode:\n        if maximum_iter:\n            mask = iterate(mask, core.std.Maximum, maximum_iter)\n\n        if inflate_iter:\n            mask = iterate(mask, core.std.Inflate, inflate_iter)\n\n        if expand:\n            if isinstance(expand, int):\n                expand = (expand, expand)\n            from vsmasktools import Morpho, XxpandMode\n\n            mask = Morpho.expand(mask, expand[0], expand[1], XxpandMode.ELLIPSE)\n\n        return mask\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.descale","title":"<code>descale(kernel, width, height, base_height=None, base_width=None, shift=(0, 0), field_based=None, mode='hw')</code>","text":"<p>Performs descale and rescale (with the same kernel).</p> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>KernelLike</code> <p>Kernel to descale with</p> required <code>height</code> <code>int | float</code> <p>Height to descale to</p> required <code>width</code> <code>int | float</code> <p>Width to descale to. Please be absolutely certain of what you're doing if you're using get_w for this.</p> required <code>base_height</code> <code>int | None</code> <p>Padded height used in a \"fractional\" descale</p> <code>None</code> <code>base_width</code> <code>int | None</code> <p>Padded width used in a \"fractional\" descale Both of these are technically optional but highly recommended to have set for float width/height.</p> <code>None</code> <code>shift</code> <code>tuple[float, float]</code> <p>A custom shift to be applied</p> <code>(0, 0)</code> <code>mode</code> <code>str</code> <p>Whether to descale only height, only width, or both. \"h\" or \"w\" respectively for the former two.</p> <code>'hw'</code> <code>field_based</code> <code>FieldBasedT | None</code> <p>To descale a cross-converted/interlaced clip. Will try to take the prop from the clip if <code>None</code> was passed.</p> <code>None</code> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def descale(\n    self,\n    kernel: KernelLike,\n    width: int | float,\n    height: int | float,\n    base_height: int | None = None,\n    base_width: int | None = None,\n    shift: tuple[float, float] = (0, 0),\n    field_based: FieldBasedT | None = None,\n    mode: str = \"hw\",\n) -&gt; Self:\n    \"\"\"\n    Performs descale and rescale (with the same kernel).\n\n    :param kernel:              Kernel to descale with\n    :param height:              Height to descale to\n    :param width:               Width to descale to. Please be absolutely certain of what you're doing if you're using get_w for this.\n    :param base_height:         Padded height used in a \"fractional\" descale\n    :param base_width:          Padded width used in a \"fractional\" descale\n                                Both of these are technically optional but highly recommended to have set for float width/height.\n\n    :param shift:               A custom shift to be applied\n    :param mode:                Whether to descale only height, only width, or both.\n                                \"h\" or \"w\" respectively for the former two.\n    :param field_based:         To descale a cross-converted/interlaced clip.\n                                Will try to take the prop from the clip if `None` was passed.\n    \"\"\"\n    clip = self.funcutil.work_clip\n\n    if isinstance(height, float) and len(stack := inspect.stack()) &gt; 1:\n        has_getw = [ctx for ctx in stack[1].code_context if \"get_w\" in ctx.lower()]\n        if has_getw:\n            print(\"RescaleBuilder: Please make sure get_w returns the width you really want!\")\n\n    self.kernel = Kernel.ensure_obj(kernel)\n    self.border_handling = self.kernel.kwargs.pop(\"border_handling\", 0)\n    self.field_based = FieldBased.from_param(field_based) or FieldBased.from_video(clip)\n\n    self.height = height if \"h\" in mode else clip.height\n    self.width = width if \"w\" in mode else clip.width\n    self.base_height = base_height\n    self.base_width = base_width\n\n    if (isinstance(width, float) or isinstance(height, float)) and self.field_based.is_inter:\n        raise CustomValueError(\"Float is not supported for fieldbased descales!\", self.descale)\n\n    if self.field_based.is_inter:\n        self._fieldbased_descale(clip, width=self.width, height=self.height, shift=shift, border_handling=self.border_handling)\n    else:\n        self._non_fieldbased_descale(clip, width, height, base_height, base_width, shift, mode)\n\n    self.descaled = self.descaled.std.CopyFrameProps(clip)\n    self.rescaled = self.rescaled.std.CopyFrameProps(clip)\n\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.double","title":"<code>double(upscaler=ArtCNN.R8F64)</code>","text":"<p>Upscales the descaled clip by 2x</p> <p>Parameters:</p> Name Type Description Default <code>upscaler</code> <code>ScalerLike</code> <p>Any kind of vsscale scaler. Defaults to ArtCNN.R8F64.</p> <code>R8F64</code> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def double(self, upscaler: ScalerLike = ArtCNN.R8F64) -&gt; Self:\n    \"\"\"\n    Upscales the descaled clip by 2x\n\n    :param upscaler:        Any kind of vsscale scaler. Defaults to ArtCNN.R8F64.\n    \"\"\"\n\n    scaler = Scaler.ensure_obj(upscaler)\n    self.doubled = scaler.supersample(self.descaled)\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.downscale","title":"<code>downscale(downscaler=None)</code>","text":"<p>Downscales the clip back the size of the original input clip and applies the masks, if any.</p> <p>Parameters:</p> Name Type Description Default <code>downscaler</code> <code>ScalerLike | None</code> <p>Any vsscale scaler to use. Defaults to Linear Hermite.</p> <code>None</code> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def downscale(self, downscaler: ScalerLike | None = None) -&gt; Self:\n    \"\"\"\n    Downscales the clip back the size of the original input clip and applies the masks, if any.\n\n    :param downscaler:      Any vsscale scaler to use. Defaults to Linear Hermite.\n    \"\"\"\n    if downscaler is None:\n        scaler = Hermite(linear=True)\n    else:\n        scaler = Scaler.ensure_obj(downscaler)\n    if not self.doubled:\n        raise SyntaxError(\"Downscale/Final is the last one that should be called in a chain!\")\n    wclip = self.funcutil.work_clip\n    self.upscaled = scaler.scale(self.doubled, wclip.width, wclip.height, **self.post_crop)\n    self._apply_masks()\n    self.upscaled = self.upscaled.std.CopyFrameProps(wclip)\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.errormask","title":"<code>errormask(mask=0.05, maximum_iter=2, inflate_iter=3, expand=0)</code>","text":"<p>A function to apply a basic error mask to the final output.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>VideoNode | float</code> <p>With a float, and by default, will be created internally. Could also pass a clip.</p> <code>0.05</code> <code>maximum_iter</code> <code>int</code> <p>Apply std.Maximum x amount of times</p> <code>2</code> <code>inflate_iter</code> <code>int</code> <p>Apply std.inflate x amount of times</p> <code>3</code> <code>expand</code> <code>int | tuple[int, int | None]</code> <p>Apply an ellipse morpho expand with the passed amount. Can be a tuple of (horizontal, vertical) or a single value for both.</p> <code>0</code> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def errormask(\n    self, mask: vs.VideoNode | float = 0.05, maximum_iter: int = 2, inflate_iter: int = 3, expand: int | tuple[int, int | None] = 0\n) -&gt; Self:\n    \"\"\"\n    A function to apply a basic error mask to the final output.\n\n    :param mask:            With a float, and by default, will be created internally. Could also pass a clip.\n    :param maximum_iter:    Apply std.Maximum x amount of times\n    :param inflate_iter:    Apply std.inflate x amount of times\n    :param expand:          Apply an ellipse morpho expand with the passed amount.\n                            Can be a tuple of (horizontal, vertical) or a single value for both.\n    \"\"\"\n    self.errormask_clip = self._errormask(mask, maximum_iter, inflate_iter, expand).std.Limiter()\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.errormask_zoned","title":"<code>errormask_zoned(ranges, mask=0.05, maximum_iter=2, inflate_iter=3, expand=0)</code>","text":"<p>A function to apply a basic error mask to the final output.</p> <p>But with this rfs'd to certain ranges.</p> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def errormask_zoned(\n    self,\n    ranges: FrameRangesN,\n    mask: vs.VideoNode | float = 0.05,\n    maximum_iter: int = 2,\n    inflate_iter: int = 3,\n    expand: int | tuple[int, int | None] = 0,\n) -&gt; Self:\n    \"\"\"\n    A function to apply a basic error mask to the final output.\\n\n    But with this rfs'd to certain ranges.\n    \"\"\"\n    if not ranges:\n        return self\n    err_mask = self._errormask(mask, maximum_iter, inflate_iter, expand)\n    if not self.errormask_clip:\n        self.errormask_clip = core.std.BlankClip(self.funcutil.work_clip, format=get_video_format(err_mask))\n\n    self.errormask_clip = replace_ranges(self.errormask_clip, err_mask, ranges)\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.final","title":"<code>final()</code>","text":"<p>This is the last function in the chain that also returns the final clip. It internally calls <code>downscale</code> if you haven't done so before and then merges the resulting clip with the input chroma, if any.</p> <p>Returns:</p> Type Description <code>tuple[Self, VideoNode]</code> <p>A tuple of this class and the resulting final rescale.</p> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def final(self) -&gt; tuple[Self, vs.VideoNode]:\n    \"\"\"\n    This is the last function in the chain that also returns the final clip.\n    It internally calls `downscale` if you haven't done so before and then merges the resulting clip with the input chroma, if any.\n\n    :return: A tuple of this class and the resulting final rescale.\n    \"\"\"\n    if not self.upscaled:\n        self.downscale()\n    if not self.upscaled:\n        raise TypeError(\"No downscaled clip has been generated yet!\")\n\n    return (self, self.funcutil.return_clip(self.upscaled))\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.linemask","title":"<code>linemask(mask=None, downscaler=None, maximum_iter=0, inflate_iter=0, expand=0, kernel_window=None, **kwargs)</code>","text":"<p>A function to apply a linemask to the final output.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>VideoNode | EdgeDetectT | None</code> <p>This can be a masking function like <code>KirschTCanny</code> (also the default if <code>None</code>) or a clip.</p> <code>None</code> <code>downscaler</code> <code>ScalerLike | None</code> <p>Downscaler to use if creating a linemask on the doubled clip. Defaults to <code>Bilinear</code> if <code>None</code>.</p> <code>None</code> <code>maximum_iter</code> <code>int</code> <p>Apply std.Maximum x amount of times</p> <code>0</code> <code>inflate_iter</code> <code>int</code> <p>Apply std.inflate x amount of times</p> <code>0</code> <code>expand</code> <code>int | tuple[int, int | None]</code> <p>Apply an ellipse morpho expand with the passed amount. Can be a tuple of (horizontal, vertical) or a single value for both.</p> <code>0</code> <code>kernel_window</code> <code>int | None</code> <p>To override kernel radius used in case of border_handling being used.</p> <code>None</code> <code>**kwargs</code> <p>Any other params to pass to the edgemask creation. For example <code>lthr</code> or <code>hthr</code>.</p> <code>{}</code> Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def linemask(\n    self,\n    mask: vs.VideoNode | EdgeDetectT | None = None,\n    downscaler: ScalerLike | None = None,\n    maximum_iter: int = 0,\n    inflate_iter: int = 0,\n    expand: int | tuple[int, int | None] = 0,\n    kernel_window: int | None = None,\n    **kwargs,\n) -&gt; Self:\n    \"\"\"\n    A function to apply a linemask to the final output.\n\n    :param mask:            This can be a masking function like `KirschTCanny` (also the default if `None`) or a clip.\n    :param downscaler:      Downscaler to use if creating a linemask on the doubled clip. Defaults to `Bilinear` if `None`.\n    :param maximum_iter:    Apply std.Maximum x amount of times\n    :param inflate_iter:    Apply std.inflate x amount of times\n    :param expand:          Apply an ellipse morpho expand with the passed amount.\n                            Can be a tuple of (horizontal, vertical) or a single value for both.\n    :param kernel_window:   To override kernel radius used in case of border_handling being used.\n    :param **kwargs:        Any other params to pass to the edgemask creation. For example `lthr` or `hthr`.\n    \"\"\"\n    if self.upscaled:\n        raise SyntaxError(\"RescaleBuilder: Downscaled clip already created. Create linemasks before calling downscale.\")\n    if isinstance(mask, vs.VideoNode):\n        self.linemask_clip = mask\n        return self\n    edgemaskFunc = KirschTCanny.ensure_obj(mask)\n\n    # Perform on doubled clip if exists and downscale\n    if self.doubled:\n        scaler = Bilinear.ensure_obj(downscaler)\n        self.linemask_clip = edgemaskFunc.edgemask(self.doubled, **kwargs)\n        self.linemask_clip = scaler.scale(self.linemask_clip, self.funcutil.work_clip.width, self.funcutil.work_clip.height, **self.post_crop)\n    else:\n        self.linemask_clip = edgemaskFunc.edgemask(self.funcutil.work_clip, **kwargs)\n\n    self.linemask_clip = self._process_mask(self.linemask_clip, maximum_iter, inflate_iter, expand)\n\n    if self.border_handling:\n        from .misc import get_border_crop\n\n        borders = get_border_crop(self.funcutil.work_clip, self, kernel_window)\n        self.linemask_clip = self.linemask_clip.std.Crop(*borders).std.AddBorders(*borders, [get_peak_value(self.linemask_clip)])\n\n    self.linemask_clip = self.linemask_clip.std.Limiter()\n\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.post_descale","title":"<code>post_descale(func)</code>","text":"<p>A function to apply any arbitrary function on the descaled clip.</p> <p>I can't think of a good usecase/example for this but I was asked to add this before.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>GenericVSFunction | list[GenericVSFunction]</code> <p>This can be any function or list of functions that take a videonode input and returns a videonode. You are responsible for keeping the format the same.</p> required Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def post_descale(self, func: GenericVSFunction | list[GenericVSFunction]) -&gt; Self:\n    \"\"\"\n    A function to apply any arbitrary function on the descaled clip.\\n\n    I can't think of a good usecase/example for this but I was asked to add this before.\n\n    :param func:    This can be any function or list of functions that take a videonode input\n                    and returns a videonode. You are responsible for keeping the format the same.\n    \"\"\"\n    if not isinstance(func, list):\n        func = [func]\n\n    for f in func:\n        if not callable(f):\n            raise CustomValueError(f\"post_descale: Function {f.__name__} is not callable!\", self.post_descale)\n\n        self.descaled = f(self.descaled)\n\n    return self\n</code></pre>"},{"location":"vodesfunc/rescale/#vodesfunc.rescale.RescaleBuilder.post_double","title":"<code>post_double(func)</code>","text":"<p>A function to apply any arbitrary function on the doubled clip.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>GenericVSFunction | list[GenericVSFunction]</code> <p>This can be any function or list of functions that take a videonode input and returns a videonode. You are responsible for keeping the format the same.</p> required Source code in <code>         vodesfunc/rescale.py       </code> <pre><code>def post_double(self, func: GenericVSFunction | list[GenericVSFunction]) -&gt; Self:\n    \"\"\"\n    A function to apply any arbitrary function on the doubled clip.\n\n    :param func:    This can be any function or list of functions that take a videonode input\n                    and returns a videonode. You are responsible for keeping the format the same.\n    \"\"\"\n    if not self.doubled:\n        raise SyntaxError(\"post_double: Doubled clip has not been generated yet. Please call this after double().\")\n\n    if not isinstance(func, list):\n        func = [func]\n\n    for f in func:\n        if not callable(f):\n            raise CustomValueError(f\"post_double: Function {f.__name__} is not callable!\", self.post_double)\n\n        self.doubled = f(self.doubled)\n\n    return self\n</code></pre>"},{"location":"vodesfunc/scale/","title":"scale","text":""},{"location":"vodesfunc/scale/#vodesfunc.scale.Lanczos_PreSS","title":"<code>Lanczos_PreSS</code>","text":"<p>               Bases: <code>Lanczos</code></p> <p>Convenience class to pass to a dehalo function. This serves the same purpose as NNEDI to double and reverse using point. Except it is a quite a bit faster and (if using opencl) takes a lot of load off the GPU.</p> Source code in <code>           vodesfunc/scale.py         </code> <pre><code>class Lanczos_PreSS(Lanczos):\n    \"\"\"\n    Convenience class to pass to a dehalo function.\n    This serves the same purpose as NNEDI to double and reverse using point.\n    Except it is a quite a bit faster and (if using opencl) takes a lot of load off the GPU.\n    \"\"\"\n\n    @inject_self.init_kwargs.clean\n    def scale(self, clip: vs.VideoNode, width: int, height: int, shift: tuple[float, float] = (0, 0), **kwargs) -&gt; vs.VideoNode:\n        if width != clip.width * 2 or height != clip.height * 2:\n            raise ValueError(\"Lanczos_PreSS: You're probably not using this correctly.\")\n        return Lanczos.scale(clip, width, height, (-0.25, -0.25))\n</code></pre>"},{"location":"vodesfunc/spikefinder/","title":"spikefinder","text":""},{"location":"vodesfunc/spikefinder/#vodesfunc.spikefinder.NVENC_H265","title":"<code>NVENC_H265</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code></p> <p>Uses ffmpeg to encode clip to a h265 stream via nvenc. (Should this be in vsmuxtools?)</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>str</code> <p>Can either be a string of your own settings or any of the 3 presets.</p> <code>''</code> <code>ensure_props</code> <code>bool</code> <p>Calls initialize_clip on the clip to have at the very least guessed props</p> <code>True</code> Source code in <code>           vodesfunc/spikefinder.py         </code> <pre><code>@dataclass\nclass NVENC_H265(VideoEncoder):\n    \"\"\"\n    Uses ffmpeg to encode clip to a h265 stream via nvenc.\n    (Should this be in vsmuxtools?)\n\n    :param settings:        Can either be a string of your own settings or any of the 3 presets.\n    :param ensure_props:    Calls initialize_clip on the clip to have at the very least guessed props\n    \"\"\"\n\n    settings: str = \"\"\n    ensure_props: bool = True\n\n    def __post_init__(self):\n        self.executable = get_executable(\"ffmpeg\")\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        bits = get_depth(clip)\n        if bits &gt; 10:\n            warn(\"This encoder does not support a bit depth over 10.\\nClip will be dithered to 10 bit.\", self, 2)\n            clip = finalize_clip(clip, 10)\n            bits = 10\n        if self.ensure_props:\n            clip = initialize_clip(clip, bits)\n            clip = finalize_clip(clip, bits)\n\n        out = make_output(\"encoded_nvenc\", \"mkv\", user_passed=outfile)\n\n        args = [self.executable, \"-hide_banner\", \"-v\", \"quiet\", \"-stats\", \"-f\", \"yuv4mpegpipe\", \"-i\", \"-\", \"-c:v\", \"hevc_nvenc\"]\n        if self.settings:\n            args.extend(shlex.split(self.settings))\n        args.append(str(out))\n\n        process = subprocess.Popen(args, stdin=subprocess.PIPE)\n        clip.output(process.stdin, y4m=True, progress_update=lambda x, y: self._update_progress(x, y))  # type: ignore\n        process.communicate()\n        return VideoFile(out)\n</code></pre>"},{"location":"vodesfunc/spikefinder/#vodesfunc.spikefinder.fetch_frames_with_sizes","title":"<code>fetch_frames_with_sizes(fileIn, fps)</code>","text":"<p>Extracts frame info with ffprobe</p> Source code in <code>         vodesfunc/spikefinder.py       </code> <pre><code>def fetch_frames_with_sizes(fileIn: Path, fps: Fraction) -&gt; list[Framedata]:\n    \"\"\"\n    Extracts frame info with ffprobe\n    \"\"\"\n    bitrate_data = list[Framedata]()\n    current_frame = 0\n    command = [\n        get_executable(\"ffprobe\"),\n        \"-show_entries\",\n        \"packet=size,duration_time,pts_time\",\n        \"-select_streams\",\n        \"v\",\n        \"-print_format\",\n        \"json=compact=1\",\n        str(fileIn),\n    ]\n    out = subprocess.run(command, capture_output=True, text=True, universal_newlines=True)\n    output = out.stdout + out.stderr\n    for line in output.splitlines():\n        if len(line) == 0:\n            break\n        if len(line) &gt; 0 and line[-1] == \",\":\n            line = line[:-1]\n\n        if \"pts_time\" in line:\n            try:\n                decoded = json.loads(line)\n            except:\n                print(line)\n                raise Exception\n\n            frame_bitrate = (float(decoded.get(\"size\")) * 8 / 1000) * fps\n            frame_time = float(decoded.get(\"pts_time\"))\n            bitrate_data.append(Framedata(current_frame, frame_time, frame_bitrate))\n            current_frame += 1\n\n    return bitrate_data\n</code></pre>"},{"location":"vodesfunc/spikefinder/#vodesfunc.spikefinder.find_spikes","title":"<code>find_spikes(clip, threshold=11500, nvenc_settings='-preset 3 -rc vbr_hq -pix_fmt p010le -b:v 6M -maxrate:v 22M', print_ranges=False, export_file=None, ignore_existing=False)</code>","text":"<p>Encodes a clip with nvenc hevc and analyzes the bitrate averages between scene changes to find spikes.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>VideoNode</code> <p>Clip to encode</p> required <code>threshold</code> <code>int</code> <p>Bitrate threshold to add to ranges (in kbps, I think)</p> <code>11500</code> <code>nvenc_settings</code> <code>str</code> <p>Settings to use for the encoder</p> <code>'-preset 3 -rc vbr_hq -pix_fmt p010le -b:v 6M -maxrate:v 22M'</code> <code>print_ranges</code> <code>bool</code> <p>If you want to print the ranges with corresponding bitrates</p> <code>False</code> <code>export_file</code> <code>None | PathLike</code> <p>Export the ranges to a bookmarks file with the given name. None to disable.</p> <code>None</code> <code>ignore_existing</code> <code>bool</code> <p>Run again and overwrite the exported file if it exists. By default it won't run again.</p> <code>False</code> Source code in <code>         vodesfunc/spikefinder.py       </code> <pre><code>def find_spikes(\n    clip: vs.VideoNode,\n    threshold: int = 11500,\n    nvenc_settings: str = \"-preset 3 -rc vbr_hq -pix_fmt p010le -b:v 6M -maxrate:v 22M\",\n    print_ranges: bool = False,\n    export_file: None | PathLike = None,\n    ignore_existing: bool = False,\n) -&gt; FrameRangesN:\n    \"\"\"\n    Encodes a clip with nvenc hevc and analyzes the bitrate averages between scene changes to find spikes.\n\n    :param clip:            Clip to encode\n    :param threshold:       Bitrate threshold to add to ranges (in kbps, I think)\n    :param nvenc_settings:  Settings to use for the encoder\n    :param print_ranges:    If you want to print the ranges with corresponding bitrates\n    :param export_file:     Export the ranges to a bookmarks file with the given name. None to disable.\n    :param ignore_existing: Run again and overwrite the exported file if it exists. By default it won't run again.\n    \"\"\"\n    if export_file:\n        out_file = make_output(export_file, \"bookmarks\", user_passed=export_file)\n        if out_file.exists():\n            if ignore_existing:\n                out_file.unlink(True)\n            else:\n                return read_ranges_bookmarks(out_file)\n\n    ranges: list[SoftRange] = []\n    info(\"Encoding clip using nvenc...\", find_spikes)\n    temp_encode = NVENC_H265(nvenc_settings).encode(clip, \"temp_nvenc\")\n    encoded_file = ensure_path_exists(temp_encode.file, find_spikes)\n    info(\"Extracting frame data...\", find_spikes)\n    framedata = fetch_frames_with_sizes(encoded_file, Fraction(clip.fps_num, clip.fps_den))\n    info(\"Finding scene changes...\")\n    chunks = split_by_keyframes(framedata, clip)\n    encoded_file.unlink(True)\n\n    for chunk in chunks:\n        size_all: float = 0.0\n        for data in chunk:\n            size_all += data.frame_size\n        avg = size_all / len(chunk)\n        if avg &gt; threshold:\n            ranges.append((chunk[0].frame, chunk[-1].frame))\n            if print_ranges:\n                debug(f\"Frames {chunk[0].frame} - {chunk[-1].frame}: {round(avg, 2)} kbps\", find_spikes)\n\n    # To make the ranges not have single frame outliers\n    ranges_int = normalize_ranges_to_list(ranges)\n    final_ranges = normalize_list_to_ranges(ranges_int)\n\n    if export_file:\n        with open(out_file, \"w\", encoding=\"utf-8\") as writer:\n            all_nums = list[int]()\n            for start, end in final_ranges:\n                all_nums.extend([start, end])\n            writer.write(\", \".join([str(it) for it in all_nums]))\n\n    return final_ranges\n</code></pre>"},{"location":"vodesfunc/spikefinder/#vodesfunc.spikefinder.split_by_keyframes","title":"<code>split_by_keyframes(data, clip)</code>","text":"<p>Search for scene changes and divide framedata into chunks that start with one.</p> Source code in <code>         vodesfunc/spikefinder.py       </code> <pre><code>def split_by_keyframes(data: list[Framedata], clip: vs.VideoNode) -&gt; list[list[Framedata]]:\n    \"\"\"\n    Search for scene changes and divide framedata into chunks that start with one.\n    \"\"\"\n    keyframes = Keyframes.from_clip(clip)\n    chunks = []\n    current_chunk = []\n\n    for item in data:\n        if item.frame in keyframes:\n            if current_chunk:\n                chunks.append(current_chunk)\n            current_chunk = [item]\n        else:\n            current_chunk.append(item)\n\n    if current_chunk:\n        chunks.append(current_chunk)\n\n    return chunks\n</code></pre>"},{"location":"vodesfunc/util/","title":"util","text":""},{"location":"vodesfunc/util/#vodesfunc.util.set_output","title":"<code>set_output(clip, name=None, frame_info=False, allow_comp=True, cache=None, **kwargs)</code>","text":"<p>Outputs a clip. Less to type. Designed to be used with the good ol 'from vodesfunc import *' and the 'out' alias</p> Source code in <code>         vodesfunc/util.py       </code> <pre><code>def set_output(\n    clip: vs.VideoNode, name: str | None = None, frame_info: bool = False, allow_comp: bool = True, cache: bool | None = None, **kwargs: KwargsT\n) -&gt; vs.VideoNode:\n    \"\"\"\n    Outputs a clip. Less to type.\n    Designed to be used with the good ol 'from vodesfunc import *' and the 'out' alias\n    \"\"\"\n    if frame_info and name:\n        clip = _print_frameinfo(clip, name)\n\n    try:\n        args = KwargsT(name=name, cache=cache, disable_comp=not allow_comp)\n        if kwargs:\n            args.update(**kwargs)\n        from vspreview import is_preview, set_output as setsu_sucks\n\n        if cache is None:\n            cache = is_preview()\n        setsu_sucks(clip, **args)\n    except:\n        if name is not None:\n            clip = clip.std.SetFrameProp(\"Name\", data=name)\n        clip.set_output(len(vs.get_outputs()))\n    return clip\n</code></pre>"},{"location":"vs-muxtools/extension/","title":"extension","text":""},{"location":"vs-muxtools/extension/#vsmuxtools.extension.audio.do_audio","title":"<code>do_audio(fileIn, track=0, trims=None, timesource=None, timescale=TimeScale.MKV, num_frames=0, extractor=FFMpeg.Extractor(), trimmer=AutoTrimmer(), encoder=AutoEncoder(), quiet=True, output=None)</code>","text":"<p>One-liner to handle the whole audio processing</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike | src_file | AudioNode</code> <p>Input file or src_file/FileInfo or AudioNode</p> required <code>track</code> <code>int</code> <p>Audio track number</p> <code>0</code> <code>trims</code> <code>Trim | list[Trim] | None</code> <p>Frame ranges to trim and/or combine, e.g. (24, -24) or [(24, 500), (700, 900)] If your passed src_file has a trim it will use it. Any other trims passed here will overwrite it.</p> <code>None</code> <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.  Will be taken from input if it's a src_file and assume the usual 24 if not.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>num_frames</code> <code>int</code> <p>Total number of frames, used for negative numbers in trims Will be taken from input if it's a src_file</p> <code>0</code> <code>extractor</code> <code>Extractor</code> <p>Tool used to extract the audio (Will default to None if an AudioNode gets passed)</p> <code>Extractor()</code> <code>trimmer</code> <code>Trimmer | None</code> <p>Tool used to trim the audio AutoTrimmer means it will choose ffmpeg for lossy and Sox for lossless</p> <code>AutoTrimmer()</code> <code>encoder</code> <code>Encoder | None</code> <p>Tool used to encode the audio AutoEncoder means it won't reencode lossy and choose opus otherwise</p> <code>AutoEncoder()</code> <code>quiet</code> <code>bool</code> <p>Whether the tool output should be visible</p> <code>True</code> <code>output</code> <code>PathLike | None</code> <p>Custom output file or directory, extensions will be automatically added</p> <code>None</code> <p>Returns:</p> Type Description <code>AudioFile</code> <p>AudioFile Object containing file path, delays and source</p> Source code in <code>         vsmuxtools/extension/audio.py       </code> <pre><code>def do_audio(\n    fileIn: PathLike | src_file | vs.AudioNode,\n    track: int = 0,\n    trims: Trim | list[Trim] | None = None,\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = TimeScale.MKV,\n    num_frames: int = 0,\n    extractor: Extractor = FFMpeg.Extractor(),\n    trimmer: Trimmer | None = AutoTrimmer(),\n    encoder: Encoder | None = AutoEncoder(),\n    quiet: bool = True,\n    output: PathLike | None = None,\n) -&gt; AudioFile:\n    \"\"\"\n    One-liner to handle the whole audio processing\n\n    :param fileIn:          Input file or src_file/FileInfo or AudioNode\n    :param track:           Audio track number\n    :param trims:           Frame ranges to trim and/or combine, e.g. (24, -24) or [(24, 500), (700, 900)]\n                            If your passed src_file has a trim it will use it. Any other trims passed here will overwrite it.\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\\n\n                            Will be taken from input if it's a src_file and assume the usual 24 if not.\n\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n\n    :param num_frames:      Total number of frames, used for negative numbers in trims\n                            Will be taken from input if it's a src_file\n\n    :param extractor:       Tool used to extract the audio (Will default to None if an AudioNode gets passed)\n    :param trimmer:         Tool used to trim the audio\n                            AutoTrimmer means it will choose ffmpeg for lossy and Sox for lossless\n\n    :param encoder:         Tool used to encode the audio\n                            AutoEncoder means it won't reencode lossy and choose opus otherwise\n\n    :param quiet:           Whether the tool output should be visible\n    :param output:          Custom output file or directory, extensions will be automatically added\n    :return:                AudioFile Object containing file path, delays and source\n    \"\"\"\n    if trims is not None:\n        if isinstance(fileIn, src_file):\n            danger(\"Other trims passed will overwrite whatever your src_file has!\", do_audio, 1)\n        if isinstance(fileIn, vs.AudioNode):\n            danger(\"Trims won't be applied if you pass an Audionode. Just do them yourself before this lol.\", do_audio, 1)\n            trims = None\n            trimmer = None\n\n    if isinstance(fileIn, vs.AudioNode):\n        extractor = None\n        fileIn = export_audionode(fileIn)\n    elif isinstance(fileIn, src_file):\n        if not trims:\n            trims = fileIn.trim\n\n        clip = fileIn.src\n        fileIn = fileIn.file\n        if not num_frames:\n            num_frames = clip.num_frames\n        if timesource is None:\n            timesource = Fraction(clip.fps_num, clip.fps_den)\n\n    if timesource is None:\n        timesource = Fraction(24000, 1001)\n\n    return mt_audio(fileIn, track, trims, timesource, timescale, num_frames, extractor, trimmer, encoder, quiet, output)\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.audio.export_audionode","title":"<code>export_audionode(node, outfile=None)</code>","text":"<p>Exports an audionode to a wav/w64 file.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AudioNode</code> <p>Your audionode</p> required <code>outfile</code> <code>PathLike | None</code> <p>Custom output path if any</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Returns path</p> Source code in <code>         vsmuxtools/extension/audio.py       </code> <pre><code>def export_audionode(node: vs.AudioNode, outfile: PathLike | None = None) -&gt; Path:\n    \"\"\"\n    Exports an audionode to a wav/w64 file.\n\n    :param node:            Your audionode\n    :param outfile:         Custom output path if any\n\n    :return:                Returns path\n    \"\"\"\n    if not outfile:\n        outfile = uniquify_path(Path(get_workdir(), \"exported.wav\"))\n\n    outfile = ensure_path(outfile, export_audionode)\n    with open(outfile, \"wb\") as bf:\n        audio_async_render(node, bf)\n    return outfile\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.chapters.Chapters","title":"<code>Chapters</code>","text":"<p>               Bases: <code>Chapters</code></p> Source code in <code>           vsmuxtools/extension/chapters.py         </code> <pre><code>class Chapters(Ch):\n    def __init__(\n        self,\n        chapter_source: src_file | PathLike | GlobSearch | Chapter | list[Chapter],\n        timesource: TimeSourceT = None,\n        timescale: TimeScaleT = TimeScale.MKV,\n        _print: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Convenience class for chapters\n\n        :param chapter_source:      Input either src_file/FileInfo, txt with ogm chapters, xml or (a list of) self defined chapters.\n        :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\\n\n                                    Will be taken from input if it's a src_file and assume the usual 24 if not.\n\n        :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                    For details check the docstring on the type.\n\n        :param _print:              Prints chapters after parsing and after trimming.\n        \"\"\"\n        if isinstance(chapter_source, src_file):\n            if isinstance(chapter_source.file, list):\n                # I'll make a workaround for this soonish\n                raise error(\"Cannot currently parse chapters when splicing multiple files.\", self)\n            clip_fps = Fraction(chapter_source.src.fps_num, chapter_source.src.fps_den)\n            self.timestamps = resolve_timesource_and_scale(timesource if timesource else clip_fps, timescale, caller=self)\n            self.chapters = parse_chapters_bdmv(chapter_source.file, clip_fps, chapter_source.src_cut.num_frames, _print)\n            if self.chapters and chapter_source.trim:\n                self.trim(chapter_source.trim[0], chapter_source.trim[1], chapter_source.src_cut.num_frames)\n                if _print:\n                    print(\"After trim:\")\n                    self.print()\n        else:\n            super().__init__(chapter_source, timesource or Fraction(24000, 1001), timescale, _print)\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.chapters.Chapters.__init__","title":"<code>__init__(chapter_source, timesource=None, timescale=TimeScale.MKV, _print=True)</code>","text":"<p>Convenience class for chapters</p> <p>Parameters:</p> Name Type Description Default <code>chapter_source</code> <code>src_file | PathLike | GlobSearch | Chapter | list[Chapter]</code> <p>Input either src_file/FileInfo, txt with ogm chapters, xml or (a list of) self defined chapters.</p> required <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.  Will be taken from input if it's a src_file and assume the usual 24 if not.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> <code>_print</code> <code>bool</code> <p>Prints chapters after parsing and after trimming.</p> <code>True</code> Source code in <code>         vsmuxtools/extension/chapters.py       </code> <pre><code>def __init__(\n    self,\n    chapter_source: src_file | PathLike | GlobSearch | Chapter | list[Chapter],\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = TimeScale.MKV,\n    _print: bool = True,\n) -&gt; None:\n    \"\"\"\n    Convenience class for chapters\n\n    :param chapter_source:      Input either src_file/FileInfo, txt with ogm chapters, xml or (a list of) self defined chapters.\n    :param timesource:          The source of timestamps/timecodes. For details check the docstring on the type.\\n\n                                Will be taken from input if it's a src_file and assume the usual 24 if not.\n\n    :param timescale:           Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n\n    :param _print:              Prints chapters after parsing and after trimming.\n    \"\"\"\n    if isinstance(chapter_source, src_file):\n        if isinstance(chapter_source.file, list):\n            # I'll make a workaround for this soonish\n            raise error(\"Cannot currently parse chapters when splicing multiple files.\", self)\n        clip_fps = Fraction(chapter_source.src.fps_num, chapter_source.src.fps_den)\n        self.timestamps = resolve_timesource_and_scale(timesource if timesource else clip_fps, timescale, caller=self)\n        self.chapters = parse_chapters_bdmv(chapter_source.file, clip_fps, chapter_source.src_cut.num_frames, _print)\n        if self.chapters and chapter_source.trim:\n            self.trim(chapter_source.trim[0], chapter_source.trim[1], chapter_source.src_cut.num_frames)\n            if _print:\n                print(\"After trim:\")\n                self.print()\n    else:\n        super().__init__(chapter_source, timesource or Fraction(24000, 1001), timescale, _print)\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.sub.SubFile","title":"<code>SubFile</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubFile</code></p> <p>Utility class representing an ASS/SSA subtitle file with various functions to run on.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | list[PathLike] | GlobSearch</code> <p>Can be a string, Path object or GlobSearch. If the GlobSearch returns multiple results or if a list was passed it will merge them.</p> required <code>container_delay</code> <code>int</code> <p>Set a container delay used in the muxing process later.</p> <code>0</code> <code>source</code> <code>PathLike | None</code> <p>The file this sub originates from, will be set by the constructor.</p> <code>None</code> <code>encoding</code> <p>Encoding used for reading and writing the subtitle files.</p> required Source code in <code>           vsmuxtools/extension/sub.py         </code> <pre><code>@dataclass\nclass SubFile(MTSubFile):\n    \"\"\"\n    Utility class representing an ASS/SSA subtitle file with various functions to run on.\n\n    :param file:            Can be a string, Path object or GlobSearch.\n                            If the GlobSearch returns multiple results or if a list was passed it will merge them.\n\n    :param container_delay: Set a container delay used in the muxing process later.\n    :param source:          The file this sub originates from, will be set by the constructor.\n    :param encoding:        Encoding used for reading and writing the subtitle files.\n    \"\"\"\n\n    def truncate_by_video(\n        self,\n        source: PathLike | VideoTrack | MkvTrack | VideoFile | vs.VideoNode,\n        timesource: TimeSourceT = None,\n        timescale: TimeScaleT = TimeScale.MKV,\n    ) -&gt; Self:\n        \"\"\"\n        Removes lines that start after the video ends and trims lines that extend past it.\n\n        :param source:          Can be any video file or a VideoNode\n        :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n        :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                                For details check the docstring on the type.\n        \"\"\"\n\n        if isinstance(source, vs.VideoNode):\n            frames = source.num_frames\n            if not timesource:\n                timesource = Fraction(source.fps_num, source.fps_den)\n            resolved_ts = resolve_timesource_and_scale(timesource, timescale, allow_warn=False, caller=self)\n        else:\n            if isinstance(source, VideoTrack) or isinstance(source, MkvTrack) or isinstance(source, VideoFile):\n                file = ensure_path_exists(source.file, self)\n            else:\n                file = ensure_path_exists(source, self)\n\n            parsed = ParsedFile.from_file(file, self)\n\n            assert parsed.find_tracks(type=TrackType.VIDEO, error_if_empty=True, caller=self)[0]\n\n            meta = get_timemeta_from_video(file, caller=self)\n            frames = len(meta.pts)\n            if not timesource:\n                timesource = meta\n                timescale = meta.timescale\n            resolved_ts = resolve_timesource_and_scale(timesource, timescale, allow_warn=False, caller=self)\n\n        cutoff = timedelta(milliseconds=resolved_ts.frame_to_time(frames + 1, TimeType.START, 2, True) * 10)\n\n        def filter_lines(lines: LINES):\n            removed = 0\n            trimmed = 0\n            new_list = list[_Line]()\n            for line in lines:\n                if line.start &gt; cutoff:\n                    removed += 1\n                    continue\n                if line.end &gt; cutoff:\n                    line.end = timedelta(milliseconds=resolved_ts.frame_to_time(frames, TimeType.END, 2, True) * 10)\n                    trimmed += 1\n                new_list.append(line)\n\n            if removed or trimmed:\n                if removed:\n                    debug(f\"Removed {removed} line{'s' if removed != 1 else ''} that started past the video\", self)\n                if trimmed:\n                    debug(f\"Trimmed {trimmed} line{'s' if trimmed != 1 else ''} that extended past the video\", self)\n\n            return new_list\n\n        return self.manipulate_lines(filter_lines)\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.sub.SubFile.truncate_by_video","title":"<code>truncate_by_video(source, timesource=None, timescale=TimeScale.MKV)</code>","text":"<p>Removes lines that start after the video ends and trims lines that extend past it.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>PathLike | VideoTrack | MkvTrack | VideoFile | VideoNode</code> <p>Can be any video file or a VideoNode</p> required <code>timesource</code> <code>TimeSourceT</code> <p>The source of timestamps/timecodes. For details check the docstring on the type.</p> <code>None</code> <code>timescale</code> <code>TimeScaleT</code> <p>Unit of time (in seconds) in terms of which frame timestamps are represented.  For details check the docstring on the type.</p> <code>MKV</code> Source code in <code>         vsmuxtools/extension/sub.py       </code> <pre><code>def truncate_by_video(\n    self,\n    source: PathLike | VideoTrack | MkvTrack | VideoFile | vs.VideoNode,\n    timesource: TimeSourceT = None,\n    timescale: TimeScaleT = TimeScale.MKV,\n) -&gt; Self:\n    \"\"\"\n    Removes lines that start after the video ends and trims lines that extend past it.\n\n    :param source:          Can be any video file or a VideoNode\n    :param timesource:      The source of timestamps/timecodes. For details check the docstring on the type.\n    :param timescale:       Unit of time (in seconds) in terms of which frame timestamps are represented.\\n\n                            For details check the docstring on the type.\n    \"\"\"\n\n    if isinstance(source, vs.VideoNode):\n        frames = source.num_frames\n        if not timesource:\n            timesource = Fraction(source.fps_num, source.fps_den)\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, allow_warn=False, caller=self)\n    else:\n        if isinstance(source, VideoTrack) or isinstance(source, MkvTrack) or isinstance(source, VideoFile):\n            file = ensure_path_exists(source.file, self)\n        else:\n            file = ensure_path_exists(source, self)\n\n        parsed = ParsedFile.from_file(file, self)\n\n        assert parsed.find_tracks(type=TrackType.VIDEO, error_if_empty=True, caller=self)[0]\n\n        meta = get_timemeta_from_video(file, caller=self)\n        frames = len(meta.pts)\n        if not timesource:\n            timesource = meta\n            timescale = meta.timescale\n        resolved_ts = resolve_timesource_and_scale(timesource, timescale, allow_warn=False, caller=self)\n\n    cutoff = timedelta(milliseconds=resolved_ts.frame_to_time(frames + 1, TimeType.START, 2, True) * 10)\n\n    def filter_lines(lines: LINES):\n        removed = 0\n        trimmed = 0\n        new_list = list[_Line]()\n        for line in lines:\n            if line.start &gt; cutoff:\n                removed += 1\n                continue\n            if line.end &gt; cutoff:\n                line.end = timedelta(milliseconds=resolved_ts.frame_to_time(frames, TimeType.END, 2, True) * 10)\n                trimmed += 1\n            new_list.append(line)\n\n        if removed or trimmed:\n            if removed:\n                debug(f\"Removed {removed} line{'s' if removed != 1 else ''} that started past the video\", self)\n            if trimmed:\n                debug(f\"Trimmed {trimmed} line{'s' if trimmed != 1 else ''} that extended past the video\", self)\n\n        return new_list\n\n    return self.manipulate_lines(filter_lines)\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.sub.SubFilePGS","title":"<code>SubFilePGS</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubFilePGS</code></p> <p>Utility class representing a PGS/SUP subtitle file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | list[PathLike] | GlobSearch</code> <p>Can be a string, Path object or GlobSearch.</p> required <code>container_delay</code> <code>int</code> <p>Set a container delay used in the muxing process later.</p> <code>0</code> <code>source</code> <code>PathLike | None</code> <p>The file this sub originates from, will be set by the constructor.</p> <code>None</code> Source code in <code>           vsmuxtools/extension/sub.py         </code> <pre><code>@dataclass\nclass SubFilePGS(MTSubFilePGS):\n    \"\"\"\n    Utility class representing a PGS/SUP subtitle file.\n\n    :param file:            Can be a string, Path object or GlobSearch.\n    :param container_delay: Set a container delay used in the muxing process later.\n    :param source:          The file this sub originates from, will be set by the constructor.\n    \"\"\"\n\n    @classmethod\n    def extract_from(cls: type[Self], fileIn: PathLike | src_file, track: int = 0, preserve_delay: bool = False, quiet: bool = True) -&gt; Self:\n        \"\"\"\n        Extract a PGS subtitle track from a file using ffmpeg.\\n\n\n        :param fileIn:          The input file to extract from.\n        :param track:           The track number to extract.\n        :param preserve_delay:  If True, the container delay will be preserved.\n        :param quiet:           If True, suppresses ffmpeg output.\n        :return:                An instance of SubFilePGS containing the extracted subtitle.\n        \"\"\"\n        f = fileIn\n        if isinstance(f, src_file):\n            if isinstance(f.file, list):\n                # I'll make a workaround for this soonish\n                raise error(\"Cannot currently parse chapters when splicing multiple files.\", cls.__name__)\n            f = f.file\n        new = super().extract_from(\n            f,\n            track=track,\n            preserve_delay=preserve_delay,\n            quiet=quiet,\n        )\n        if isinstance(fileIn, src_file) and fileIn.trim:\n            if fileIn.trim[0]:\n                debug(f\"Shifting extracted subtitle by -{fileIn.trim[0]} frames...\", cls.__name__)\n                new = new.shift(-fileIn.trim[0], timesource=fileIn.file, quiet=quiet)\n            if fileIn.trim[1]:\n                warn(\"Trimming is currently not supported for PGS subtitles.\", cls.__name__)\n        return new\n</code></pre>"},{"location":"vs-muxtools/extension/#vsmuxtools.extension.sub.SubFilePGS.extract_from","title":"<code>extract_from(fileIn, track=0, preserve_delay=False, quiet=True)</code>  <code>classmethod</code>","text":"<p>Extract a PGS subtitle track from a file using ffmpeg.</p> <p>Parameters:</p> Name Type Description Default <code>fileIn</code> <code>PathLike | src_file</code> <p>The input file to extract from.</p> required <code>track</code> <code>int</code> <p>The track number to extract.</p> <code>0</code> <code>preserve_delay</code> <code>bool</code> <p>If True, the container delay will be preserved.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If True, suppresses ffmpeg output.</p> <code>True</code> <p>Returns:</p> Type Description <code>Self</code> <p>An instance of SubFilePGS containing the extracted subtitle.</p> Source code in <code>         vsmuxtools/extension/sub.py       </code> <pre><code>@classmethod\ndef extract_from(cls: type[Self], fileIn: PathLike | src_file, track: int = 0, preserve_delay: bool = False, quiet: bool = True) -&gt; Self:\n    \"\"\"\n    Extract a PGS subtitle track from a file using ffmpeg.\\n\n\n    :param fileIn:          The input file to extract from.\n    :param track:           The track number to extract.\n    :param preserve_delay:  If True, the container delay will be preserved.\n    :param quiet:           If True, suppresses ffmpeg output.\n    :return:                An instance of SubFilePGS containing the extracted subtitle.\n    \"\"\"\n    f = fileIn\n    if isinstance(f, src_file):\n        if isinstance(f.file, list):\n            # I'll make a workaround for this soonish\n            raise error(\"Cannot currently parse chapters when splicing multiple files.\", cls.__name__)\n        f = f.file\n    new = super().extract_from(\n        f,\n        track=track,\n        preserve_delay=preserve_delay,\n        quiet=quiet,\n    )\n    if isinstance(fileIn, src_file) and fileIn.trim:\n        if fileIn.trim[0]:\n            debug(f\"Shifting extracted subtitle by -{fileIn.trim[0]} frames...\", cls.__name__)\n            new = new.shift(-fileIn.trim[0], timesource=fileIn.file, quiet=quiet)\n        if fileIn.trim[1]:\n            warn(\"Trimming is currently not supported for PGS subtitles.\", cls.__name__)\n    return new\n</code></pre>"},{"location":"vs-muxtools/utils/audio/","title":"audio","text":""},{"location":"vs-muxtools/utils/audio/#vsmuxtools.utils.audio.__all__","title":"<code>__all__ = ['audio_async_render', 'WaveHeader']</code>  <code>module-attribute</code>","text":"<p>Most if not everything in this file is stolen from this because I don't feel like waiting for setsu to add it to vapoursynth itself.</p> <p>https://github.com/Ichunjo/vardautomation/blob/fae054956b3611e641276dc92f4a8c4060a3d8e2/vardautomation/render.py</p>"},{"location":"vs-muxtools/utils/audio/#vsmuxtools.utils.audio.WaveFormat","title":"<code>WaveFormat</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>WAVE form wFormatTag IDs Complete list is in mmreg.h in Windows 10 SDK.</p> Source code in <code>           vsmuxtools/utils/audio.py         </code> <pre><code>class WaveFormat(IntEnum):\n    \"\"\"\n    WAVE form wFormatTag IDs\n    Complete list is in mmreg.h in Windows 10 SDK.\n    \"\"\"\n\n    PCM = 0x0001\n    IEEE_FLOAT = 0x0003\n    EXTENSIBLE = 0xFFFE\n</code></pre>"},{"location":"vs-muxtools/utils/audio/#vsmuxtools.utils.audio.WaveHeader","title":"<code>WaveHeader</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Wave headers</p> Source code in <code>           vsmuxtools/utils/audio.py         </code> <pre><code>class WaveHeader(IntEnum):\n    \"\"\"\n    Wave headers\n    \"\"\"\n\n    WAVE = 0\n    WAVE64 = 1\n    AUTO = 2\n</code></pre>"},{"location":"vs-muxtools/utils/audio/#vsmuxtools.utils.audio.audio_async_render","title":"<code>audio_async_render(audio, outfile, header=WaveHeader.AUTO, progress='Rendering audio...')</code>","text":"<p>Render an audio by requesting frames asynchronously using audio.frames.</p> <p>Implementation-like of VideoNode.output for an AudioNode that isn't in the Cython side yet.</p> <p>Parameters:</p> Name Type Description Default <code>audio</code> <code>AudioNode</code> <p>Audio to render.</p> required <code>outfile</code> <code>BinaryIO</code> <p>Render output BinaryIO handle.</p> required <code>header</code> <code>WaveHeader</code> <p>Kind of Wave header. WaveHeader.AUTO adds a Wave64 header if the audio  * Has more than 2 channels * Has a bitdepth &gt; 16 * Has more than 44100 samples</p> <code>AUTO</code> <code>progress</code> <code>Optional[str]</code> <p>String to use for render progress display. If empty or <code>None</code>, no progress display.</p> <code>'Rendering audio...'</code> Source code in <code>         vsmuxtools/utils/audio.py       </code> <pre><code>def audio_async_render(\n    audio: vs.AudioNode, outfile: BinaryIO, header: WaveHeader = WaveHeader.AUTO, progress: Optional[str] = \"Rendering audio...\"\n) -&gt; None:\n    \"\"\"\n    Render an audio by requesting frames asynchronously using audio.frames.\n\n    Implementation-like of VideoNode.output for an AudioNode that isn't in the Cython side yet.\n\n    :param audio:       Audio to render.\n    :param outfile:     Render output BinaryIO handle.\n    :param header:      Kind of Wave header.\n                        WaveHeader.AUTO adds a Wave64 header if the audio\n\n                        * Has more than 2 channels\n                        * Has a bitdepth &gt; 16\n                        * Has more than 44100 samples\n\n    :param progress:    String to use for render progress display.\n                        If empty or ``None``, no progress display.\n    \"\"\"\n    if progress:\n        p = get_render_progress()\n        task = p.add_task(progress, total=audio.num_frames)\n        p.start()\n\n    bytes_per_output_sample = (audio.bits_per_sample + 7) // 8\n    block_align = audio.num_channels * bytes_per_output_sample\n    bytes_per_second = audio.sample_rate * block_align\n    data_size = audio.num_samples * block_align\n\n    if header == WaveHeader.AUTO:\n        conditions = (audio.num_channels &gt; 2, audio.bits_per_sample &gt; 16, audio.num_samples &gt; 44100)\n        header_func, use_w64 = (_w64_header, WaveHeader.WAVE64) if any(conditions) else (_wav_header, WaveHeader.WAVE)\n    else:\n        use_w64 = header\n        header_func = (_wav_header, _w64_header)[header]\n\n    outfile.write(header_func(audio, bytes_per_second, block_align, data_size))\n\n    for f in audio.frames(close=True):\n        if progress:\n            p.update(task, advance=1)\n        _finish_frame_audio(f, outfile, audio.bits_per_sample == 24)\n    size = outfile.tell()\n    if use_w64:\n        outfile.seek(16)\n        outfile.write(struct.pack(\"&lt;Q\", size))\n    else:\n        outfile.seek(4)\n        outfile.write(struct.pack(\"&lt;I\", size - 8))\n    if progress:\n        p.stop()\n</code></pre>"},{"location":"vs-muxtools/utils/src/","title":"src","text":""},{"location":"vs-muxtools/utils/src/#src","title":"src","text":"<p>Uses lsmas for previewing and bestsource otherwise. Still supports dgi files directly if dgdecodenv is installed to not break existing scripts.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <p>Path to video or dgi file</p> required <code>preview_sourcefilter</code> <code>SourceFilter | None</code> <p>Source filter to be used when previewing using vspreview. <code>None</code> will make it fall back to <code>sourcefilter</code>.</p> <code>AUTO</code> <code>sourcefilter</code> <code>SourceFilter</code> <p>Source filter to be used otherwise.</p> <code>BESTSOURCE</code> <code>kwargs</code> <code>KwargsT</code> <p>Other arguments you may or may not wanna pass to the indexer.</p> <code>{}</code> <p>Returns:</p> Type Description <code>VideoNode</code> <p>Video Node</p> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def src(\n    filePath: PathLike,\n    preview_sourcefilter: SourceFilter | None = SourceFilter.AUTO,\n    sourcefilter: SourceFilter = SourceFilter.BESTSOURCE,\n    **kwargs: KwargsT,\n) -&gt; vs.VideoNode:\n    \"\"\"\n    Uses lsmas for previewing and bestsource otherwise.\n    Still supports dgi files directly if dgdecodenv is installed to not break existing scripts.\n\n    :param filepath:                Path to video or dgi file\n    :param preview_sourcefilter:    Source filter to be used when previewing using vspreview.\n                                    `None` will make it fall back to `sourcefilter`.\n    :param sourcefilter:            Source filter to be used otherwise.\n    :param kwargs:                  Other arguments you may or may not wanna pass to the indexer.\n    :return:                        Video Node\n    \"\"\"\n    filePath = ensure_path_exists(filePath, src)\n    dgiFile = filePath.with_suffix(\".dgi\")\n    if filePath.suffix.lower() == \".dgi\" or dgiFile.exists():\n        if not hasattr(core, \"dgdecodenv\"):\n            raise error(\"Trying to use a dgi file without dgdecodenv installed.\", src)\n        return core.lazy.dgdecodenv.DGSource(str(filePath.resolve()) if not dgiFile.exists() else str(dgiFile.resolve()), **kwargs)\n\n    is_previewing = False\n    try:\n        from vspreview import is_preview\n\n        is_previewing = is_preview()\n    except:\n        debug(\"Could not check if we're currently previewing. Is vspreview installed?\", src)\n\n    force_lsmas = kwargs.pop(\"force_lsmas\", False)\n    if force_lsmas:\n        warn(\"force_lsmas is deprecated!\\nPlease switch to using the explicit sourcefilter params.\", src, 5)\n        preview_sourcefilter = None\n        sourcefilter = SourceFilter.LSMASH\n\n    force_bs = kwargs.pop(\"force_bs\", False)\n    if force_bs:\n        warn(\"force_bs is deprecated!\\nPlease switch to using the explicit sourcefilter params.\", src, 5)\n        preview_sourcefilter = None\n        sourcefilter = SourceFilter.BESTSOURCE\n\n    if preview_sourcefilter is SourceFilter.AUTO:\n        preview_sourcefilter = SourceFilter.LSMASH if \"m2ts\" in filePath.name.lower() else SourceFilter.FFMS2\n\n    if sourcefilter is SourceFilter.AUTO:\n        sourcefilter = SourceFilter.LSMASH if \"m2ts\" in filePath.name.lower() else SourceFilter.BESTSOURCE\n\n    if is_previewing and preview_sourcefilter is not None:\n        return _call_sourcefilter(filePath.resolve(), preview_sourcefilter, **kwargs)\n    else:\n        return _call_sourcefilter(filePath.resolve(), sourcefilter, **kwargs)\n</code></pre>"},{"location":"vs-muxtools/utils/src/#src_file","title":"src_file","text":"<p>               Bases: <code>vs_object</code></p> Source code in <code>           vsmuxtools/utils/source.py         </code> <pre><code>class src_file(vs_object):\n    file: Path | list[Path]\n    trim: Trim = None\n    preview_sourcefilter: SourceFilter | None\n    sourcefilter: SourceFilter\n    idx: Callable[[str], vs.VideoNode] | None = None\n    idx_args = {}\n\n    def __init__(\n        self,\n        file: PathLike | GlobSearch | Sequence[PathLike],\n        trim: Trim = None,\n        preview_sourcefilter: SourceFilter | None = SourceFilter.FFMS2,\n        sourcefilter: SourceFilter = SourceFilter.BESTSOURCE,\n        idx: Callable[[str], vs.VideoNode] | None = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Custom `FileInfo` kind of thing for convenience\n\n        :param file:                    Either a string based filepath or a Path object\n        :param trim:                    Can be a single trim or a sequence of trims.\n        :param preview_sourcefilter:    Source filter to be used when previewing using vspreview.\n                                        `None` will make it fall back to `sourcefilter`.\n        :param sourcefilter:            Source filter to be used otherwise.\n        :param idx:                     Custom indexer for the input file. Pass a function that takes a string in and returns a vs.VideoNode.\n        \"\"\"\n        if isinstance(file, Sequence) and not isinstance(file, str) and len(file) == 1:\n            file = file[0]\n\n        self.file = (\n            [ensure_path_exists(f, self) for f in file]\n            if isinstance(file, Sequence) and not isinstance(file, str)\n            else ensure_path_exists(file, self)\n        )\n        self.trim = trim\n        self.preview_sourcefilter = preview_sourcefilter\n        self.sourcefilter = sourcefilter\n        self.idx = idx\n        self.idx_args = kwargs\n\n    def __call_indexer(self, fileIn: Path):\n        if self.idx:\n            return self.idx(str(fileIn.resolve()))\n        else:\n            return src(fileIn, preview_sourcefilter=self.preview_sourcefilter, sourcefilter=self.sourcefilter, **self.idx_args)\n\n    def __index_clip(self):\n        if isinstance(self.file, list):\n            indexed = core.std.Splice([self.__call_indexer(f) for f in self.file])\n        else:\n            indexed = self.__call_indexer(self.file)\n        cut = indexed\n        if self.trim:\n            self.trim = list(self.trim)\n            if self.trim[0] is None:\n                self.trim[0] = 0\n            if self.trim[1] is None or self.trim[1] == 0:\n                if self.trim[0] &lt; 0:\n                    cut = (indexed[0] * abs(self.trim[0])) + indexed\n                else:\n                    cut = indexed[self.trim[0] :]\n            else:\n                if self.trim[0] &lt; 0:\n                    cut = (indexed[0] * abs(self.trim[0])) + indexed[: self.trim[1]]\n                else:\n                    cut = indexed[self.trim[0] : self.trim[1]]\n            self.trim = tuple(self.trim)\n\n        if not isinstance(self.file, list) and self.file.suffix.lower() == \".dgi\":\n            if self.file.with_suffix(\".m2ts\").exists():\n                self.file = self.file.with_suffix(\".m2ts\")\n            else:\n                self.file = parse_m2ts_path(self.file)\n\n        setattr(self, \"clip\", indexed)\n        setattr(self, \"clip_cut\", cut)\n\n    @property\n    def src(self) -&gt; vs.VideoNode:\n        if not hasattr(self, \"clip\"):\n            self.__index_clip()\n        return self.clip\n\n    @property\n    def src_cut(self) -&gt; vs.VideoNode:\n        if not hasattr(self, \"clip_cut\"):\n            self.__index_clip()\n        return self.clip_cut\n\n    def init(\n        self,\n        bits: int | None = None,\n        matrix: MatrixT | None = None,\n        transfer: TransferT | None = None,\n        primaries: PrimariesT | None = None,\n        chroma_location: ChromaLocationT | None = None,\n        color_range: ColorRangeT | None = None,\n        field_based: FieldBasedT | None = None,\n        strict: bool = False,\n        dither_type: DitherType = DitherType.AUTO,\n    ) -&gt; vs.VideoNode:\n        \"\"\"\n        Getter that calls `vstools.initialize_clip` on the src clip for convenience\n        \"\"\"\n        return initialize_clip(\n            self.src, bits, matrix, transfer, primaries, chroma_location, color_range, field_based, strict, dither_type, func=self.init\n        )\n\n    def init_cut(\n        self,\n        bits: int | None = None,\n        matrix: MatrixT | None = None,\n        transfer: TransferT | None = None,\n        primaries: PrimariesT | None = None,\n        chroma_location: ChromaLocationT | None = None,\n        color_range: ColorRangeT | None = None,\n        field_based: FieldBasedT | None = None,\n        strict: bool = False,\n        dither_type: DitherType = DitherType.AUTO,\n    ) -&gt; vs.VideoNode:\n        \"\"\"\n        Getter that calls `vstools.initialize_clip` on the src_cut clip for convenience\n        \"\"\"\n        return initialize_clip(\n            self.src_cut, bits, matrix, transfer, primaries, chroma_location, color_range, field_based, strict, dither_type, func=self.init_cut\n        )\n\n    def get_audio(self, track: int = 0, **kwargs) -&gt; vs.AudioNode:\n        \"\"\"\n        Indexes the specified audio track from the input file(s).\n        \"\"\"\n        file = self.file if isinstance(self.file, list) else [self.file]\n\n        nodes = list[vs.AudioNode]()\n        for f in file:\n            parsed = ParsedFile.from_file(f, self)\n            absolute = parsed.find_tracks(relative_id=track, type=TrackType.AUDIO, error_if_empty=True, caller=self)[0].index\n            nodes.append(core.bs.AudioSource(str(f.resolve()), absolute, **kwargs))\n\n        return nodes[0] if len(nodes) == 1 else core.std.AudioSplice(nodes)\n\n    def get_audio_trimmed(self, track: int = 0, **kwargs) -&gt; vs.AudioNode:\n        \"\"\"\n        Gets the indexed audio track with the trim specified in the src_file.\n        \"\"\"\n        node = self.get_audio(track, **kwargs)\n        if self.trim:\n            if self.trim[1] is None or self.trim[1] == 0:\n                node = node[f2s(self.trim[0], node, self.src) :]\n            else:\n                node = node[f2s(self.trim[0], node, self.src) : f2s(self.trim[1], node, self.src)]\n        return node\n\n    def __vs_del__(self, core_id: int) -&gt; None:\n        if not TYPE_CHECKING:\n            setattr(self, \"clip\", None)\n            setattr(self, \"clip_cut\", None)\n\n            for v in self.__dict__.values():\n                if not isinstance(v, MutableMapping):\n                    continue\n\n                for k2, v2 in v.items():\n                    if isinstance(v2, vs.VideoNode):\n                        v[k2] = None\n\n    @staticmethod\n    def BDMV(\n        root_dir: PathLike,\n        playlist: int = 0,\n        entries: int | list[int] | Trim | None = None,\n        angle: int = 0,\n        trim: Trim | None = None,\n        preview_sourcefilter: SourceFilter | None = SourceFilter.AUTO,\n        sourcefilter: SourceFilter = SourceFilter.BESTSOURCE,\n        idx: Callable[[str], vs.VideoNode] | None = None,\n        **kwargs: KwargsT,\n    ) -&gt; \"src_file\":\n        root_dir = ensure_path_exists(root_dir, \"BDMV\", True)\n        mpls = core.mpls.Read(str(root_dir), playlist, angle)\n        clips: list[str] = mpls[\"clip\"]\n        if entries is not None:\n            if isinstance(entries, int):\n                clips = clips[entries]\n            elif isinstance(entries, list):\n                entries = sanitize_trims(entries)\n            else:\n                if entries[0] is None and entries[1]:\n                    clips = clips[: entries[1]]\n                elif entries[1] is None:\n                    clips = clips[entries[0] :]\n                else:\n                    clips = clips[entries[0] : entries[1]]\n        return src_file(clips, trim, preview_sourcefilter, sourcefilter, idx, **kwargs)\n\n    @classproperty\n    def AUTO(self) -&gt; SourceFilter:\n        return SourceFilter.AUTO\n\n    @classproperty\n    def BESTSOURCE(self) -&gt; SourceFilter:\n        return SourceFilter.BESTSOURCE\n\n    @classproperty\n    def BS(self) -&gt; SourceFilter:\n        return SourceFilter.BESTSOURCE\n\n    @classproperty\n    def FFMS2(self) -&gt; SourceFilter:\n        return SourceFilter.FFMS2\n\n    @classproperty\n    def LSMASH(self) -&gt; SourceFilter:\n        return SourceFilter.LSMASH\n</code></pre>"},{"location":"vs-muxtools/utils/src/#vsmuxtools.utils.src_file.__init__","title":"<code>__init__(file, trim=None, preview_sourcefilter=SourceFilter.FFMS2, sourcefilter=SourceFilter.BESTSOURCE, idx=None, **kwargs)</code>","text":"<p>Custom <code>FileInfo</code> kind of thing for convenience</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike | GlobSearch | Sequence[PathLike]</code> <p>Either a string based filepath or a Path object</p> required <code>trim</code> <code>Trim</code> <p>Can be a single trim or a sequence of trims.</p> <code>None</code> <code>preview_sourcefilter</code> <code>SourceFilter | None</code> <p>Source filter to be used when previewing using vspreview. <code>None</code> will make it fall back to <code>sourcefilter</code>.</p> <code>FFMS2</code> <code>sourcefilter</code> <code>SourceFilter</code> <p>Source filter to be used otherwise.</p> <code>BESTSOURCE</code> <code>idx</code> <code>Callable[[str], VideoNode] | None</code> <p>Custom indexer for the input file. Pass a function that takes a string in and returns a vs.VideoNode.</p> <code>None</code> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def __init__(\n    self,\n    file: PathLike | GlobSearch | Sequence[PathLike],\n    trim: Trim = None,\n    preview_sourcefilter: SourceFilter | None = SourceFilter.FFMS2,\n    sourcefilter: SourceFilter = SourceFilter.BESTSOURCE,\n    idx: Callable[[str], vs.VideoNode] | None = None,\n    **kwargs,\n):\n    \"\"\"\n    Custom `FileInfo` kind of thing for convenience\n\n    :param file:                    Either a string based filepath or a Path object\n    :param trim:                    Can be a single trim or a sequence of trims.\n    :param preview_sourcefilter:    Source filter to be used when previewing using vspreview.\n                                    `None` will make it fall back to `sourcefilter`.\n    :param sourcefilter:            Source filter to be used otherwise.\n    :param idx:                     Custom indexer for the input file. Pass a function that takes a string in and returns a vs.VideoNode.\n    \"\"\"\n    if isinstance(file, Sequence) and not isinstance(file, str) and len(file) == 1:\n        file = file[0]\n\n    self.file = (\n        [ensure_path_exists(f, self) for f in file]\n        if isinstance(file, Sequence) and not isinstance(file, str)\n        else ensure_path_exists(file, self)\n    )\n    self.trim = trim\n    self.preview_sourcefilter = preview_sourcefilter\n    self.sourcefilter = sourcefilter\n    self.idx = idx\n    self.idx_args = kwargs\n</code></pre>"},{"location":"vs-muxtools/utils/src/#vsmuxtools.utils.src_file.get_audio","title":"<code>get_audio(track=0, **kwargs)</code>","text":"<p>Indexes the specified audio track from the input file(s).</p> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def get_audio(self, track: int = 0, **kwargs) -&gt; vs.AudioNode:\n    \"\"\"\n    Indexes the specified audio track from the input file(s).\n    \"\"\"\n    file = self.file if isinstance(self.file, list) else [self.file]\n\n    nodes = list[vs.AudioNode]()\n    for f in file:\n        parsed = ParsedFile.from_file(f, self)\n        absolute = parsed.find_tracks(relative_id=track, type=TrackType.AUDIO, error_if_empty=True, caller=self)[0].index\n        nodes.append(core.bs.AudioSource(str(f.resolve()), absolute, **kwargs))\n\n    return nodes[0] if len(nodes) == 1 else core.std.AudioSplice(nodes)\n</code></pre>"},{"location":"vs-muxtools/utils/src/#vsmuxtools.utils.src_file.get_audio_trimmed","title":"<code>get_audio_trimmed(track=0, **kwargs)</code>","text":"<p>Gets the indexed audio track with the trim specified in the src_file.</p> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def get_audio_trimmed(self, track: int = 0, **kwargs) -&gt; vs.AudioNode:\n    \"\"\"\n    Gets the indexed audio track with the trim specified in the src_file.\n    \"\"\"\n    node = self.get_audio(track, **kwargs)\n    if self.trim:\n        if self.trim[1] is None or self.trim[1] == 0:\n            node = node[f2s(self.trim[0], node, self.src) :]\n        else:\n            node = node[f2s(self.trim[0], node, self.src) : f2s(self.trim[1], node, self.src)]\n    return node\n</code></pre>"},{"location":"vs-muxtools/utils/src/#vsmuxtools.utils.src_file.init","title":"<code>init(bits=None, matrix=None, transfer=None, primaries=None, chroma_location=None, color_range=None, field_based=None, strict=False, dither_type=DitherType.AUTO)</code>","text":"<p>Getter that calls <code>vstools.initialize_clip</code> on the src clip for convenience</p> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def init(\n    self,\n    bits: int | None = None,\n    matrix: MatrixT | None = None,\n    transfer: TransferT | None = None,\n    primaries: PrimariesT | None = None,\n    chroma_location: ChromaLocationT | None = None,\n    color_range: ColorRangeT | None = None,\n    field_based: FieldBasedT | None = None,\n    strict: bool = False,\n    dither_type: DitherType = DitherType.AUTO,\n) -&gt; vs.VideoNode:\n    \"\"\"\n    Getter that calls `vstools.initialize_clip` on the src clip for convenience\n    \"\"\"\n    return initialize_clip(\n        self.src, bits, matrix, transfer, primaries, chroma_location, color_range, field_based, strict, dither_type, func=self.init\n    )\n</code></pre>"},{"location":"vs-muxtools/utils/src/#vsmuxtools.utils.src_file.init_cut","title":"<code>init_cut(bits=None, matrix=None, transfer=None, primaries=None, chroma_location=None, color_range=None, field_based=None, strict=False, dither_type=DitherType.AUTO)</code>","text":"<p>Getter that calls <code>vstools.initialize_clip</code> on the src_cut clip for convenience</p> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def init_cut(\n    self,\n    bits: int | None = None,\n    matrix: MatrixT | None = None,\n    transfer: TransferT | None = None,\n    primaries: PrimariesT | None = None,\n    chroma_location: ChromaLocationT | None = None,\n    color_range: ColorRangeT | None = None,\n    field_based: FieldBasedT | None = None,\n    strict: bool = False,\n    dither_type: DitherType = DitherType.AUTO,\n) -&gt; vs.VideoNode:\n    \"\"\"\n    Getter that calls `vstools.initialize_clip` on the src_cut clip for convenience\n    \"\"\"\n    return initialize_clip(\n        self.src_cut, bits, matrix, transfer, primaries, chroma_location, color_range, field_based, strict, dither_type, func=self.init_cut\n    )\n</code></pre>"},{"location":"vs-muxtools/utils/src/#src_file-alias","title":"SRC_FILE (alias)","text":""},{"location":"vs-muxtools/utils/src/#fileinfo-alias","title":"FileInfo (alias)","text":"<p>Converts a frame number to a sample number</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>The frame number</p> required <code>sample_rate</code> <code>AudioNode | int</code> <p>Can be a flat number like 48000 (=48 kHz) or an AudioNode to get the sample rate from</p> <code>48000</code> <code>fps</code> <code>VideoNode | Fraction</code> <p>Can be a Fraction or a VideoNode to get the fps from</p> <code>Fraction(24000, 1001)</code> <p>Returns:</p> Type Description <code>int</code> <p>The sample number</p> Source code in <code>         vsmuxtools/utils/source.py       </code> <pre><code>def frames_to_samples(frame: int, sample_rate: vs.AudioNode | int = 48000, fps: vs.VideoNode | Fraction = Fraction(24000, 1001)) -&gt; int:\n    \"\"\"\n    Converts a frame number to a sample number\n\n    :param frame:           The frame number\n    :param sample_rate:     Can be a flat number like 48000 (=48 kHz) or an AudioNode to get the sample rate from\n    :param fps:             Can be a Fraction or a VideoNode to get the fps from\n\n    :return:                The sample number\n    \"\"\"\n    if frame == 0:\n        return 0\n    sample_rate = sample_rate.sample_rate if isinstance(sample_rate, vs.AudioNode) else sample_rate\n    fps = Fraction(fps.fps_num, fps.fps_den) if isinstance(fps, vs.VideoNode) else fps\n    return int(sample_rate * (fps.denominator / fps.numerator) * frame)\n</code></pre>"},{"location":"vs-muxtools/video/settings/","title":"settings","text":""},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.__all__","title":"<code>__all__ = ['settings_builder_x265', 'settings_builder_x264', 'sb', 'sb265', 'sb264']</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.sb","title":"<code>sb = settings_builder_x265</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.sb264","title":"<code>sb264 = settings_builder_x264</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.sb265","title":"<code>sb265 = sb</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.file_or_default","title":"<code>file_or_default</code>","text":"Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def file_or_default(file: PathLike, default: str, no_warn: bool = False) -&gt; tuple[str | list[str], bool]:\n    if isinstance(file, list):\n        return file, False\n    if os.path.isfile(file):\n        file = ensure_path(file, None)\n        if file.exists():\n            with open(file, \"r\") as r:\n                settings = str(r.read())\n                settings = settings.replace(\"\\n\", \" \")\n                settings = re.sub(r\"(?:-o|--output) {clip.+?}\", \"\", settings, flags=re.I).strip()\n                return settings, True\n\n    if not no_warn:\n        warn(\"Settings file wasn't found. Using default.\", None, 3)\n    return default, False\n</code></pre>"},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.is_full_zone","title":"<code>is_full_zone</code>","text":"Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def is_full_zone(zone: Zone) -&gt; bool:\n    if isinstance(zone[2], str):\n        if len(zone) &lt; 4:\n            raise error(f\"Zone '{zone}' is invalid.\")\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.norm_zones","title":"<code>norm_zones</code>","text":"<p>Normalize zones to be within the clip's range.</p> <p>Parameters:</p> Name Type Description Default <code>clip_or_max_frames</code> <code>VideoNode | int</code> <p>The clip or a max frame count to normalize to.</p> required <code>zones</code> <code>Zone | list[Zone] | None</code> <p>The zones to normalize.</p> required <p>Returns:</p> Type Description <code>list[Zone]</code> <p>The normalized zones.</p> Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def norm_zones(clip_or_max_frames: vs.VideoNode | int, zones: Zone | list[Zone] | None) -&gt; list[Zone]:\n    \"\"\"\n    Normalize zones to be within the clip's range.\n\n    :param clip_or_max_frames:      The clip or a max frame count to normalize to.\n    :param zones:                   The zones to normalize.\n\n    :return:                        The normalized zones.\n    \"\"\"\n\n    if not zones:\n        return []\n\n    max_frames = clip_or_max_frames if isinstance(clip_or_max_frames, int) else clip_or_max_frames.num_frames\n\n    if not isinstance(zones, list):\n        zones = [zones]\n\n    newzones = list[Zone]()\n\n    for zone in zones:\n        start, end, *params = zone\n\n        if start is None:\n            start = 0\n        elif isinstance(start, int) and start &lt; 0:\n            start = max_frames - abs(start)\n\n        if end is None:\n            end = max_frames - 1\n        elif isinstance(end, int) and end &lt; 0:\n            end = max_frames - abs(end)\n\n        if start &gt; end:\n            raise CustomValueError(f\"Zone '{zone}' start frame is after end frame!\", norm_zones, f\"{start} &gt; {end}\")\n\n        newzones.append(cast(Zone, (start, min(end, max_frames - 1), *params)))  # type:ignore[type-var]\n\n    return newzones\n</code></pre>"},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.settings_builder_x264","title":"<code>settings_builder_x264</code>","text":"Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def settings_builder_x264(\n    preset: str = \"placebo\",\n    crf: float = 13,\n    qcomp: float = 0.7,\n    psy_rd: float = 1.0,\n    psy_trellis: float = 0.0,\n    trellis: int | None = None,\n    aq_strength: float = 0.8,\n    aq_mode: int = 3,\n    ref: int = 16,\n    bframes: int = 16,\n    mbtree: bool = False,\n    rc_lookahead: int = 250,\n    me: str = \"umh\",\n    subme: int = 11,\n    threads: int = 6,\n    merange: int = 32,\n    deblock: list[int] | str = [-1, -1],\n    dct_decimate: bool = False,\n    append: str = \"\",\n    **kwargs,\n) -&gt; str:\n    # Simple insert values\n    settings = f\" --preset {preset} --crf {crf} --bframes {bframes} --ref {ref} --rc-lookahead {rc_lookahead} --me {me} --merange {merange}\"\n    settings += f\" --aq-mode {aq_mode} --aq-strength {aq_strength} --qcomp {qcomp}\"\n    settings += f\" --psy-rd {psy_rd}:{psy_trellis} --subme {subme} --threads {threads}\"\n    if trellis is not None:\n        settings += f\" --trellis {trellis}\"\n\n    # Less simple\n    settings += f\" {'--no-mbtree' if not mbtree else ''} {'--no-dct-decimate' if not dct_decimate else ''}\"\n\n    if isinstance(deblock, list):\n        deblock = f\"{str(deblock[0])}:{str(deblock[1])}\"\n    settings += f\" --deblock={deblock}\"\n\n    for k, v in kwargs.items():\n        prefix = \"--\"\n        if k.startswith(\"_\"):\n            prefix = \"-\"\n            k = k[1:]\n        settings += f\" {prefix}{k.replace('_', '-')} {v}\"\n\n    settings += (\" \" + append.strip()) if append.strip() else \"\"\n    return settings\n</code></pre>"},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.settings_builder_x265","title":"<code>settings_builder_x265</code>","text":"Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def settings_builder_x265(\n    preset: str | int = \"slower\",\n    crf: float = 14.0,\n    qcomp: float = 0.75,\n    psy_rd: float = 2.0,\n    psy_rdoq: float = 2.0,\n    aq_strength: float = 0.75,\n    aq_mode: int = 3,\n    rd: int = 4,\n    rect: bool = True,\n    amp: bool = False,\n    chroma_qpoffsets: int = -2,\n    tu_intra_depth: int = 2,\n    tu_inter_depth: int = 2,\n    rskip: bool | int = 0,\n    tskip: bool = False,\n    ref: int = 4,\n    bframes: int = 16,\n    cutree: bool = False,\n    rc_lookahead: int = 60,\n    subme: int = 5,\n    me: int = 3,\n    b_intra: bool = True,\n    weightb: bool = True,\n    deblock: list[int] | str = [-2, -2],\n    append: str = \"\",\n    **kwargs,\n) -&gt; str:\n    # Simple insert values\n    settings = f\" --preset {preset} --crf {crf} --bframes {bframes} --ref {ref} --rc-lookahead {rc_lookahead} --subme {subme} --me {me}\"\n    settings += f\" --aq-mode {aq_mode} --aq-strength {aq_strength} --qcomp {qcomp} --cbqpoffs {chroma_qpoffsets} --crqpoffs {chroma_qpoffsets}\"\n    settings += f\" --rd {rd} --psy-rd {psy_rd} --psy-rdoq {psy_rdoq} --tu-intra-depth {tu_intra_depth} --tu-inter-depth {tu_inter_depth}\"\n\n    # Less simple\n    settings += f\" --{'rect' if rect else 'no-rect'} --{'amp' if amp else 'no-amp'} --{'tskip' if tskip else 'no-tskip'}\"\n    settings += f\" --{'b-intra' if b_intra else 'no-b-intra'} --{'weightb' if weightb else 'no-weightb'} --{'cutree' if cutree else 'no-cutree'}\"\n    settings += f\" --rskip {int(rskip) if isinstance(rskip, bool) else rskip}\"\n\n    if isinstance(deblock, list):\n        deblock = f\"{str(deblock[0])}:{str(deblock[1])}\"\n    settings += f\" --deblock={deblock}\"\n\n    # Don't need to change these lol\n    settings += \" --no-sao --no-sao-non-deblock --no-strong-intra-smoothing --no-open-gop\"\n\n    for k, v in kwargs.items():\n        prefix = \"--\"\n        if k.startswith(\"_\"):\n            prefix = \"-\"\n            k = k[1:]\n        settings += f\" {prefix}{k.replace('_', '-')} {v}\"\n\n    settings += (\" \" + append.strip()) if append.strip() else \"\"\n    return settings\n</code></pre>"},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.shift_zones","title":"<code>shift_zones</code>","text":"Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def shift_zones(zones: Zone | list[Zone] | None, start_frame: int = 0) -&gt; list[Zone] | None:\n    if not zones:\n        return None\n    if not isinstance(zones, list):\n        zones = [zones]\n\n    newzones = list[Zone]()\n\n    for zone in zones:\n        zone = list(zone)\n        zone[0] = zone[0] - start_frame\n        zone[1] = zone[1] - start_frame\n        if zone[1] &lt; 0:\n            continue\n        if zone[0] &lt; 0:\n            zone[0] = 0\n        zone = tuple(zone)\n        newzones.append(zone)\n\n    return newzones\n</code></pre>"},{"location":"vs-muxtools/video/settings/#vsmuxtools.video.settings.zones_to_args","title":"<code>zones_to_args</code>","text":"Source code in <code>         vsmuxtools/video/settings.py       </code> <pre><code>def zones_to_args(zones: Zone | list[Zone] | None, x265: bool) -&gt; list[str]:\n    args: list[str] = []\n    if not zones:\n        return args\n    if not isinstance(zones, list):\n        zones = [zones]\n    zones_settings: str = \"\"\n    for i, zone in enumerate(zones):\n        if is_full_zone(zone):\n            if x265 and zone[2].lower() not in [\"q\", \"b\"]:\n                raise error(f\"Zone '{zone}' is invalid for x265. Please only use b or q.\")\n            zones_settings += f\"{zone[0]},{zone[1]},{zone[2]}={zone[3]}\"\n        else:\n            zones_settings += f\"{zone[0]},{zone[1]},b={zone[2]}\"\n        if i != len(zones) - 1:\n            zones_settings += \"/\"\n    args.extend([\"--zones\", zones_settings])\n    return args\n</code></pre>"},{"location":"vs-muxtools/video/testing/","title":"testing","text":""},{"location":"vs-muxtools/video/testing/#vsmuxtools.video.testing.SettingsTester","title":"<code>SettingsTester</code>","text":"<p>A utility class for making test encodes. This can automatically parse strings like</p> <p><code>--preset veryfast --crf [14/15/0.5]</code> and will then run encodes with CRF 14, 14.5 and 15.</p> <p>The same works with non stepping options like</p> <p><code>--preset [fast,veryfast,slow,slower]</code> or <code>--sao [true,false]</code> (can also use yes/no and y/n for these)</p> <p>Keep in mind that this will create an encode for EVERY combination and not some order.</p> <p><code>--preset [fast,veryfast,ultrafast] --crf [14/15/0.5]</code> For example will end up with 9 encodes.</p> Source code in <code>           vsmuxtools/video/testing.py         </code> <pre><code>class SettingsTester:\n    \"\"\"\n    A utility class for making test encodes.\n    This can automatically parse strings like\n\n    `--preset veryfast --crf [14/15/0.5]`\n    and will then run encodes with CRF 14, 14.5 and 15.\n\n\n    The same works with non stepping options like\n\n    `--preset [fast,veryfast,slow,slower]`\n    or\n    `--sao [true,false]` (can also use yes/no and y/n for these)\n\n\n    Keep in mind that this will create an encode for EVERY combination and not some order.\n\n    `--preset [fast,veryfast,ultrafast] --crf [14/15/0.5]`\n    For example will end up with 9 encodes.\n    \"\"\"\n\n    encoder: VideoEncoder\n    encodes = list[tuple[str | None, str]]()\n    qp_file: str | None = None\n\n    def __init__(self, settings: str | list[str], encoder: VideoEncoder | None = None, qp_clip: SRC_FILE | vs.VideoNode | None = None) -&gt; None:\n        if not encoder:\n            self.encoder = x265(\"--kek\")\n        else:\n            self.encoder = encoder\n\n        if isinstance(self.encoder, SupportsQP) and qp_clip:\n            self.encoder.qp_clip = qp_clip\n            self.qp_file = self.encoder._get_qpfile()\n\n        if isinstance(settings, str):\n            self.encodes = generate_settings(settings)\n        else:\n            self.encodes = [(None, s) for s in settings]\n\n    def run(self, clip: vs.VideoNode, output_clips: bool = True) -&gt; None:\n        \"\"\"\n        Runs all encodes with the settings specified/generated.\n\n        :param output_clips:        Will index and output clips with proper naming if vspreview is installed.\n                                    This might obviously end up using quite a lot of ram.\n        \"\"\"\n        for encode in self.encodes:\n            encoder = self.encoder.__class__(settings=encode[1])\n            encoder.resumable = False\n            if isinstance(self.encoder, SupportsQP) and self.qp_file:\n                encoder.qp_file = self.qp_file\n\n            out = make_output(\"encode\", \"test\", suffix=\"\" if not encode[0] else f\"[{encode[0]}]\")\n\n            f = encoder.encode(clip, out)\n            if output_clips:\n                done = src(f.file, True)\n                try:\n                    from vspreview import set_output\n\n                    set_output(done, name=encode[0], cache=False)\n                except:\n                    done.set_output(len(vs.get_outputs()))\n</code></pre>"},{"location":"vs-muxtools/video/testing/#vsmuxtools.video.testing.SettingsTester.run","title":"<code>run(clip, output_clips=True)</code>","text":"<p>Runs all encodes with the settings specified/generated.</p> <p>Parameters:</p> Name Type Description Default <code>output_clips</code> <code>bool</code> <p>Will index and output clips with proper naming if vspreview is installed. This might obviously end up using quite a lot of ram.</p> <code>True</code> Source code in <code>         vsmuxtools/video/testing.py       </code> <pre><code>def run(self, clip: vs.VideoNode, output_clips: bool = True) -&gt; None:\n    \"\"\"\n    Runs all encodes with the settings specified/generated.\n\n    :param output_clips:        Will index and output clips with proper naming if vspreview is installed.\n                                This might obviously end up using quite a lot of ram.\n    \"\"\"\n    for encode in self.encodes:\n        encoder = self.encoder.__class__(settings=encode[1])\n        encoder.resumable = False\n        if isinstance(self.encoder, SupportsQP) and self.qp_file:\n            encoder.qp_file = self.qp_file\n\n        out = make_output(\"encode\", \"test\", suffix=\"\" if not encode[0] else f\"[{encode[0]}]\")\n\n        f = encoder.encode(clip, out)\n        if output_clips:\n            done = src(f.file, True)\n            try:\n                from vspreview import set_output\n\n                set_output(done, name=encode[0], cache=False)\n            except:\n                done.set_output(len(vs.get_outputs()))\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/","title":"base","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.__all__","title":"<code>__all__ = ['VideoEncoder', 'FFMpegEncoder', 'SupportsQP']</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.VideoEncoder","title":"<code>VideoEncoder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>CLIKwargs</code>, <code>ABC</code></p> Source code in <code>           vsmuxtools/video/encoders/base.py         </code> <pre><code>@dataclass\nclass VideoEncoder(CLIKwargs, ABC):\n    resumable = False\n\n    @abstractmethod\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        \"\"\"\n        To actually run the encode.\n\n        :param clip:            Your videonode\n        :param outfile:         Can be a custom output file or directory.\n                                The correct extension will automatically be appended.\n\n        Returns a VideoFile object.\n        If you're only interested in the path you can just do `VideoFile.file`.\n        \"\"\"\n        ...\n\n    def _update_progress(self, current_frame, total_frames):\n        print(f\"\\rVapoursynth: {current_frame} / {total_frames} ({100 * current_frame // total_frames}%) || Encoder: \", end=\"\")\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.VideoEncoder.resumable","title":"<code>resumable = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.VideoEncoder.__init__","title":"<code>__init__</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.VideoEncoder.encode","title":"<code>encode</code>  <code>abstractmethod</code>","text":"<p>To actually run the encode.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>VideoNode</code> <p>Your videonode</p> required <code>outfile</code> <code>PathLike | None</code> <p>Can be a custom output file or directory. The correct extension will automatically be appended.  Returns a VideoFile object. If you're only interested in the path you can just do <code>VideoFile.file</code>.</p> <code>None</code> Source code in <code>         vsmuxtools/video/encoders/base.py       </code> <pre><code>@abstractmethod\ndef encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n    \"\"\"\n    To actually run the encode.\n\n    :param clip:            Your videonode\n    :param outfile:         Can be a custom output file or directory.\n                            The correct extension will automatically be appended.\n\n    Returns a VideoFile object.\n    If you're only interested in the path you can just do `VideoFile.file`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.FFMpegEncoder","title":"<code>FFMpegEncoder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code>, <code>ABC</code></p> Source code in <code>           vsmuxtools/video/encoders/base.py         </code> <pre><code>@dataclass\nclass FFMpegEncoder(VideoEncoder, ABC):\n    def __post_init__(self):\n        self.executable = get_executable(\"ffmpeg\")\n\n    def _default_args(self) -&gt; list[str]:\n        return [self.executable, \"-v\", \"quiet\", \"-stats\"]\n\n    def _pixfmt_for_clip(self, clip: vs.VideoNode) -&gt; str:\n        videoformat = get_video_format(clip)\n        if videoformat.color_family != vs.YUV:\n            raise error(\"Only YUV input allowed for FFMPEG pipes/encoders!\", self)\n\n        allowed_depths = range(8, 18, 2)\n        if videoformat.bits_per_sample not in allowed_depths:\n            raise error(f\"Only the following bitdepths are allowed: {', '.join([str(x) for x in allowed_depths])}\", self)\n\n        formatname = videoformat.name.replace(\"P8\", \"P\").lower()\n        return formatname + \"le\" if videoformat.bits_per_sample &gt; 8 else formatname\n\n    def input_args(self, clip: vs.VideoNode) -&gt; tuple[list[str], list[str]]:\n        props = props_dict(clip, True)\n        # fmt: off\n        prop_args = [\n            \"-r\", f\"{props.get('fps_num')}/{props.get('fps_den')}\",\n            \"-color_range\", props.get(\"range\"),\n            \"-colorspace\", props.get(\"colormatrix\"),\n            \"-color_primaries\", props.get(\"primaries\"),\n            \"-color_trc\", props.get(\"transfer\"),\n            \"-chroma_sample_location\", props.get(\"chromaloc\"),\n        ]\n        input_arguments = prop_args + [\"-f\", \"yuv4mpegpipe\", \"-i\", \"-\"] + [\"-pix_fmt\", self._pixfmt_for_clip(clip)]\n        return input_arguments, prop_args\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.FFMpegEncoder.__init__","title":"<code>__init__</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.FFMpegEncoder.__post_init__","title":"<code>__post_init__</code>","text":"Source code in <code>         vsmuxtools/video/encoders/base.py       </code> <pre><code>def __post_init__(self):\n    self.executable = get_executable(\"ffmpeg\")\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.FFMpegEncoder.input_args","title":"<code>input_args</code>","text":"Source code in <code>         vsmuxtools/video/encoders/base.py       </code> <pre><code>def input_args(self, clip: vs.VideoNode) -&gt; tuple[list[str], list[str]]:\n    props = props_dict(clip, True)\n    # fmt: off\n    prop_args = [\n        \"-r\", f\"{props.get('fps_num')}/{props.get('fps_den')}\",\n        \"-color_range\", props.get(\"range\"),\n        \"-colorspace\", props.get(\"colormatrix\"),\n        \"-color_primaries\", props.get(\"primaries\"),\n        \"-color_trc\", props.get(\"transfer\"),\n        \"-chroma_sample_location\", props.get(\"chromaloc\"),\n    ]\n    input_arguments = prop_args + [\"-f\", \"yuv4mpegpipe\", \"-i\", \"-\"] + [\"-pix_fmt\", self._pixfmt_for_clip(clip)]\n    return input_arguments, prop_args\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP","title":"<code>SupportsQP</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code></p> Source code in <code>           vsmuxtools/video/encoders/base.py         </code> <pre><code>@dataclass\nclass SupportsQP(VideoEncoder):\n    settings: str | PathLike | None = None\n    zones: Zone | list[Zone] | None = None\n    qp_file: PathLike | bool | None = None\n    qp_clip: src_file | vs.VideoNode | None = None\n    add_props: bool | None = None\n    sar: str | None = None\n    quiet_merging: bool = True\n    x265 = True\n\n    def _get_qpfile(self, start_frame: int = 0) -&gt; str:\n        if not self.qp_file and not self.qp_clip:\n            return \"\"\n\n        if not isinstance(self.qp_file, bool) and self.qp_file is not None:\n            return str(ensure_path_exists(self.qp_file, self).resolve())\n\n        if self.qp_clip:\n            if isinstance(self.qp_clip, src_file):\n                self.qp_clip = self.qp_clip.src_cut\n            return generate_qp_file(self.qp_clip, start_frame)\n\n    def _init_settings(self, x265: bool):\n        if not self.settings:\n            s, p = file_or_default(f\"{'x265' if x265 else 'x264'}_settings\", sb265() if x265 else sb264())\n            self.was_file = p\n            self.settings = s\n        else:\n            s, p = file_or_default(self.settings, self.settings, True)\n            self.was_file = p\n            self.settings = s\n\n        if self.add_props is None:\n            self.add_props = not getattr(self, \"was_file\", False)\n\n    def _update_settings(self, clip: vs.VideoNode, x265: bool):\n        if self.was_file:\n            self.settings = fill_props(self.settings, clip, x265, self.sar)\n\n        self.settings = self.settings if isinstance(self.settings, list) else shlex.split(self.settings)\n\n        if self.add_props:\n            self.settings.extend(props_args(clip, x265, self.sar))\n\n    @abstractmethod\n    def _encode_clip(self, clip: vs.VideoNode, out: Path) -&gt; Path: ...\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        if clip.format.bits_per_sample &gt; (12 if self.x265 else 10):\n            warn(f\"This encoder does not support a bit depth over {(12 if self.x265 else 10)}.\\nClip will be dithered to 10 bit.\", self, 2)\n            clip = finalize_clip(clip, 10)\n        self._update_settings(clip, self.x265)\n        out = make_output(\n            Path(self.qp_clip.file).stem if isinstance(self.qp_clip, src_file) else \"encoded\",\n            \"265\" if self.x265 else \"264\",\n            \"encoded\" if isinstance(self.qp_clip, src_file) else \"\",\n            outfile,\n        )\n        if not self.resumable:\n            return VideoFile(self._encode_clip(clip, out, self._get_qpfile()))\n\n        pattern = out.with_stem(out.stem + \"_part_???\")\n        parts = sorted(pattern.parent.glob(pattern.name))\n        info(f\"Found {len(parts)} part{'s' if len(parts) != 1 else ''} for this encode\")\n\n        keyframes = list[int]()\n        for i, p in enumerate(parts):\n            try:\n                info(f\"Parsing keyframes for part {i}...\")\n                kf = parse_keyframes(p)[-1]\n                if kf == 0:\n                    del parts[-1]\n                else:\n                    keyframes.append(kf)\n            except:\n                del parts[-1]\n        fout = out.with_stem(out.stem + f\"_part_{len(parts):03.0f}\")\n        start_frame = sum(keyframes)\n        info(f\"Starting encode at frame {start_frame}\")\n\n        # TODO: Normalize and adjust existing zones to the new start frame\n\n        clip = clip[start_frame:]\n        self._encode_clip(clip, fout, self._get_qpfile(start_frame), start_frame)\n\n        info(\"Remuxing and merging parts...\")\n        merge_parts(fout, out, keyframes, parts, self.quiet_merging)\n        return VideoFile(out, source=self.qp_clip.file if isinstance(self.qp_clip, src_file) else None)\n</code></pre>"},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.settings","title":"<code>settings = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.zones","title":"<code>zones = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.qp_file","title":"<code>qp_file = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.qp_clip","title":"<code>qp_clip = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.add_props","title":"<code>add_props = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.sar","title":"<code>sar = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.quiet_merging","title":"<code>quiet_merging = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.x265","title":"<code>x265 = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.__init__","title":"<code>__init__</code>","text":""},{"location":"vs-muxtools/video/encoders/base/#vsmuxtools.video.encoders.base.SupportsQP.encode","title":"<code>encode</code>","text":"Source code in <code>         vsmuxtools/video/encoders/base.py       </code> <pre><code>def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n    if clip.format.bits_per_sample &gt; (12 if self.x265 else 10):\n        warn(f\"This encoder does not support a bit depth over {(12 if self.x265 else 10)}.\\nClip will be dithered to 10 bit.\", self, 2)\n        clip = finalize_clip(clip, 10)\n    self._update_settings(clip, self.x265)\n    out = make_output(\n        Path(self.qp_clip.file).stem if isinstance(self.qp_clip, src_file) else \"encoded\",\n        \"265\" if self.x265 else \"264\",\n        \"encoded\" if isinstance(self.qp_clip, src_file) else \"\",\n        outfile,\n    )\n    if not self.resumable:\n        return VideoFile(self._encode_clip(clip, out, self._get_qpfile()))\n\n    pattern = out.with_stem(out.stem + \"_part_???\")\n    parts = sorted(pattern.parent.glob(pattern.name))\n    info(f\"Found {len(parts)} part{'s' if len(parts) != 1 else ''} for this encode\")\n\n    keyframes = list[int]()\n    for i, p in enumerate(parts):\n        try:\n            info(f\"Parsing keyframes for part {i}...\")\n            kf = parse_keyframes(p)[-1]\n            if kf == 0:\n                del parts[-1]\n            else:\n                keyframes.append(kf)\n        except:\n            del parts[-1]\n    fout = out.with_stem(out.stem + f\"_part_{len(parts):03.0f}\")\n    start_frame = sum(keyframes)\n    info(f\"Starting encode at frame {start_frame}\")\n\n    # TODO: Normalize and adjust existing zones to the new start frame\n\n    clip = clip[start_frame:]\n    self._encode_clip(clip, fout, self._get_qpfile(start_frame), start_frame)\n\n    info(\"Remuxing and merging parts...\")\n    merge_parts(fout, out, keyframes, parts, self.quiet_merging)\n    return VideoFile(out, source=self.qp_clip.file if isinstance(self.qp_clip, src_file) else None)\n</code></pre>"},{"location":"vs-muxtools/video/encoders/ffmpeg/","title":"ffmpeg","text":""},{"location":"vs-muxtools/video/encoders/ffmpeg/#vsmuxtools.video.encoders.ffmpeg.FFV1","title":"<code>FFV1</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FFMpegEncoder</code></p> <p>Uses ffmpeg to encode a clip to a lossless ffv1 stream.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <p>Can either be a string of your own settings or any of the 3 presets.</p> required Source code in <code>           vsmuxtools/video/encoders/ffmpeg.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass FFV1(FFMpegEncoder):\n    \"\"\"\n    Uses ffmpeg to encode a clip to a lossless ffv1 stream.\n\n    :param settings:        Can either be a string of your own settings or any of the 3 presets.\n    \"\"\"\n\n    settings: str | LosslessPreset = LosslessPreset.MIDDLEGROUND\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        bits = get_video_format(clip).bits_per_sample\n        if bits &gt; 10:\n            warn(f\"You are encoding FFV1 with {bits} bits. It will be massive.\", self, 1)\n        _base = \"-coder 1 -context 0 -g 1 -level 3 -threads 0\"\n        match self.settings:\n            case LosslessPreset.SPEED:\n                self.settings = _base + \" -slices 30 -slicecrc 0\"\n            case LosslessPreset.COMPRESSION:\n                self.settings = _base + \" -slices 16 -slicecrc 1\"\n            case LosslessPreset.MIDDLEGROUND:\n                self.settings = _base + \" -slices 24 -slicecrc 1\"\n            case _:\n                self.settings = self.settings\n\n        out = make_output(\"encoded_ffv1\", \"mkv\", user_passed=outfile)\n\n        input_args, prop_args = self.input_args(clip)\n        args = self._default_args() + input_args + [\"-c:v\", \"ffv1\"] + prop_args + self.get_custom_args()\n        if self.settings:\n            args.extend(shlex.split(self.settings))\n        args.append(str(out))\n\n        process = subprocess.Popen(args, stdin=subprocess.PIPE)\n        self.update_process_affinity(process.pid)\n        clip.output(process.stdin, y4m=True)\n        process.communicate()\n\n        enc_settings = self.get_mediainfo_settings(shlex.split(self.settings) + self.get_custom_args(), False)\n        return VideoFile(out, tags=dict(ENCODER=\"ffmpeg FFV1\", ENCODER_SETTINGS=enc_settings))\n</code></pre>"},{"location":"vs-muxtools/video/encoders/ffmpeg/#vsmuxtools.video.encoders.ffmpeg.ProRes","title":"<code>ProRes</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FFMpegEncoder</code></p> <p>Uses ffmpeg's prores-ks encoder to encode a clip to a ProRes stream.</p> <p>Documentation for params and additional options can be viewed at: https://ffmpeg.org/ffmpeg-codecs.html#Private-Options-for-prores_002dks</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <p>The encoder profile. Basically Quality settings. Chooses the Standard/Default profile for 422 and the '4444' profile for 444 clips if None.</p> required Source code in <code>           vsmuxtools/video/encoders/ffmpeg.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass ProRes(FFMpegEncoder):\n    \"\"\"\n    Uses ffmpeg's prores-ks encoder to encode a clip to a ProRes stream.\\n\n    Documentation for params and additional options can be viewed at: https://ffmpeg.org/ffmpeg-codecs.html#Private-Options-for-prores_002dks\n\n\n    :param profile:         The encoder profile. Basically Quality settings.\n                            Chooses the Standard/Default profile for 422 and the '4444' profile for 444 clips if None.\n    \"\"\"\n\n    profile: ProResProfile | int | None = None\n\n    def __post_init__(self):\n        if isinstance(self.profile, int) and self.profile not in ProResProfile.__members__.values():\n            raise error(f\"{self.profile} is not a valid ProRes profile!\", self)\n        super().__post_init__()\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        clipf = get_video_format(clip)\n        if clipf.subsampling_h != 0:\n            raise error(\"ProRes only supports 422 and 444 subsampling clips.\", self)\n        if clipf.bits_per_sample &gt; 12:\n            raise error(\"ProRes only supports bitdepths at or below 12.\", self)\n\n        profile = self.profile\n        if profile is None:\n            profile = ProResProfile.DEFAULT if clipf.subsampling_w == 1 else ProResProfile.P4444\n\n        if profile in range(0, 4) and clipf.subsampling_w != 1:\n            raise error(f\"Profile '{ProResProfile(profile).name}' only supports 422.\", self)\n\n        if profile in range(4, 5) and clipf.subsampling_w != 0:\n            raise error(f\"Profile '{ProResProfile(profile).name}' only supports 444.\", self)\n\n        out = make_output(\"prores\", \"mkv\", user_passed=outfile)\n        input_args, prop_args = self.input_args(clip)\n        args = self._default_args() + input_args + [\"-c:v\", \"prores_ks\"] + prop_args + self.get_custom_args() + [\"-profile\", str(profile)]\n        args.append(str(out))\n\n        process = subprocess.Popen(args, stdin=subprocess.PIPE)\n        self.update_process_affinity(process.pid)\n        clip.output(process.stdin, y4m=True)\n        process.communicate()\n        enc_settings = self.get_mediainfo_settings([\"-profile\", str(profile)] + self.get_custom_args(), False)\n        return VideoFile(out, tags=dict(ENCODER=\"ffmpeg prores_ks\", ENCODER_SETTINGS=enc_settings))\n</code></pre>"},{"location":"vs-muxtools/video/encoders/intermediary/","title":"intermediary","text":""},{"location":"vs-muxtools/video/encoders/intermediary/#vsmuxtools.video.encoders.intermediary.IntermediaryEncoder","title":"<code>IntermediaryEncoder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code></p> <p>Encoder that will create an intermediary first and then encode that intermediary to the target encoders.</p> <p>Parameters:</p> Name Type Description Default <code>encoder</code> <p>The intermediary encoder. Might recommend prores or ffv1.</p> required <code>target_encoders</code> <p>Target encoders to use. You can also pass a tuple with a function to call on the clips before running. For example: (x265(), lambda clip: clip.nlm_cuda.NLMeans(h=2.0))</p> required <code>indexer</code> <p>Here you can pass a custom indexing function ala FileInfo. Uses vsmuxtools.src otherwise.</p> required Source code in <code>           vsmuxtools/video/encoders/intermediary.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass IntermediaryEncoder(VideoEncoder):\n    \"\"\"\n    Encoder that will create an intermediary first and then encode that intermediary to the target encoders.\n\n    :param encoder:             The intermediary encoder. Might recommend prores or ffv1.\n\n    :param target_encoders:     Target encoders to use. You can also pass a tuple with a function to call on the clips before running.\n                                For example: (x265(), lambda clip: clip.nlm_cuda.NLMeans(h=2.0))\n\n    :param indexer:             Here you can pass a custom indexing function ala FileInfo. Uses vsmuxtools.src otherwise.\n    \"\"\"\n\n    encoder: VideoEncoder\n    target_encoders: list[Union[VideoEncoder, tuple[VideoEncoder, GenericVSFunction]]]\n    indexer: Callable[[str], vs.VideoNode] | None = None\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; list[VideoFile]:\n        intermediary = self.encoder.encode(clip, get_workdir() / \"intermediary\")\n        from vsmuxtools import src as src_index\n\n        index_clip = self.indexer(str(intermediary.file)) if self.indexer else src_index(intermediary.file, force_lsmas=True)\n\n        outputs = list[VideoFile]()\n\n        for target in self.target_encoders:\n            temp_clip = temp_clip = target[1](index_clip) if isinstance(target, tuple) else index_clip\n            encoder = target[0] if isinstance(target, tuple) else target\n            result = encoder.encode(temp_clip)\n            outputs.append(result)\n\n        return outputs\n</code></pre>"},{"location":"vs-muxtools/video/encoders/intermediary/#vsmuxtools.video.encoders.intermediary.ProResIntermediary","title":"<code>ProResIntermediary</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code></p> <p>This encodes to prores first and will upscale chroma to 422 with point if needed and undo it before passing to other encoders.</p> <p>Parameters:</p> Name Type Description Default <code>target_encoders</code> <p>Target encoders to use. You can also pass a tuple with a function to call on the clips before running. For example: (x265(), lambda clip: clip.nlm_cuda.NLMeans(h=2.0))</p> required <code>indexer</code> <p>Here you can pass a custom indexing function ala FileInfo. Uses vsmuxtools.src otherwise.</p> required <code>profile</code> <p>The encoder profile. Basically Quality settings. Chooses the Standard/Default profile for 422 and the '4444' profile for 444 clips if None.</p> required Source code in <code>           vsmuxtools/video/encoders/intermediary.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass ProResIntermediary(VideoEncoder):\n    \"\"\"\n    This encodes to prores first and will upscale chroma to 422 with point if needed and undo it before passing to other encoders.\n\n    :param target_encoders:     Target encoders to use. You can also pass a tuple with a function to call on the clips before running.\n                                For example: (x265(), lambda clip: clip.nlm_cuda.NLMeans(h=2.0))\n\n    :param indexer:             Here you can pass a custom indexing function ala FileInfo. Uses vsmuxtools.src otherwise.\n\n    :param profile:             The encoder profile. Basically Quality settings.\n                                Chooses the Standard/Default profile for 422 and the '4444' profile for 444 clips if None.\n    \"\"\"\n\n    target_encoders: list[VideoEncoder]\n    indexer: Callable[[str], vs.VideoNode] | None = None\n    profile: ProResProfile | int | None = None\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; list[VideoFile]:\n        clipf = get_video_format(clip)\n        try:\n            from vskernels import Point\n        except:\n            raise error(\"You need to install vskernels for this\", self)\n        if clipf.subsampling_h != 0:\n            clip = Point.resample(clip, format=clipf.replace(subsampling_h=0))\n\n        encoder = IntermediaryEncoder(\n            ProRes(self.profile),\n            self.target_encoders\n            if clipf.subsampling_h == 0\n            else [(enc, lambda x: depth(Point.resample(x, clipf), 10)) for enc in self.target_encoders],\n            self.indexer,\n        )\n        return encoder.encode(clip)\n</code></pre>"},{"location":"vs-muxtools/video/encoders/standalone/","title":"standlone","text":""},{"location":"vs-muxtools/video/encoders/standalone/#vsmuxtools.video.encoders.standalone.x264","title":"<code>x264</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SupportsQP</code></p> <p>Encodes your clip to an avc/h264 file using x264.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>str | PathLike | None</code> <p>This will by default try to look for an <code>x264_settings</code> file in your cwd. If it doesn't find one it will warn you and resort to the default settings_builder preset. You can either pass settings as usual or a filepath here. If the filepath doesn't exist it will assume you passed actual settings and pass those to the encoder.</p> <code>None</code> <code>zones</code> <code>Zone | list[Zone] | None</code> <p>With this you can tweak settings of specific regions of the video. In x264 this includes but is not limited to CRF. For example (100, 300, \"crf\", 12) or [(100, 300, \"crf\", 12), (500, 750, 1.3)] If the third part is not a string it will assume a bitrate multiplier (or \"b\")</p> <code>None</code> <code>qp_file</code> <code>PathLike | bool | None</code> <p>Here you can pass a bool to en/disable or an existing filepath for one.</p> <code>None</code> <code>qp_clip</code> <code>src_file | VideoNode | None</code> <p>Can either be a straight up VideoNode or a SRC_FILE/FileInfo from this package. If neither a clip or a file are given it will simply skip. If only a clip is given it will generate one.</p> <code>None</code> <code>add_props</code> <code>bool | None</code> <p>This will explicitly add all props taken from the clip to the command line. This will be disabled by default if you are using a file and otherwise enabled. Files can have their own tokens like in vs-encode/vardautomation that will be filled in.</p> <code>None</code> <code>sar</code> <code>str | None</code> <p>Here you can pass your Pixel / Sample Aspect Ratio. This will overwrite whatever is in the clip if passed.</p> <code>None</code> <code>resumable</code> <p>Enable or disable resumable encodes. Very useful for people that have scripts that crash their PC (skill issue tbh)</p> required Source code in <code>           vsmuxtools/video/encoders/standalone.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass x264(SupportsQP):\n    \"\"\"\n    Encodes your clip to an avc/h264 file using x264.\n\n    :param settings:            This will by default try to look for an `x264_settings` file in your cwd.\n                                If it doesn't find one it will warn you and resort to the default settings_builder preset.\n                                You can either pass settings as usual or a filepath here.\n                                If the filepath doesn't exist it will assume you passed actual settings and pass those to the encoder.\n\n    :param zones:               With this you can tweak settings of specific regions of the video.\n                                In x264 this includes but is not limited to CRF.\n                                For example (100, 300, \"crf\", 12) or [(100, 300, \"crf\", 12), (500, 750, 1.3)]\n                                If the third part is not a string it will assume a bitrate multiplier (or \"b\")\n\n    :param qp_file:             Here you can pass a bool to en/disable or an existing filepath for one.\n    :param qp_clip:             Can either be a straight up VideoNode or a SRC_FILE/FileInfo from this package.\n                                If neither a clip or a file are given it will simply skip.\n                                If only a clip is given it will generate one.\n\n    :param add_props:           This will explicitly add all props taken from the clip to the command line.\n                                This will be disabled by default if you are using a file and otherwise enabled.\n                                Files can have their own tokens like in vs-encode/vardautomation that will be filled in.\n\n    :param sar:                 Here you can pass your Pixel / Sample Aspect Ratio. This will overwrite whatever is in the clip if passed.\n    :param resumable:           Enable or disable resumable encodes. Very useful for people that have scripts that crash their PC (skill issue tbh)\n    \"\"\"\n\n    resumable: bool = True\n    x265 = False\n\n    def __post_init__(self):\n        self.executable = get_executable(\"x264\")\n        self._init_settings(self.x265)\n\n    def _encode_clip(self, clip: vs.VideoNode, out: Path, qpfile: str, start_frame: int = 0) -&gt; Path:\n        args = [self.executable, \"-o\", str(out.resolve())]\n        if qpfile:\n            args.extend([\"--qpfile\", qpfile])\n        if self.settings:\n            args.extend(self.settings if isinstance(self.settings, list) else shlex.split(self.settings))\n        if self.zones:\n            self.zones = norm_zones(clip, self.zones)\n            if start_frame:\n                self.zones = shift_zones(self.zones, start_frame)\n            args.extend(zones_to_args(self.zones, False))\n        args.extend(self.get_custom_args() + [\"--demuxer\", \"y4m\", \"-\"])\n\n        process = subprocess.Popen(args, stdin=subprocess.PIPE)\n        self.update_process_affinity(process.pid)\n        clip.output(process.stdin, y4m=True)\n        process.communicate()\n        return out\n</code></pre>"},{"location":"vs-muxtools/video/encoders/standalone/#vsmuxtools.video.encoders.standalone.x265","title":"<code>x265</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SupportsQP</code></p> <p>Encodes your clip to an hevc/h265 file using x265.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>str | PathLike | None</code> <p>This will by default try to look for an <code>x265_settings</code> file in your cwd. If it doesn't find one it will warn you and resort to the default settings_builder preset. You can either pass settings as usual or a filepath here. If the filepath doesn't exist it will assume you passed actual settings and pass those to the encoder.</p> <code>None</code> <code>zones</code> <code>Zone | list[Zone] | None</code> <p>With this you can tweak settings of specific regions of the video. In x265 you're basically limited to a flat bitrate multiplier or force QP (\"q\") For example (100, 300, \"b\", 1.2) or [(100, 300, \"q\", 12), (500, 750, 1.3)] If the third part is not a string it will assume a bitrate multiplier (or \"b\")</p> <code>None</code> <code>qp_file</code> <code>PathLike | bool | None</code> <p>Here you can pass a bool to en/disable or an existing filepath for one.</p> <code>None</code> <code>qp_clip</code> <code>src_file | VideoNode | None</code> <p>Can either be a straight up VideoNode or a SRC_FILE/FileInfo from this package. If neither a clip or a file are given it will simply skip. If only a clip is given it will generate one.</p> <code>None</code> <code>add_props</code> <code>bool | None</code> <p>This will explicitly add all props taken from the clip to the command line. This will be disabled by default if you are using a file and otherwise enabled. Files can have their own tokens like in vs-encode/vardautomation that will be filled in.</p> <code>None</code> <code>sar</code> <code>str | None</code> <p>Here you can pass your Pixel / Sample Aspect Ratio. This will overwrite whatever is in the clip if passed.</p> <code>None</code> <code>resumable</code> <p>Enable or disable resumable encodes. Very useful for people that have scripts that crash their PC (skill issue tbh)</p> required <code>csv</code> <p>Either a bool to enable or disable csv logging or a Filepath for said csv.</p> required Source code in <code>           vsmuxtools/video/encoders/standalone.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass x265(SupportsQP):\n    \"\"\"\n    Encodes your clip to an hevc/h265 file using x265.\n\n    :param settings:            This will by default try to look for an `x265_settings` file in your cwd.\n                                If it doesn't find one it will warn you and resort to the default settings_builder preset.\n                                You can either pass settings as usual or a filepath here.\n                                If the filepath doesn't exist it will assume you passed actual settings and pass those to the encoder.\n\n    :param zones:               With this you can tweak settings of specific regions of the video.\n                                In x265 you're basically limited to a flat bitrate multiplier or force QP (\"q\")\n                                For example (100, 300, \"b\", 1.2) or [(100, 300, \"q\", 12), (500, 750, 1.3)]\n                                If the third part is not a string it will assume a bitrate multiplier (or \"b\")\n\n    :param qp_file:             Here you can pass a bool to en/disable or an existing filepath for one.\n    :param qp_clip:             Can either be a straight up VideoNode or a SRC_FILE/FileInfo from this package.\n                                If neither a clip or a file are given it will simply skip.\n                                If only a clip is given it will generate one.\n\n    :param add_props:           This will explicitly add all props taken from the clip to the command line.\n                                This will be disabled by default if you are using a file and otherwise enabled.\n                                Files can have their own tokens like in vs-encode/vardautomation that will be filled in.\n\n    :param sar:                 Here you can pass your Pixel / Sample Aspect Ratio. This will overwrite whatever is in the clip if passed.\n    :param resumable:           Enable or disable resumable encodes. Very useful for people that have scripts that crash their PC (skill issue tbh)\n    :param csv:                 Either a bool to enable or disable csv logging or a Filepath for said csv.\n    \"\"\"\n\n    resumable: bool = True\n    csv: bool | PathLike = True\n    x265 = True\n\n    def __post_init__(self):\n        self.executable = get_executable(\"x265\")\n        self._init_settings(self.x265)\n\n    def _encode_clip(self, clip: vs.VideoNode, out: Path, qpfile: str, start_frame: int = 0) -&gt; Path:\n        args = [self.executable, \"-o\", str(out.resolve())]\n        if self.csv:\n            if isinstance(self.csv, bool):\n                show_name = get_setup_attr(\"show_name\", \"\")\n                csv_file = Path(show_name + f\"{'_' if show_name else ''}log_x265.csv\").resolve()\n            else:\n                csv_file = ensure_path(self.csv, self)\n            args.extend([\"--csv\", str(csv_file)])\n        if qpfile:\n            args.extend([\"--qpfile\", qpfile])\n        if self.settings:\n            args.extend(self.settings if isinstance(self.settings, list) else shlex.split(self.settings))\n        if self.zones:\n            self.zones = norm_zones(clip, self.zones)\n            if start_frame:\n                self.zones = shift_zones(self.zones, start_frame)\n            args.extend(zones_to_args(self.zones, True))\n        args.extend(self.get_custom_args() + [\"--y4m\", \"--input\", \"-\"])\n\n        process = subprocess.Popen(args, stdin=subprocess.PIPE)\n        self.update_process_affinity(process.pid)\n        clip.output(process.stdin, y4m=True)\n        process.communicate()\n        return out\n</code></pre>"},{"location":"vs-muxtools/video/encoders/standalone/#vsmuxtools.video.encoders.standalone.LosslessX264","title":"<code>LosslessX264</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code></p> <p>Uses x264 to encode clip to a lossless avc stream.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <p>Can either be a string of some x264 preset or any of the 3 predefined presets.</p> required <code>settings</code> <p>Any other settings you might want to pass. Entirely optional.</p> required <code>add_props</code> <p>This will explicitly add all props taken from the clip to the command line.</p> required Source code in <code>           vsmuxtools/video/encoders/standalone.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass LosslessX264(VideoEncoder):\n    \"\"\"\n    Uses x264 to encode clip to a lossless avc stream.\n\n    :param preset:          Can either be a string of some x264 preset or any of the 3 predefined presets.\n    :param settings:        Any other settings you might want to pass. Entirely optional.\n    :param add_props:       This will explicitly add all props taken from the clip to the command line.\n    \"\"\"\n\n    preset: str | LosslessPreset = LosslessPreset.MIDDLEGROUND\n    settings: str | None = None\n    add_props: bool = True\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        out = make_output(\"lossless\", \"264\", user_passed=outfile)\n        match self.preset:\n            case LosslessPreset.SPEED:\n                preset = \"ultrafast\"\n            case LosslessPreset.COMPRESSION:\n                preset = \"veryslow\"\n            case LosslessPreset.MIDDLEGROUND:\n                preset = \"medium\"\n            case _:\n                preset = self.preset\n        settings = [\"--preset\", preset, \"--qp\", \"0\"] + self.get_custom_args()\n        if clip.format.bits_per_sample &gt; 10:\n            warn(\"This encoder does not support a bit depth over 10.\\nClip will be dithered to 10 bit.\", self, 2)\n            clip = finalize_clip(clip, 10)\n\n        if self.settings:\n            settings.extend(shlex.split(self.settings))\n        avc = x264(shlex.join(settings), add_props=self.add_props, resumable=False)\n        avc._update_settings(clip, False)\n        avc._encode_clip(clip, out, None, 0)\n        return VideoFile(out)\n</code></pre>"},{"location":"vs-muxtools/video/encoders/standalone/#vsmuxtools.video.encoders.standalone.SVTAV1","title":"<code>SVTAV1</code>  <code>dataclass</code>","text":"<p>               Bases: <code>VideoEncoder</code></p> <p>Uses SVtAv1EncApp to encode clip to a av1 stream.</p> <p>Do not use this for high fidelity encoding.</p> <p>For better explanations of params, check the <code>--help</code> of the encoder or the gitlab wiki page.</p> <p>Parameters:</p> Name Type Description Default <code>preset</code> <p>Encoder preset. Lower = slower &amp; better The range is -1 to 13 for the regular SVTAV1 and -3 to 13 for SVTAV1-PSY</p> required <code>crf</code> <p>Constant rate factor, lower = better</p> required <code>tune</code> <p>The tuning metric. None = 2 for SVTAV1 and 3 for SVTAV1-PSY</p> required <code>qp_clip</code> <p>Can either be a straight up VideoNode or a SRC_FILE/FileInfo from this package. It is highly recommended to do this so you can force keyframes.</p> required Source code in <code>           vsmuxtools/video/encoders/standalone.py         </code> <pre><code>@dataclass(config=allow_extra)\nclass SVTAV1(VideoEncoder):\n    \"\"\"\n    Uses SVtAv1EncApp to encode clip to a av1 stream.\\n\n    Do not use this for high fidelity encoding.\\n\n    For better explanations of params, check the `--help` of the encoder or the gitlab wiki page.\n\n    :param preset:          Encoder preset. Lower = slower &amp; better\n                            The range is -1 to 13 for the regular SVTAV1 and -3 to 13 for SVTAV1-PSY\n    :param crf:             Constant rate factor, lower = better\n    :param tune:            The tuning metric. None = 2 for SVTAV1 and 3 for SVTAV1-PSY\n\n    :param qp_clip:         Can either be a straight up VideoNode or a SRC_FILE/FileInfo from this package.\n                            It is highly recommended to do this so you can force keyframes.\n    \"\"\"\n\n    preset: int = 4\n    crf: int | float = 15\n    tune: int | None = None\n    qp_clip: vs.VideoNode | src_file | None = None\n\n    def __post_init__(self):\n        self.executable = get_executable(\"SvtAv1EncApp\")\n        if self.get_process_affinity() is False:\n            self.affinity = []\n        if not self.qp_clip:\n            warn(\"It is highly recommended to force keyframes with this encoder!\\nPlease pass a qp_clip param.\", self, 2)\n\n    def _make_keyframes_config(self, clip: vs.VideoNode) -&gt; Path | bool:\n        out = get_workdir() / \"svt_keyframes.cfg\"\n        if out.exists():\n            info(\"Reusing existing keyframes config.\", self)\n            return out\n        info(\"Generating keyframes config file...\", self)\n\n        keyframes = generate_keyframes(clip)\n        if not keyframes:\n            return False\n        keyframes_str = f\"ForceKeyFrames : {'f,'.join([str(i) for i in keyframes])}f\"\n        with open(out, \"w\", encoding=\"utf-8\") as f:\n            f.write(keyframes_str)\n\n        info(\"Done\", self)\n        return out\n\n    def encode(self, clip: vs.VideoNode, outfile: PathLike | None = None) -&gt; VideoFile:\n        from vsmuxtools.video.clip_metadata import props_dict, SVT_AV1_RANGES\n\n        clip_props = props_dict(clip, False, SVT_AV1_RANGES)\n        output = make_output(\"svtav1\", ext=\"ivf\", user_passed=outfile)\n        encoder = get_binary_version(self.executable, r\"(SVT-AV1.+?(?:v\\d+.\\d+.\\d[^ ]+|[0-9a-f]{8,40}))\", [\"--version\"])\n        tags = dict[str, str](ENCODER=encoder)\n        args = [self.executable, \"-i\", \"-\", \"--output\", str(output), \"--preset\", str(self.preset)]\n        if self.qp_clip:\n            qp_clip = self.qp_clip if isinstance(self.qp_clip, vs.VideoNode) else self.qp_clip.src_cut\n            keyframes_config = self._make_keyframes_config(qp_clip)\n            if keyframes_config:\n                args.extend([\"--keyint\", \"-1\", \"-c\", str(keyframes_config)])\n            else:\n                warn(\"No keyframes found.\", self)\n\n        if self.crf:\n            args.extend([\"--crf\", str(self.crf)])\n\n        if self.tune is None:\n            self.tune = 3 if \"psy\" in encoder.lower() else 2\n\n        args.extend([\"--tune\", str(self.tune)])\n\n        # fmt:off\n        args.extend(self.get_custom_args() + [\n            \"--fps-num\", clip_props.get(\"fps_num\"),\n            \"--fps-denom\", clip_props.get(\"fps_den\"),\n            \"--input-depth\", clip_props.get(\"depth\"),\n            \"--chroma-sample-position\", clip_props.get(\"chromaloc\"),\n            \"--color-primaries\", clip_props.get(\"primaries\"),\n            \"--transfer-characteristics\", clip_props.get(\"transfer\"),\n            \"--matrix-coefficients\", clip_props.get(\"colormatrix\"),\n            \"--color-range\", clip_props.get(\"range\")\n        ])\n        # fmt: on\n\n        process = subprocess.Popen(args, stdin=subprocess.PIPE)\n        self.update_process_affinity(process.pid)\n        clip.output(process.stdin, y4m=True)\n        process.communicate()\n        tags.update(ENCODER_SETTINGS=self.get_mediainfo_settings(args))\n        return VideoFile(output, tags=tags)\n</code></pre>"},{"location":"vs-muxtools/video/encoders/types/","title":"types","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.__all__","title":"<code>__all__ = ['LosslessPreset', 'ProResProfile']</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ZoneFrame","title":"<code>ZoneFrame = Union[int, None]</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.Zone","title":"<code>Zone = tuple[ZoneFrame, ZoneFrame, float | str] | tuple[ZoneFrame, ZoneFrame, str, float | int | str]</code>  <code>module-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.LosslessPreset","title":"<code>LosslessPreset</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>           vsmuxtools/video/encoders/types.py         </code> <pre><code>class LosslessPreset(IntEnum):\n    SPEED = 1\n    COMPRESSION = 2\n    MIDDLEGROUND = 3\n</code></pre>"},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.LosslessPreset.SPEED","title":"<code>SPEED = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.LosslessPreset.COMPRESSION","title":"<code>COMPRESSION = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.LosslessPreset.MIDDLEGROUND","title":"<code>MIDDLEGROUND = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile","title":"<code>ProResProfile</code>","text":"<p>               Bases: <code>IntEnum</code></p> Source code in <code>           vsmuxtools/video/encoders/types.py         </code> <pre><code>class ProResProfile(IntEnum):\n    AUTO = -1\n    PROXY = 0\n    LT = 1\n    DEFAULT = 2\n    HQ = 3\n    P4444 = 4\n    P4444XQ = 5\n</code></pre>"},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.AUTO","title":"<code>AUTO = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.PROXY","title":"<code>PROXY = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.LT","title":"<code>LT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.DEFAULT","title":"<code>DEFAULT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.HQ","title":"<code>HQ = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.P4444","title":"<code>P4444 = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"vs-muxtools/video/encoders/types/#vsmuxtools.video.encoders.types.ProResProfile.P4444XQ","title":"<code>P4444XQ = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""}]}